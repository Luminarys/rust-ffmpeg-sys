/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _ERRNO_H: libc::c_int = 1;
pub const _FEATURES_H: libc::c_int = 1;
pub const _DEFAULT_SOURCE: libc::c_int = 1;
pub const __USE_ISOC11: libc::c_int = 1;
pub const __USE_ISOC99: libc::c_int = 1;
pub const __USE_ISOC95: libc::c_int = 1;
pub const __USE_POSIX_IMPLICITLY: libc::c_int = 1;
pub const _POSIX_SOURCE: libc::c_int = 1;
pub const _POSIX_C_SOURCE: libc::c_int = 200809;
pub const __USE_POSIX: libc::c_int = 1;
pub const __USE_POSIX2: libc::c_int = 1;
pub const __USE_POSIX199309: libc::c_int = 1;
pub const __USE_POSIX199506: libc::c_int = 1;
pub const __USE_XOPEN2K: libc::c_int = 1;
pub const __USE_XOPEN2K8: libc::c_int = 1;
pub const _ATFILE_SOURCE: libc::c_int = 1;
pub const __USE_MISC: libc::c_int = 1;
pub const __USE_ATFILE: libc::c_int = 1;
pub const __USE_FORTIFY_LEVEL: libc::c_int = 0;
pub const _STDC_PREDEF_H: libc::c_int = 1;
pub const __STDC_IEC_559__: libc::c_int = 1;
pub const __STDC_IEC_559_COMPLEX__: libc::c_int = 1;
pub const __STDC_ISO_10646__: libc::c_int = 201505;
pub const __STDC_NO_THREADS__: libc::c_int = 1;
pub const __GNU_LIBRARY__: libc::c_int = 6;
pub const __GLIBC__: libc::c_int = 2;
pub const __GLIBC_MINOR__: libc::c_int = 25;
pub const _SYS_CDEFS_H: libc::c_int = 1;
pub const __glibc_c99_flexarr_available: libc::c_int = 1;
pub const __WORDSIZE: libc::c_int = 64;
pub const __WORDSIZE_TIME64_COMPAT32: libc::c_int = 1;
pub const __SYSCALL_WORDSIZE: libc::c_int = 64;
pub const EPERM: libc::c_int = 1;
pub const ENOENT: libc::c_int = 2;
pub const ESRCH: libc::c_int = 3;
pub const EINTR: libc::c_int = 4;
pub const EIO: libc::c_int = 5;
pub const ENXIO: libc::c_int = 6;
pub const E2BIG: libc::c_int = 7;
pub const ENOEXEC: libc::c_int = 8;
pub const EBADF: libc::c_int = 9;
pub const ECHILD: libc::c_int = 10;
pub const EAGAIN: libc::c_int = 11;
pub const ENOMEM: libc::c_int = 12;
pub const EACCES: libc::c_int = 13;
pub const EFAULT: libc::c_int = 14;
pub const ENOTBLK: libc::c_int = 15;
pub const EBUSY: libc::c_int = 16;
pub const EEXIST: libc::c_int = 17;
pub const EXDEV: libc::c_int = 18;
pub const ENODEV: libc::c_int = 19;
pub const ENOTDIR: libc::c_int = 20;
pub const EISDIR: libc::c_int = 21;
pub const EINVAL: libc::c_int = 22;
pub const ENFILE: libc::c_int = 23;
pub const EMFILE: libc::c_int = 24;
pub const ENOTTY: libc::c_int = 25;
pub const ETXTBSY: libc::c_int = 26;
pub const EFBIG: libc::c_int = 27;
pub const ENOSPC: libc::c_int = 28;
pub const ESPIPE: libc::c_int = 29;
pub const EROFS: libc::c_int = 30;
pub const EMLINK: libc::c_int = 31;
pub const EPIPE: libc::c_int = 32;
pub const EDOM: libc::c_int = 33;
pub const ERANGE: libc::c_int = 34;
pub const EDEADLK: libc::c_int = 35;
pub const ENAMETOOLONG: libc::c_int = 36;
pub const ENOLCK: libc::c_int = 37;
pub const ENOSYS: libc::c_int = 38;
pub const ENOTEMPTY: libc::c_int = 39;
pub const ELOOP: libc::c_int = 40;
pub const EWOULDBLOCK: libc::c_int = 11;
pub const ENOMSG: libc::c_int = 42;
pub const EIDRM: libc::c_int = 43;
pub const ECHRNG: libc::c_int = 44;
pub const EL2NSYNC: libc::c_int = 45;
pub const EL3HLT: libc::c_int = 46;
pub const EL3RST: libc::c_int = 47;
pub const ELNRNG: libc::c_int = 48;
pub const EUNATCH: libc::c_int = 49;
pub const ENOCSI: libc::c_int = 50;
pub const EL2HLT: libc::c_int = 51;
pub const EBADE: libc::c_int = 52;
pub const EBADR: libc::c_int = 53;
pub const EXFULL: libc::c_int = 54;
pub const ENOANO: libc::c_int = 55;
pub const EBADRQC: libc::c_int = 56;
pub const EBADSLT: libc::c_int = 57;
pub const EDEADLOCK: libc::c_int = 35;
pub const EBFONT: libc::c_int = 59;
pub const ENOSTR: libc::c_int = 60;
pub const ENODATA: libc::c_int = 61;
pub const ETIME: libc::c_int = 62;
pub const ENOSR: libc::c_int = 63;
pub const ENONET: libc::c_int = 64;
pub const ENOPKG: libc::c_int = 65;
pub const EREMOTE: libc::c_int = 66;
pub const ENOLINK: libc::c_int = 67;
pub const EADV: libc::c_int = 68;
pub const ESRMNT: libc::c_int = 69;
pub const ECOMM: libc::c_int = 70;
pub const EPROTO: libc::c_int = 71;
pub const EMULTIHOP: libc::c_int = 72;
pub const EDOTDOT: libc::c_int = 73;
pub const EBADMSG: libc::c_int = 74;
pub const EOVERFLOW: libc::c_int = 75;
pub const ENOTUNIQ: libc::c_int = 76;
pub const EBADFD: libc::c_int = 77;
pub const EREMCHG: libc::c_int = 78;
pub const ELIBACC: libc::c_int = 79;
pub const ELIBBAD: libc::c_int = 80;
pub const ELIBSCN: libc::c_int = 81;
pub const ELIBMAX: libc::c_int = 82;
pub const ELIBEXEC: libc::c_int = 83;
pub const EILSEQ: libc::c_int = 84;
pub const ERESTART: libc::c_int = 85;
pub const ESTRPIPE: libc::c_int = 86;
pub const EUSERS: libc::c_int = 87;
pub const ENOTSOCK: libc::c_int = 88;
pub const EDESTADDRREQ: libc::c_int = 89;
pub const EMSGSIZE: libc::c_int = 90;
pub const EPROTOTYPE: libc::c_int = 91;
pub const ENOPROTOOPT: libc::c_int = 92;
pub const EPROTONOSUPPORT: libc::c_int = 93;
pub const ESOCKTNOSUPPORT: libc::c_int = 94;
pub const EOPNOTSUPP: libc::c_int = 95;
pub const EPFNOSUPPORT: libc::c_int = 96;
pub const EAFNOSUPPORT: libc::c_int = 97;
pub const EADDRINUSE: libc::c_int = 98;
pub const EADDRNOTAVAIL: libc::c_int = 99;
pub const ENETDOWN: libc::c_int = 100;
pub const ENETUNREACH: libc::c_int = 101;
pub const ENETRESET: libc::c_int = 102;
pub const ECONNABORTED: libc::c_int = 103;
pub const ECONNRESET: libc::c_int = 104;
pub const ENOBUFS: libc::c_int = 105;
pub const EISCONN: libc::c_int = 106;
pub const ENOTCONN: libc::c_int = 107;
pub const ESHUTDOWN: libc::c_int = 108;
pub const ETOOMANYREFS: libc::c_int = 109;
pub const ETIMEDOUT: libc::c_int = 110;
pub const ECONNREFUSED: libc::c_int = 111;
pub const EHOSTDOWN: libc::c_int = 112;
pub const EHOSTUNREACH: libc::c_int = 113;
pub const EALREADY: libc::c_int = 114;
pub const EINPROGRESS: libc::c_int = 115;
pub const ESTALE: libc::c_int = 116;
pub const EUCLEAN: libc::c_int = 117;
pub const ENOTNAM: libc::c_int = 118;
pub const ENAVAIL: libc::c_int = 119;
pub const EISNAM: libc::c_int = 120;
pub const EREMOTEIO: libc::c_int = 121;
pub const EDQUOT: libc::c_int = 122;
pub const ENOMEDIUM: libc::c_int = 123;
pub const EMEDIUMTYPE: libc::c_int = 124;
pub const ECANCELED: libc::c_int = 125;
pub const ENOKEY: libc::c_int = 126;
pub const EKEYEXPIRED: libc::c_int = 127;
pub const EKEYREVOKED: libc::c_int = 128;
pub const EKEYREJECTED: libc::c_int = 129;
pub const EOWNERDEAD: libc::c_int = 130;
pub const ENOTRECOVERABLE: libc::c_int = 131;
pub const ERFKILL: libc::c_int = 132;
pub const EHWPOISON: libc::c_int = 133;
pub const ENOTSUP: libc::c_int = 95;
pub const _STDINT_H: libc::c_int = 1;
pub const __GLIBC_USE_LIB_EXT2: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: libc::c_int = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: libc::c_int = 0;
pub const _BITS_TYPES_H: libc::c_int = 1;
pub const _BITS_TYPESIZES_H: libc::c_int = 1;
pub const __OFF_T_MATCHES_OFF64_T: libc::c_int = 1;
pub const __INO_T_MATCHES_INO64_T: libc::c_int = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: libc::c_int = 1;
pub const __FD_SETSIZE: libc::c_int = 1024;
pub const _BITS_WCHAR_H: libc::c_int = 1;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT8_MAX: libc::c_int = 127;
pub const INT16_MAX: libc::c_int = 32767;
pub const INT32_MAX: libc::c_int = 2147483647;
pub const UINT8_MAX: libc::c_int = 255;
pub const UINT16_MAX: libc::c_int = 65535;
pub const UINT32_MAX: libc::c_uint = 4294967295;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: libc::c_int = 127;
pub const INT_LEAST16_MAX: libc::c_int = 32767;
pub const INT_LEAST32_MAX: libc::c_int = 2147483647;
pub const UINT_LEAST8_MAX: libc::c_int = 255;
pub const UINT_LEAST16_MAX: libc::c_int = 65535;
pub const UINT_LEAST32_MAX: libc::c_uint = 4294967295;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_int = 127;
pub const INT_FAST16_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_int = 255;
pub const UINT_FAST16_MAX: libc::c_int = -1;
pub const UINT_FAST32_MAX: libc::c_int = -1;
pub const INTPTR_MIN: libc::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_int = 2147483647;
pub const SIZE_MAX: libc::c_int = -1;
pub const WINT_MIN: libc::c_int = 0;
pub const WINT_MAX: libc::c_uint = 4294967295;
pub const FF_LAMBDA_SHIFT: libc::c_int = 7;
pub const FF_LAMBDA_SCALE: libc::c_int = 128;
pub const FF_QP2LAMBDA: libc::c_int = 118;
pub const FF_LAMBDA_MAX: libc::c_int = 32767;
pub const FF_QUALITY_SCALE: libc::c_int = 128;
pub const AV_TIME_BASE: libc::c_int = 1000000;
pub const _INTTYPES_H: libc::c_int = 1;
pub const ____gwchar_t_defined: libc::c_int = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const PRId8: &'static [u8; 2usize] = b"d\x00";
pub const PRId16: &'static [u8; 2usize] = b"d\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRId64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIi8: &'static [u8; 2usize] = b"i\x00";
pub const PRIi16: &'static [u8; 2usize] = b"i\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIi64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIo8: &'static [u8; 2usize] = b"o\x00";
pub const PRIo16: &'static [u8; 2usize] = b"o\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIo64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIu8: &'static [u8; 2usize] = b"u\x00";
pub const PRIu16: &'static [u8; 2usize] = b"u\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIu64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIx8: &'static [u8; 2usize] = b"x\x00";
pub const PRIx16: &'static [u8; 2usize] = b"x\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIx64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIX8: &'static [u8; 2usize] = b"X\x00";
pub const PRIX16: &'static [u8; 2usize] = b"X\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRIX64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNd64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNi64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNu64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNo64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNx64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const _LIBC_LIMITS_H_: libc::c_int = 1;
pub const MB_LEN_MAX: libc::c_int = 16;
pub const _BITS_POSIX1_LIM_H: libc::c_int = 1;
pub const _POSIX_AIO_LISTIO_MAX: libc::c_int = 2;
pub const _POSIX_AIO_MAX: libc::c_int = 1;
pub const _POSIX_ARG_MAX: libc::c_int = 4096;
pub const _POSIX_CHILD_MAX: libc::c_int = 25;
pub const _POSIX_DELAYTIMER_MAX: libc::c_int = 32;
pub const _POSIX_HOST_NAME_MAX: libc::c_int = 255;
pub const _POSIX_LINK_MAX: libc::c_int = 8;
pub const _POSIX_LOGIN_NAME_MAX: libc::c_int = 9;
pub const _POSIX_MAX_CANON: libc::c_int = 255;
pub const _POSIX_MAX_INPUT: libc::c_int = 255;
pub const _POSIX_MQ_OPEN_MAX: libc::c_int = 8;
pub const _POSIX_MQ_PRIO_MAX: libc::c_int = 32;
pub const _POSIX_NAME_MAX: libc::c_int = 14;
pub const _POSIX_NGROUPS_MAX: libc::c_int = 8;
pub const _POSIX_OPEN_MAX: libc::c_int = 20;
pub const _POSIX_PATH_MAX: libc::c_int = 256;
pub const _POSIX_PIPE_BUF: libc::c_int = 512;
pub const _POSIX_RE_DUP_MAX: libc::c_int = 255;
pub const _POSIX_RTSIG_MAX: libc::c_int = 8;
pub const _POSIX_SEM_NSEMS_MAX: libc::c_int = 256;
pub const _POSIX_SEM_VALUE_MAX: libc::c_int = 32767;
pub const _POSIX_SIGQUEUE_MAX: libc::c_int = 32;
pub const _POSIX_SSIZE_MAX: libc::c_int = 32767;
pub const _POSIX_STREAM_MAX: libc::c_int = 8;
pub const _POSIX_SYMLINK_MAX: libc::c_int = 255;
pub const _POSIX_SYMLOOP_MAX: libc::c_int = 8;
pub const _POSIX_TIMER_MAX: libc::c_int = 32;
pub const _POSIX_TTY_NAME_MAX: libc::c_int = 9;
pub const _POSIX_TZNAME_MAX: libc::c_int = 6;
pub const _POSIX_CLOCKRES_MIN: libc::c_int = 20000000;
pub const NR_OPEN: libc::c_int = 1024;
pub const NGROUPS_MAX: libc::c_int = 65536;
pub const ARG_MAX: libc::c_int = 131072;
pub const LINK_MAX: libc::c_int = 127;
pub const MAX_CANON: libc::c_int = 255;
pub const MAX_INPUT: libc::c_int = 255;
pub const NAME_MAX: libc::c_int = 255;
pub const PATH_MAX: libc::c_int = 4096;
pub const PIPE_BUF: libc::c_int = 4096;
pub const XATTR_NAME_MAX: libc::c_int = 255;
pub const XATTR_SIZE_MAX: libc::c_int = 65536;
pub const XATTR_LIST_MAX: libc::c_int = 65536;
pub const RTSIG_MAX: libc::c_int = 32;
pub const _POSIX_THREAD_KEYS_MAX: libc::c_int = 128;
pub const PTHREAD_KEYS_MAX: libc::c_int = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: libc::c_int = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: libc::c_int = 4;
pub const _POSIX_THREAD_THREADS_MAX: libc::c_int = 64;
pub const AIO_PRIO_DELTA_MAX: libc::c_int = 20;
pub const PTHREAD_STACK_MIN: libc::c_int = 16384;
pub const DELAYTIMER_MAX: libc::c_int = 2147483647;
pub const TTY_NAME_MAX: libc::c_int = 32;
pub const LOGIN_NAME_MAX: libc::c_int = 256;
pub const HOST_NAME_MAX: libc::c_int = 64;
pub const MQ_PRIO_MAX: libc::c_int = 32768;
pub const SEM_VALUE_MAX: libc::c_int = 2147483647;
pub const _BITS_POSIX2_LIM_H: libc::c_int = 1;
pub const _POSIX2_BC_BASE_MAX: libc::c_int = 99;
pub const _POSIX2_BC_DIM_MAX: libc::c_int = 2048;
pub const _POSIX2_BC_SCALE_MAX: libc::c_int = 99;
pub const _POSIX2_BC_STRING_MAX: libc::c_int = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: libc::c_int = 2;
pub const _POSIX2_EXPR_NEST_MAX: libc::c_int = 32;
pub const _POSIX2_LINE_MAX: libc::c_int = 2048;
pub const _POSIX2_RE_DUP_MAX: libc::c_int = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: libc::c_int = 14;
pub const BC_BASE_MAX: libc::c_int = 99;
pub const BC_DIM_MAX: libc::c_int = 2048;
pub const BC_SCALE_MAX: libc::c_int = 99;
pub const BC_STRING_MAX: libc::c_int = 1000;
pub const COLL_WEIGHTS_MAX: libc::c_int = 255;
pub const EXPR_NEST_MAX: libc::c_int = 32;
pub const LINE_MAX: libc::c_int = 2048;
pub const CHARCLASS_NAME_MAX: libc::c_int = 2048;
pub const RE_DUP_MAX: libc::c_int = 32767;
pub const _MATH_H: libc::c_int = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: libc::c_int = 1;
pub const __FP_LOGB0_IS_MIN: libc::c_int = 1;
pub const __FP_LOGBNAN_IS_MIN: libc::c_int = 1;
pub const FP_ILOGB0: libc::c_int = -2147483648;
pub const FP_ILOGBNAN: libc::c_int = -2147483648;
pub const __MATH_DECLARING_DOUBLE: libc::c_int = 1;
pub const __MATH_DECLARE_LDOUBLE: libc::c_int = 1;
pub const MATH_ERRNO: libc::c_int = 1;
pub const MATH_ERREXCEPT: libc::c_int = 2;
pub const math_errhandling: libc::c_int = 3;
pub const DOMAIN: libc::c_int = 1;
pub const SING: libc::c_int = 2;
pub const OVERFLOW: libc::c_int = 3;
pub const UNDERFLOW: libc::c_int = 4;
pub const TLOSS: libc::c_int = 5;
pub const PLOSS: libc::c_int = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STDIO_H: libc::c_int = 1;
pub const __FILE_defined: libc::c_int = 1;
pub const ____FILE_defined: libc::c_int = 1;
pub const _G_config_h: libc::c_int = 1;
pub const ____mbstate_t_defined: libc::c_int = 1;
pub const _G_HAVE_MMAP: libc::c_int = 1;
pub const _G_HAVE_MREMAP: libc::c_int = 1;
pub const _G_IO_IO_FILE_VERSION: libc::c_int = 131073;
pub const _G_BUFSIZ: libc::c_int = 8192;
pub const _IO_BUFSIZ: libc::c_int = 8192;
pub const __GNUC_VA_LIST: libc::c_int = 1;
pub const _IO_UNIFIED_JUMPTABLES: libc::c_int = 1;
pub const EOF: libc::c_int = -1;
pub const _IOS_INPUT: libc::c_int = 1;
pub const _IOS_OUTPUT: libc::c_int = 2;
pub const _IOS_ATEND: libc::c_int = 4;
pub const _IOS_APPEND: libc::c_int = 8;
pub const _IOS_TRUNC: libc::c_int = 16;
pub const _IOS_NOCREATE: libc::c_int = 32;
pub const _IOS_NOREPLACE: libc::c_int = 64;
pub const _IOS_BIN: libc::c_int = 128;
pub const _IO_MAGIC: libc::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: libc::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: libc::c_uint = 4294901760;
pub const _IO_USER_BUF: libc::c_int = 1;
pub const _IO_UNBUFFERED: libc::c_int = 2;
pub const _IO_NO_READS: libc::c_int = 4;
pub const _IO_NO_WRITES: libc::c_int = 8;
pub const _IO_EOF_SEEN: libc::c_int = 16;
pub const _IO_ERR_SEEN: libc::c_int = 32;
pub const _IO_DELETE_DONT_CLOSE: libc::c_int = 64;
pub const _IO_LINKED: libc::c_int = 128;
pub const _IO_IN_BACKUP: libc::c_int = 256;
pub const _IO_LINE_BUF: libc::c_int = 512;
pub const _IO_TIED_PUT_GET: libc::c_int = 1024;
pub const _IO_CURRENTLY_PUTTING: libc::c_int = 2048;
pub const _IO_IS_APPENDING: libc::c_int = 4096;
pub const _IO_IS_FILEBUF: libc::c_int = 8192;
pub const _IO_BAD_SEEN: libc::c_int = 16384;
pub const _IO_USER_LOCK: libc::c_int = 32768;
pub const _IO_FLAGS2_MMAP: libc::c_int = 1;
pub const _IO_FLAGS2_NOTCANCEL: libc::c_int = 2;
pub const _IO_FLAGS2_USER_WBUF: libc::c_int = 8;
pub const _IO_SKIPWS: libc::c_int = 1;
pub const _IO_LEFT: libc::c_int = 2;
pub const _IO_RIGHT: libc::c_int = 4;
pub const _IO_INTERNAL: libc::c_int = 8;
pub const _IO_DEC: libc::c_int = 16;
pub const _IO_OCT: libc::c_int = 32;
pub const _IO_HEX: libc::c_int = 64;
pub const _IO_SHOWBASE: libc::c_int = 128;
pub const _IO_SHOWPOINT: libc::c_int = 256;
pub const _IO_UPPERCASE: libc::c_int = 512;
pub const _IO_SHOWPOS: libc::c_int = 1024;
pub const _IO_SCIENTIFIC: libc::c_int = 2048;
pub const _IO_FIXED: libc::c_int = 4096;
pub const _IO_UNITBUF: libc::c_int = 8192;
pub const _IO_STDIO: libc::c_int = 16384;
pub const _IO_DONT_CLOSE: libc::c_int = 32768;
pub const _IO_BOOLALPHA: libc::c_int = 65536;
pub const _IOFBF: libc::c_int = 0;
pub const _IOLBF: libc::c_int = 1;
pub const _IONBF: libc::c_int = 2;
pub const BUFSIZ: libc::c_int = 8192;
pub const SEEK_SET: libc::c_int = 0;
pub const SEEK_CUR: libc::c_int = 1;
pub const SEEK_END: libc::c_int = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: libc::c_int = 20;
pub const TMP_MAX: libc::c_int = 238328;
pub const FILENAME_MAX: libc::c_int = 4096;
pub const L_ctermid: libc::c_int = 9;
pub const FOPEN_MAX: libc::c_int = 16;
pub const _STDLIB_H: libc::c_int = 1;
pub const WNOHANG: libc::c_int = 1;
pub const WUNTRACED: libc::c_int = 2;
pub const WSTOPPED: libc::c_int = 2;
pub const WEXITED: libc::c_int = 4;
pub const WCONTINUED: libc::c_int = 8;
pub const WNOWAIT: libc::c_int = 16777216;
pub const __WNOTHREAD: libc::c_int = 536870912;
pub const __WALL: libc::c_int = 1073741824;
pub const __WCLONE: libc::c_uint = 2147483648;
pub const __W_CONTINUED: libc::c_int = 65535;
pub const __WCOREFLAG: libc::c_int = 128;
pub const __ldiv_t_defined: libc::c_int = 1;
pub const __lldiv_t_defined: libc::c_int = 1;
pub const RAND_MAX: libc::c_int = 2147483647;
pub const EXIT_FAILURE: libc::c_int = 1;
pub const EXIT_SUCCESS: libc::c_int = 0;
pub const _SYS_TYPES_H: libc::c_int = 1;
pub const __clock_t_defined: libc::c_int = 1;
pub const __clockid_t_defined: libc::c_int = 1;
pub const __time_t_defined: libc::c_int = 1;
pub const __timer_t_defined: libc::c_int = 1;
pub const __BIT_TYPES_DEFINED__: libc::c_int = 1;
pub const _ENDIAN_H: libc::c_int = 1;
pub const __LITTLE_ENDIAN: libc::c_int = 1234;
pub const __BIG_ENDIAN: libc::c_int = 4321;
pub const __PDP_ENDIAN: libc::c_int = 3412;
pub const __BYTE_ORDER: libc::c_int = 1234;
pub const __FLOAT_WORD_ORDER: libc::c_int = 1234;
pub const LITTLE_ENDIAN: libc::c_int = 1234;
pub const BIG_ENDIAN: libc::c_int = 4321;
pub const PDP_ENDIAN: libc::c_int = 3412;
pub const BYTE_ORDER: libc::c_int = 1234;
pub const _BITS_BYTESWAP_H: libc::c_int = 1;
pub const _BITS_UINTN_IDENTITY_H: libc::c_int = 1;
pub const _SYS_SELECT_H: libc::c_int = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: libc::c_int = 1;
pub const __timeval_defined: libc::c_int = 1;
pub const __timespec_defined: libc::c_int = 1;
pub const FD_SETSIZE: libc::c_int = 1024;
pub const _SYS_SYSMACROS_H: libc::c_int = 1;
pub const _BITS_SYSMACROS_H: libc::c_int = 1;
pub const _BITS_PTHREADTYPES_H: libc::c_int = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: libc::c_int = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: libc::c_int = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: libc::c_int = 4;
pub const __SIZEOF_PTHREAD_COND_T: libc::c_int = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: libc::c_int = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: libc::c_int = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: libc::c_int = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: libc::c_int = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: libc::c_int = 4;
pub const __have_pthread_attr_t: libc::c_int = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: libc::c_int = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: libc::c_int = 1;
pub const _ALLOCA_H: libc::c_int = 1;
pub const _STRING_H: libc::c_int = 1;
pub const _XLOCALE_H: libc::c_int = 1;
pub const LIBAVUTIL_VERSION_MAJOR: libc::c_int = 55;
pub const LIBAVUTIL_VERSION_MINOR: libc::c_int = 58;
pub const LIBAVUTIL_VERSION_MICRO: libc::c_int = 100;
pub const AV_HAVE_BIGENDIAN: libc::c_int = 0;
pub const AV_HAVE_FAST_UNALIGNED: libc::c_int = 1;
pub const AVERROR_EXPERIMENTAL: libc::c_int = -733130664;
pub const AVERROR_INPUT_CHANGED: libc::c_int = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: libc::c_int = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: usize = 64;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const AV_LOG_QUIET: libc::c_int = -8;
pub const AV_LOG_PANIC: libc::c_int = 0;
pub const AV_LOG_FATAL: libc::c_int = 8;
pub const AV_LOG_ERROR: libc::c_int = 16;
pub const AV_LOG_WARNING: libc::c_int = 24;
pub const AV_LOG_INFO: libc::c_int = 32;
pub const AV_LOG_VERBOSE: libc::c_int = 40;
pub const AV_LOG_DEBUG: libc::c_int = 48;
pub const AV_LOG_TRACE: libc::c_int = 56;
pub const AV_LOG_MAX_OFFSET: libc::c_int = 64;
pub const AV_LOG_SKIP_REPEATED: libc::c_int = 1;
pub const AV_LOG_PRINT_LEVEL: libc::c_int = 2;
pub const AVPALETTE_SIZE: libc::c_int = 1024;
pub const AVPALETTE_COUNT: libc::c_int = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: libc::c_int = 32;
pub const AV_BUFFER_FLAG_READONLY: libc::c_int = 1;
pub const AV_CPU_FLAG_FORCE: libc::c_uint = 2147483648;
pub const AV_CPU_FLAG_MMX: libc::c_int = 1;
pub const AV_CPU_FLAG_MMXEXT: libc::c_int = 2;
pub const AV_CPU_FLAG_MMX2: libc::c_int = 2;
pub const AV_CPU_FLAG_3DNOW: libc::c_int = 4;
pub const AV_CPU_FLAG_SSE: libc::c_int = 8;
pub const AV_CPU_FLAG_SSE2: libc::c_int = 16;
pub const AV_CPU_FLAG_SSE2SLOW: libc::c_int = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: libc::c_int = 32;
pub const AV_CPU_FLAG_SSE3: libc::c_int = 64;
pub const AV_CPU_FLAG_SSE3SLOW: libc::c_int = 536870912;
pub const AV_CPU_FLAG_SSSE3: libc::c_int = 128;
pub const AV_CPU_FLAG_SSSE3SLOW: libc::c_int = 67108864;
pub const AV_CPU_FLAG_ATOM: libc::c_int = 268435456;
pub const AV_CPU_FLAG_SSE4: libc::c_int = 256;
pub const AV_CPU_FLAG_SSE42: libc::c_int = 512;
pub const AV_CPU_FLAG_AESNI: libc::c_int = 524288;
pub const AV_CPU_FLAG_AVX: libc::c_int = 16384;
pub const AV_CPU_FLAG_AVXSLOW: libc::c_int = 134217728;
pub const AV_CPU_FLAG_XOP: libc::c_int = 1024;
pub const AV_CPU_FLAG_FMA4: libc::c_int = 2048;
pub const AV_CPU_FLAG_CMOV: libc::c_int = 4096;
pub const AV_CPU_FLAG_AVX2: libc::c_int = 32768;
pub const AV_CPU_FLAG_FMA3: libc::c_int = 65536;
pub const AV_CPU_FLAG_BMI1: libc::c_int = 131072;
pub const AV_CPU_FLAG_BMI2: libc::c_int = 262144;
pub const AV_CPU_FLAG_ALTIVEC: libc::c_int = 1;
pub const AV_CPU_FLAG_VSX: libc::c_int = 2;
pub const AV_CPU_FLAG_POWER8: libc::c_int = 4;
pub const AV_CPU_FLAG_ARMV5TE: libc::c_int = 1;
pub const AV_CPU_FLAG_ARMV6: libc::c_int = 2;
pub const AV_CPU_FLAG_ARMV6T2: libc::c_int = 4;
pub const AV_CPU_FLAG_VFP: libc::c_int = 8;
pub const AV_CPU_FLAG_VFPV3: libc::c_int = 16;
pub const AV_CPU_FLAG_NEON: libc::c_int = 32;
pub const AV_CPU_FLAG_ARMV8: libc::c_int = 64;
pub const AV_CPU_FLAG_VFP_VM: libc::c_int = 128;
pub const AV_CPU_FLAG_SETEND: libc::c_int = 65536;
pub const AV_CH_FRONT_LEFT: libc::c_ulonglong = 1;
pub const AV_CH_FRONT_RIGHT: libc::c_ulonglong = 2;
pub const AV_CH_FRONT_CENTER: libc::c_ulonglong = 4;
pub const AV_CH_LOW_FREQUENCY: libc::c_ulonglong = 8;
pub const AV_CH_BACK_LEFT: libc::c_ulonglong = 16;
pub const AV_CH_BACK_RIGHT: libc::c_ulonglong = 32;
pub const AV_CH_FRONT_LEFT_OF_CENTER: libc::c_ulonglong = 64;
pub const AV_CH_FRONT_RIGHT_OF_CENTER: libc::c_ulonglong = 128;
pub const AV_CH_BACK_CENTER: libc::c_ulonglong = 256;
pub const AV_CH_SIDE_LEFT: libc::c_ulonglong = 512;
pub const AV_CH_SIDE_RIGHT: libc::c_ulonglong = 1024;
pub const AV_CH_TOP_CENTER: libc::c_ulonglong = 2048;
pub const AV_CH_TOP_FRONT_LEFT: libc::c_ulonglong = 4096;
pub const AV_CH_TOP_FRONT_CENTER: libc::c_ulonglong = 8192;
pub const AV_CH_TOP_FRONT_RIGHT: libc::c_ulonglong = 16384;
pub const AV_CH_TOP_BACK_LEFT: libc::c_ulonglong = 32768;
pub const AV_CH_TOP_BACK_CENTER: libc::c_ulonglong = 65536;
pub const AV_CH_TOP_BACK_RIGHT: libc::c_ulonglong = 131072;
pub const AV_CH_STEREO_LEFT: libc::c_ulonglong = 536870912;
pub const AV_CH_STEREO_RIGHT: libc::c_ulonglong = 1073741824;
pub const AV_CH_WIDE_LEFT: libc::c_ulonglong = 2147483648;
pub const AV_CH_WIDE_RIGHT: libc::c_ulonglong = 4294967296;
pub const AV_CH_SURROUND_DIRECT_LEFT: libc::c_ulonglong = 8589934592;
pub const AV_CH_SURROUND_DIRECT_RIGHT: libc::c_ulonglong = 17179869184;
pub const AV_CH_LOW_FREQUENCY_2: libc::c_ulonglong = 34359738368;
pub const AV_CH_LAYOUT_MONO: libc::c_ulonglong = 4;
pub const AV_CH_LAYOUT_STEREO: libc::c_ulonglong = 3;
pub const AV_CH_LAYOUT_2POINT1: libc::c_ulonglong = 11;
pub const AV_CH_LAYOUT_2_1: libc::c_ulonglong = 259;
pub const AV_CH_LAYOUT_SURROUND: libc::c_ulonglong = 7;
pub const AV_CH_LAYOUT_3POINT1: libc::c_ulonglong = 15;
pub const AV_CH_LAYOUT_4POINT0: libc::c_ulonglong = 263;
pub const AV_CH_LAYOUT_4POINT1: libc::c_ulonglong = 271;
pub const AV_CH_LAYOUT_2_2: libc::c_ulonglong = 1539;
pub const AV_CH_LAYOUT_QUAD: libc::c_ulonglong = 51;
pub const AV_CH_LAYOUT_5POINT0: libc::c_ulonglong = 1543;
pub const AV_CH_LAYOUT_5POINT1: libc::c_ulonglong = 1551;
pub const AV_CH_LAYOUT_5POINT0_BACK: libc::c_ulonglong = 55;
pub const AV_CH_LAYOUT_5POINT1_BACK: libc::c_ulonglong = 63;
pub const AV_CH_LAYOUT_6POINT0: libc::c_ulonglong = 1799;
pub const AV_CH_LAYOUT_6POINT0_FRONT: libc::c_ulonglong = 1731;
pub const AV_CH_LAYOUT_HEXAGONAL: libc::c_ulonglong = 311;
pub const AV_CH_LAYOUT_6POINT1: libc::c_ulonglong = 1807;
pub const AV_CH_LAYOUT_6POINT1_BACK: libc::c_ulonglong = 319;
pub const AV_CH_LAYOUT_6POINT1_FRONT: libc::c_ulonglong = 1739;
pub const AV_CH_LAYOUT_7POINT0: libc::c_ulonglong = 1591;
pub const AV_CH_LAYOUT_7POINT0_FRONT: libc::c_ulonglong = 1735;
pub const AV_CH_LAYOUT_7POINT1: libc::c_ulonglong = 1599;
pub const AV_CH_LAYOUT_7POINT1_WIDE: libc::c_ulonglong = 1743;
pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: libc::c_ulonglong = 255;
pub const AV_CH_LAYOUT_OCTAGONAL: libc::c_ulonglong = 1847;
pub const AV_CH_LAYOUT_HEXADECAGONAL: libc::c_ulonglong = 6442710839;
pub const AV_CH_LAYOUT_STEREO_DOWNMIX: libc::c_ulonglong = 1610612736;
pub const AV_DICT_MATCH_CASE: libc::c_int = 1;
pub const AV_DICT_IGNORE_SUFFIX: libc::c_int = 2;
pub const AV_DICT_DONT_STRDUP_KEY: libc::c_int = 4;
pub const AV_DICT_DONT_STRDUP_VAL: libc::c_int = 8;
pub const AV_DICT_DONT_OVERWRITE: libc::c_int = 16;
pub const AV_DICT_APPEND: libc::c_int = 32;
pub const AV_DICT_MULTIKEY: libc::c_int = 64;
pub const AV_NUM_DATA_POINTERS: libc::c_int = 8;
pub const AV_FRAME_FLAG_CORRUPT: libc::c_int = 1;
pub const AV_FRAME_FLAG_DISCARD: libc::c_int = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: libc::c_int = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: libc::c_int = 2;
pub const LIBAVCODEC_VERSION_MAJOR: libc::c_int = 57;
pub const LIBAVCODEC_VERSION_MINOR: libc::c_int = 89;
pub const LIBAVCODEC_VERSION_MICRO: libc::c_int = 100;
pub const AV_CODEC_PROP_INTRA_ONLY: libc::c_int = 1;
pub const AV_CODEC_PROP_LOSSY: libc::c_int = 2;
pub const AV_CODEC_PROP_LOSSLESS: libc::c_int = 4;
pub const AV_CODEC_PROP_REORDER: libc::c_int = 8;
pub const AV_CODEC_PROP_BITMAP_SUB: libc::c_int = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: libc::c_int = 131072;
pub const AV_INPUT_BUFFER_PADDING_SIZE: libc::c_int = 32;
pub const AV_INPUT_BUFFER_MIN_SIZE: libc::c_int = 16384;
pub const FF_INPUT_BUFFER_PADDING_SIZE: libc::c_int = 32;
pub const FF_MIN_BUFFER_SIZE: libc::c_int = 16384;
pub const FF_MAX_B_FRAMES: libc::c_int = 16;
pub const AV_CODEC_FLAG_UNALIGNED: libc::c_uint = 1;
pub const AV_CODEC_FLAG_QSCALE: libc::c_uint = 2;
pub const AV_CODEC_FLAG_4MV: libc::c_uint = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: libc::c_uint = 8;
pub const AV_CODEC_FLAG_QPEL: libc::c_uint = 16;
pub const AV_CODEC_FLAG_PASS1: libc::c_uint = 512;
pub const AV_CODEC_FLAG_PASS2: libc::c_uint = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: libc::c_uint = 2048;
pub const AV_CODEC_FLAG_GRAY: libc::c_uint = 8192;
pub const AV_CODEC_FLAG_PSNR: libc::c_uint = 32768;
pub const AV_CODEC_FLAG_TRUNCATED: libc::c_uint = 65536;
pub const AV_CODEC_FLAG_INTERLACED_DCT: libc::c_uint = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: libc::c_uint = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: libc::c_uint = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: libc::c_uint = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: libc::c_uint = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: libc::c_uint = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: libc::c_uint = 2147483648;
pub const AV_CODEC_FLAG2_FAST: libc::c_uint = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: libc::c_uint = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: libc::c_uint = 8;
pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE: libc::c_uint = 8192;
pub const AV_CODEC_FLAG2_CHUNKS: libc::c_uint = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: libc::c_uint = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: libc::c_uint = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: libc::c_uint = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: libc::c_uint = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: libc::c_uint = 1073741824;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: libc::c_uint = 1;
pub const AV_CODEC_CAP_DR1: libc::c_uint = 2;
pub const AV_CODEC_CAP_TRUNCATED: libc::c_uint = 8;
pub const AV_CODEC_CAP_DELAY: libc::c_uint = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: libc::c_uint = 64;
pub const AV_CODEC_CAP_HWACCEL_VDPAU: libc::c_uint = 128;
pub const AV_CODEC_CAP_SUBFRAMES: libc::c_uint = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: libc::c_uint = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: libc::c_uint = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: libc::c_uint = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: libc::c_uint = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: libc::c_uint = 16384;
pub const AV_CODEC_CAP_AUTO_THREADS: libc::c_uint = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: libc::c_uint = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: libc::c_uint = 131072;
pub const AV_CODEC_CAP_INTRA_ONLY: libc::c_uint = 1073741824;
pub const AV_CODEC_CAP_LOSSLESS: libc::c_uint = 2147483648;
pub const CODEC_FLAG_UNALIGNED: libc::c_int = 1;
pub const CODEC_FLAG_QSCALE: libc::c_int = 2;
pub const CODEC_FLAG_4MV: libc::c_int = 4;
pub const CODEC_FLAG_OUTPUT_CORRUPT: libc::c_int = 8;
pub const CODEC_FLAG_QPEL: libc::c_int = 16;
pub const CODEC_FLAG_GMC: libc::c_int = 32;
pub const CODEC_FLAG_MV0: libc::c_int = 64;
pub const CODEC_FLAG_INPUT_PRESERVED: libc::c_int = 256;
pub const CODEC_FLAG_PASS1: libc::c_int = 512;
pub const CODEC_FLAG_PASS2: libc::c_int = 1024;
pub const CODEC_FLAG_GRAY: libc::c_int = 8192;
pub const CODEC_FLAG_EMU_EDGE: libc::c_int = 16384;
pub const CODEC_FLAG_PSNR: libc::c_int = 32768;
pub const CODEC_FLAG_TRUNCATED: libc::c_int = 65536;
pub const CODEC_FLAG_NORMALIZE_AQP: libc::c_int = 131072;
pub const CODEC_FLAG_INTERLACED_DCT: libc::c_int = 262144;
pub const CODEC_FLAG_LOW_DELAY: libc::c_int = 524288;
pub const CODEC_FLAG_GLOBAL_HEADER: libc::c_int = 4194304;
pub const CODEC_FLAG_BITEXACT: libc::c_int = 8388608;
pub const CODEC_FLAG_AC_PRED: libc::c_int = 16777216;
pub const CODEC_FLAG_LOOP_FILTER: libc::c_int = 2048;
pub const CODEC_FLAG_INTERLACED_ME: libc::c_int = 536870912;
pub const CODEC_FLAG_CLOSED_GOP: libc::c_uint = 2147483648;
pub const CODEC_FLAG2_FAST: libc::c_int = 1;
pub const CODEC_FLAG2_NO_OUTPUT: libc::c_int = 4;
pub const CODEC_FLAG2_LOCAL_HEADER: libc::c_int = 8;
pub const CODEC_FLAG2_DROP_FRAME_TIMECODE: libc::c_int = 8192;
pub const CODEC_FLAG2_IGNORE_CROP: libc::c_int = 65536;
pub const CODEC_FLAG2_CHUNKS: libc::c_int = 32768;
pub const CODEC_FLAG2_SHOW_ALL: libc::c_int = 4194304;
pub const CODEC_FLAG2_EXPORT_MVS: libc::c_int = 268435456;
pub const CODEC_FLAG2_SKIP_MANUAL: libc::c_int = 536870912;
pub const CODEC_CAP_DRAW_HORIZ_BAND: libc::c_int = 1;
pub const CODEC_CAP_DR1: libc::c_int = 2;
pub const CODEC_CAP_TRUNCATED: libc::c_int = 8;
pub const CODEC_CAP_HWACCEL: libc::c_int = 16;
pub const CODEC_CAP_DELAY: libc::c_int = 32;
pub const CODEC_CAP_SMALL_LAST_FRAME: libc::c_int = 64;
pub const CODEC_CAP_HWACCEL_VDPAU: libc::c_int = 128;
pub const CODEC_CAP_SUBFRAMES: libc::c_int = 256;
pub const CODEC_CAP_EXPERIMENTAL: libc::c_int = 512;
pub const CODEC_CAP_CHANNEL_CONF: libc::c_int = 1024;
pub const CODEC_CAP_NEG_LINESIZES: libc::c_int = 2048;
pub const CODEC_CAP_FRAME_THREADS: libc::c_int = 4096;
pub const CODEC_CAP_SLICE_THREADS: libc::c_int = 8192;
pub const CODEC_CAP_PARAM_CHANGE: libc::c_int = 16384;
pub const CODEC_CAP_AUTO_THREADS: libc::c_int = 32768;
pub const CODEC_CAP_VARIABLE_FRAME_SIZE: libc::c_int = 65536;
pub const CODEC_CAP_INTRA_ONLY: libc::c_int = 1073741824;
pub const CODEC_CAP_LOSSLESS: libc::c_uint = 2147483648;
pub const HWACCEL_CODEC_CAP_EXPERIMENTAL: libc::c_int = 512;
pub const MB_TYPE_INTRA4x4: libc::c_int = 1;
pub const MB_TYPE_INTRA16x16: libc::c_int = 2;
pub const MB_TYPE_INTRA_PCM: libc::c_int = 4;
pub const MB_TYPE_16x16: libc::c_int = 8;
pub const MB_TYPE_16x8: libc::c_int = 16;
pub const MB_TYPE_8x16: libc::c_int = 32;
pub const MB_TYPE_8x8: libc::c_int = 64;
pub const MB_TYPE_INTERLACED: libc::c_int = 128;
pub const MB_TYPE_DIRECT2: libc::c_int = 256;
pub const MB_TYPE_ACPRED: libc::c_int = 512;
pub const MB_TYPE_GMC: libc::c_int = 1024;
pub const MB_TYPE_SKIP: libc::c_int = 2048;
pub const MB_TYPE_P0L0: libc::c_int = 4096;
pub const MB_TYPE_P1L0: libc::c_int = 8192;
pub const MB_TYPE_P0L1: libc::c_int = 16384;
pub const MB_TYPE_P1L1: libc::c_int = 32768;
pub const MB_TYPE_L0: libc::c_int = 12288;
pub const MB_TYPE_L1: libc::c_int = 49152;
pub const MB_TYPE_L0L1: libc::c_int = 61440;
pub const MB_TYPE_QUANT: libc::c_int = 65536;
pub const MB_TYPE_CBP: libc::c_int = 131072;
pub const FF_QSCALE_TYPE_MPEG1: libc::c_int = 0;
pub const FF_QSCALE_TYPE_MPEG2: libc::c_int = 1;
pub const FF_QSCALE_TYPE_H264: libc::c_int = 2;
pub const FF_QSCALE_TYPE_VP56: libc::c_int = 3;
pub const AV_GET_BUFFER_FLAG_REF: libc::c_int = 1;
pub const AV_PKT_FLAG_KEY: libc::c_int = 1;
pub const AV_PKT_FLAG_CORRUPT: libc::c_int = 2;
pub const AV_PKT_FLAG_DISCARD: libc::c_int = 4;
pub const FF_COMPRESSION_DEFAULT: libc::c_int = -1;
pub const FF_ASPECT_EXTENDED: libc::c_int = 15;
pub const FF_RC_STRATEGY_XVID: libc::c_int = 1;
pub const FF_PRED_LEFT: libc::c_int = 0;
pub const FF_PRED_PLANE: libc::c_int = 1;
pub const FF_PRED_MEDIAN: libc::c_int = 2;
pub const FF_CMP_SAD: libc::c_int = 0;
pub const FF_CMP_SSE: libc::c_int = 1;
pub const FF_CMP_SATD: libc::c_int = 2;
pub const FF_CMP_DCT: libc::c_int = 3;
pub const FF_CMP_PSNR: libc::c_int = 4;
pub const FF_CMP_BIT: libc::c_int = 5;
pub const FF_CMP_RD: libc::c_int = 6;
pub const FF_CMP_ZERO: libc::c_int = 7;
pub const FF_CMP_VSAD: libc::c_int = 8;
pub const FF_CMP_VSSE: libc::c_int = 9;
pub const FF_CMP_NSSE: libc::c_int = 10;
pub const FF_CMP_W53: libc::c_int = 11;
pub const FF_CMP_W97: libc::c_int = 12;
pub const FF_CMP_DCTMAX: libc::c_int = 13;
pub const FF_CMP_DCT264: libc::c_int = 14;
pub const FF_CMP_MEDIAN_SAD: libc::c_int = 15;
pub const FF_CMP_CHROMA: libc::c_int = 256;
pub const FF_DTG_AFD_SAME: libc::c_int = 8;
pub const FF_DTG_AFD_4_3: libc::c_int = 9;
pub const FF_DTG_AFD_16_9: libc::c_int = 10;
pub const FF_DTG_AFD_14_9: libc::c_int = 11;
pub const FF_DTG_AFD_4_3_SP_14_9: libc::c_int = 13;
pub const FF_DTG_AFD_16_9_SP_14_9: libc::c_int = 14;
pub const FF_DTG_AFD_SP_4_3: libc::c_int = 15;
pub const FF_DEFAULT_QUANT_BIAS: libc::c_int = 999999;
pub const SLICE_FLAG_CODED_ORDER: libc::c_int = 1;
pub const SLICE_FLAG_ALLOW_FIELD: libc::c_int = 2;
pub const SLICE_FLAG_ALLOW_PLANE: libc::c_int = 4;
pub const FF_MB_DECISION_SIMPLE: libc::c_int = 0;
pub const FF_MB_DECISION_BITS: libc::c_int = 1;
pub const FF_MB_DECISION_RD: libc::c_int = 2;
pub const FF_CODER_TYPE_VLC: libc::c_int = 0;
pub const FF_CODER_TYPE_AC: libc::c_int = 1;
pub const FF_CODER_TYPE_RAW: libc::c_int = 2;
pub const FF_CODER_TYPE_RLE: libc::c_int = 3;
pub const FF_CODER_TYPE_DEFLATE: libc::c_int = 4;
pub const FF_BUG_AUTODETECT: libc::c_int = 1;
pub const FF_BUG_OLD_MSMPEG4: libc::c_int = 2;
pub const FF_BUG_XVID_ILACE: libc::c_int = 4;
pub const FF_BUG_UMP4: libc::c_int = 8;
pub const FF_BUG_NO_PADDING: libc::c_int = 16;
pub const FF_BUG_AMV: libc::c_int = 32;
pub const FF_BUG_AC_VLC: libc::c_int = 0;
pub const FF_BUG_QPEL_CHROMA: libc::c_int = 64;
pub const FF_BUG_STD_QPEL: libc::c_int = 128;
pub const FF_BUG_QPEL_CHROMA2: libc::c_int = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: libc::c_int = 512;
pub const FF_BUG_EDGE: libc::c_int = 1024;
pub const FF_BUG_HPEL_CHROMA: libc::c_int = 2048;
pub const FF_BUG_DC_CLIP: libc::c_int = 4096;
pub const FF_BUG_MS: libc::c_int = 8192;
pub const FF_BUG_TRUNCATED: libc::c_int = 16384;
pub const FF_BUG_IEDGE: libc::c_int = 32768;
pub const FF_COMPLIANCE_VERY_STRICT: libc::c_int = 2;
pub const FF_COMPLIANCE_STRICT: libc::c_int = 1;
pub const FF_COMPLIANCE_NORMAL: libc::c_int = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: libc::c_int = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: libc::c_int = -2;
pub const FF_EC_GUESS_MVS: libc::c_int = 1;
pub const FF_EC_DEBLOCK: libc::c_int = 2;
pub const FF_EC_FAVOR_INTER: libc::c_int = 256;
pub const FF_DEBUG_PICT_INFO: libc::c_int = 1;
pub const FF_DEBUG_RC: libc::c_int = 2;
pub const FF_DEBUG_BITSTREAM: libc::c_int = 4;
pub const FF_DEBUG_MB_TYPE: libc::c_int = 8;
pub const FF_DEBUG_QP: libc::c_int = 16;
pub const FF_DEBUG_MV: libc::c_int = 32;
pub const FF_DEBUG_DCT_COEFF: libc::c_int = 64;
pub const FF_DEBUG_SKIP: libc::c_int = 128;
pub const FF_DEBUG_STARTCODE: libc::c_int = 256;
pub const FF_DEBUG_PTS: libc::c_int = 512;
pub const FF_DEBUG_ER: libc::c_int = 1024;
pub const FF_DEBUG_MMCO: libc::c_int = 2048;
pub const FF_DEBUG_BUGS: libc::c_int = 4096;
pub const FF_DEBUG_VIS_QP: libc::c_int = 8192;
pub const FF_DEBUG_VIS_MB_TYPE: libc::c_int = 16384;
pub const FF_DEBUG_BUFFERS: libc::c_int = 32768;
pub const FF_DEBUG_THREADS: libc::c_int = 65536;
pub const FF_DEBUG_GREEN_MD: libc::c_int = 8388608;
pub const FF_DEBUG_NOMC: libc::c_int = 16777216;
pub const FF_DEBUG_VIS_MV_P_FOR: libc::c_int = 1;
pub const FF_DEBUG_VIS_MV_B_FOR: libc::c_int = 2;
pub const FF_DEBUG_VIS_MV_B_BACK: libc::c_int = 4;
pub const AV_EF_CRCCHECK: libc::c_int = 1;
pub const AV_EF_BITSTREAM: libc::c_int = 2;
pub const AV_EF_BUFFER: libc::c_int = 4;
pub const AV_EF_EXPLODE: libc::c_int = 8;
pub const AV_EF_IGNORE_ERR: libc::c_int = 32768;
pub const AV_EF_CAREFUL: libc::c_int = 65536;
pub const AV_EF_COMPLIANT: libc::c_int = 131072;
pub const AV_EF_AGGRESSIVE: libc::c_int = 262144;
pub const FF_DCT_AUTO: libc::c_int = 0;
pub const FF_DCT_FASTINT: libc::c_int = 1;
pub const FF_DCT_INT: libc::c_int = 2;
pub const FF_DCT_MMX: libc::c_int = 3;
pub const FF_DCT_ALTIVEC: libc::c_int = 5;
pub const FF_DCT_FAAN: libc::c_int = 6;
pub const FF_IDCT_AUTO: libc::c_int = 0;
pub const FF_IDCT_INT: libc::c_int = 1;
pub const FF_IDCT_SIMPLE: libc::c_int = 2;
pub const FF_IDCT_SIMPLEMMX: libc::c_int = 3;
pub const FF_IDCT_ARM: libc::c_int = 7;
pub const FF_IDCT_ALTIVEC: libc::c_int = 8;
pub const FF_IDCT_SH4: libc::c_int = 9;
pub const FF_IDCT_SIMPLEARM: libc::c_int = 10;
pub const FF_IDCT_IPP: libc::c_int = 13;
pub const FF_IDCT_XVID: libc::c_int = 14;
pub const FF_IDCT_XVIDMMX: libc::c_int = 14;
pub const FF_IDCT_SIMPLEARMV5TE: libc::c_int = 16;
pub const FF_IDCT_SIMPLEARMV6: libc::c_int = 17;
pub const FF_IDCT_SIMPLEVIS: libc::c_int = 18;
pub const FF_IDCT_FAAN: libc::c_int = 20;
pub const FF_IDCT_SIMPLENEON: libc::c_int = 22;
pub const FF_IDCT_SIMPLEALPHA: libc::c_int = 23;
pub const FF_IDCT_SIMPLEAUTO: libc::c_int = 128;
pub const FF_THREAD_FRAME: libc::c_int = 1;
pub const FF_THREAD_SLICE: libc::c_int = 2;
pub const FF_PROFILE_UNKNOWN: libc::c_int = -99;
pub const FF_PROFILE_RESERVED: libc::c_int = -100;
pub const FF_PROFILE_AAC_MAIN: libc::c_int = 0;
pub const FF_PROFILE_AAC_LOW: libc::c_int = 1;
pub const FF_PROFILE_AAC_SSR: libc::c_int = 2;
pub const FF_PROFILE_AAC_LTP: libc::c_int = 3;
pub const FF_PROFILE_AAC_HE: libc::c_int = 4;
pub const FF_PROFILE_AAC_HE_V2: libc::c_int = 28;
pub const FF_PROFILE_AAC_LD: libc::c_int = 22;
pub const FF_PROFILE_AAC_ELD: libc::c_int = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: libc::c_int = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: libc::c_int = 131;
pub const FF_PROFILE_DNXHD: libc::c_int = 0;
pub const FF_PROFILE_DNXHR_LB: libc::c_int = 1;
pub const FF_PROFILE_DNXHR_SQ: libc::c_int = 2;
pub const FF_PROFILE_DNXHR_HQ: libc::c_int = 3;
pub const FF_PROFILE_DNXHR_HQX: libc::c_int = 4;
pub const FF_PROFILE_DNXHR_444: libc::c_int = 5;
pub const FF_PROFILE_DTS: libc::c_int = 20;
pub const FF_PROFILE_DTS_ES: libc::c_int = 30;
pub const FF_PROFILE_DTS_96_24: libc::c_int = 40;
pub const FF_PROFILE_DTS_HD_HRA: libc::c_int = 50;
pub const FF_PROFILE_DTS_HD_MA: libc::c_int = 60;
pub const FF_PROFILE_DTS_EXPRESS: libc::c_int = 70;
pub const FF_PROFILE_MPEG2_422: libc::c_int = 0;
pub const FF_PROFILE_MPEG2_HIGH: libc::c_int = 1;
pub const FF_PROFILE_MPEG2_SS: libc::c_int = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: libc::c_int = 3;
pub const FF_PROFILE_MPEG2_MAIN: libc::c_int = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: libc::c_int = 5;
pub const FF_PROFILE_H264_CONSTRAINED: libc::c_int = 512;
pub const FF_PROFILE_H264_INTRA: libc::c_int = 2048;
pub const FF_PROFILE_H264_BASELINE: libc::c_int = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: libc::c_int = 578;
pub const FF_PROFILE_H264_MAIN: libc::c_int = 77;
pub const FF_PROFILE_H264_EXTENDED: libc::c_int = 88;
pub const FF_PROFILE_H264_HIGH: libc::c_int = 100;
pub const FF_PROFILE_H264_HIGH_10: libc::c_int = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: libc::c_int = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: libc::c_int = 118;
pub const FF_PROFILE_H264_HIGH_422: libc::c_int = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: libc::c_int = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: libc::c_int = 128;
pub const FF_PROFILE_H264_HIGH_444: libc::c_int = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: libc::c_int = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: libc::c_int = 2292;
pub const FF_PROFILE_H264_CAVLC_444: libc::c_int = 44;
pub const FF_PROFILE_VC1_SIMPLE: libc::c_int = 0;
pub const FF_PROFILE_VC1_MAIN: libc::c_int = 1;
pub const FF_PROFILE_VC1_COMPLEX: libc::c_int = 2;
pub const FF_PROFILE_VC1_ADVANCED: libc::c_int = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: libc::c_int = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: libc::c_int = 1;
pub const FF_PROFILE_MPEG4_CORE: libc::c_int = 2;
pub const FF_PROFILE_MPEG4_MAIN: libc::c_int = 3;
pub const FF_PROFILE_MPEG4_N_BIT: libc::c_int = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: libc::c_int = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: libc::c_int = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: libc::c_int = 7;
pub const FF_PROFILE_MPEG4_HYBRID: libc::c_int = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: libc::c_int = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: libc::c_int = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: libc::c_int = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: libc::c_int = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: libc::c_int = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: libc::c_int = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: libc::c_int = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: libc::c_int = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: libc::c_int = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: libc::c_int = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: libc::c_int = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: libc::c_int = 4;
pub const FF_PROFILE_VP9_0: libc::c_int = 0;
pub const FF_PROFILE_VP9_1: libc::c_int = 1;
pub const FF_PROFILE_VP9_2: libc::c_int = 2;
pub const FF_PROFILE_VP9_3: libc::c_int = 3;
pub const FF_PROFILE_HEVC_MAIN: libc::c_int = 1;
pub const FF_PROFILE_HEVC_MAIN_10: libc::c_int = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: libc::c_int = 3;
pub const FF_PROFILE_HEVC_REXT: libc::c_int = 4;
pub const FF_LEVEL_UNKNOWN: libc::c_int = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: libc::c_int = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: libc::c_int = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: libc::c_int = 1;
pub const FF_CODEC_PROPERTY_LOSSLESS: libc::c_int = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: libc::c_int = 2;
pub const FF_SUB_TEXT_FMT_ASS: libc::c_int = 0;
pub const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS: libc::c_int = 1;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: libc::c_int = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: libc::c_int = 2;
pub const AV_SUBTITLE_FLAG_FORCED: libc::c_int = 1;
pub const AV_PARSER_PTS_NB: libc::c_int = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: libc::c_int = 1;
pub const PARSER_FLAG_ONCE: libc::c_int = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: libc::c_int = 4;
pub const PARSER_FLAG_USE_CODEC_TS: libc::c_int = 4096;
pub const _TIME_H: libc::c_int = 1;
pub const _BITS_TIME_H: libc::c_int = 1;
pub const CLOCK_REALTIME: libc::c_int = 0;
pub const CLOCK_MONOTONIC: libc::c_int = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: libc::c_int = 2;
pub const CLOCK_THREAD_CPUTIME_ID: libc::c_int = 3;
pub const CLOCK_MONOTONIC_RAW: libc::c_int = 4;
pub const CLOCK_REALTIME_COARSE: libc::c_int = 5;
pub const CLOCK_MONOTONIC_COARSE: libc::c_int = 6;
pub const CLOCK_BOOTTIME: libc::c_int = 7;
pub const CLOCK_REALTIME_ALARM: libc::c_int = 8;
pub const CLOCK_BOOTTIME_ALARM: libc::c_int = 9;
pub const CLOCK_TAI: libc::c_int = 11;
pub const TIMER_ABSTIME: libc::c_int = 1;
pub const __struct_tm_defined: libc::c_int = 1;
pub const __itimerspec_defined: libc::c_int = 1;
pub const TIME_UTC: libc::c_int = 1;
pub const LIBAVFORMAT_VERSION_MAJOR: libc::c_int = 57;
pub const LIBAVFORMAT_VERSION_MINOR: libc::c_int = 71;
pub const LIBAVFORMAT_VERSION_MICRO: libc::c_int = 100;
pub const FF_API_R_FRAME_RATE: libc::c_int = 1;
pub const AVIO_SEEKABLE_NORMAL: libc::c_int = 1;
pub const AVIO_SEEKABLE_TIME: libc::c_int = 2;
pub const AVSEEK_SIZE: libc::c_int = 65536;
pub const AVSEEK_FORCE: libc::c_int = 131072;
pub const AVIO_FLAG_READ: libc::c_int = 1;
pub const AVIO_FLAG_WRITE: libc::c_int = 2;
pub const AVIO_FLAG_READ_WRITE: libc::c_int = 3;
pub const AVIO_FLAG_NONBLOCK: libc::c_int = 8;
pub const AVIO_FLAG_DIRECT: libc::c_int = 32768;
pub const AVPROBE_SCORE_EXTENSION: libc::c_int = 50;
pub const AVPROBE_SCORE_MIME: libc::c_int = 75;
pub const AVPROBE_SCORE_MAX: libc::c_int = 100;
pub const AVPROBE_PADDING_SIZE: libc::c_int = 32;
pub const AVFMT_NOFILE: libc::c_int = 1;
pub const AVFMT_NEEDNUMBER: libc::c_int = 2;
pub const AVFMT_SHOW_IDS: libc::c_int = 8;
pub const AVFMT_RAWPICTURE: libc::c_int = 32;
pub const AVFMT_GLOBALHEADER: libc::c_int = 64;
pub const AVFMT_NOTIMESTAMPS: libc::c_int = 128;
pub const AVFMT_GENERIC_INDEX: libc::c_int = 256;
pub const AVFMT_TS_DISCONT: libc::c_int = 512;
pub const AVFMT_VARIABLE_FPS: libc::c_int = 1024;
pub const AVFMT_NODIMENSIONS: libc::c_int = 2048;
pub const AVFMT_NOSTREAMS: libc::c_int = 4096;
pub const AVFMT_NOBINSEARCH: libc::c_int = 8192;
pub const AVFMT_NOGENSEARCH: libc::c_int = 16384;
pub const AVFMT_NO_BYTE_SEEK: libc::c_int = 32768;
pub const AVFMT_ALLOW_FLUSH: libc::c_int = 65536;
pub const AVFMT_TS_NONSTRICT: libc::c_int = 131072;
pub const AVFMT_TS_NEGATIVE: libc::c_int = 262144;
pub const AVFMT_SEEK_TO_PTS: libc::c_int = 67108864;
pub const AVINDEX_KEYFRAME: libc::c_int = 1;
pub const AVINDEX_DISCARD_FRAME: libc::c_int = 2;
pub const AV_DISPOSITION_DEFAULT: libc::c_int = 1;
pub const AV_DISPOSITION_DUB: libc::c_int = 2;
pub const AV_DISPOSITION_ORIGINAL: libc::c_int = 4;
pub const AV_DISPOSITION_COMMENT: libc::c_int = 8;
pub const AV_DISPOSITION_LYRICS: libc::c_int = 16;
pub const AV_DISPOSITION_KARAOKE: libc::c_int = 32;
pub const AV_DISPOSITION_FORCED: libc::c_int = 64;
pub const AV_DISPOSITION_HEARING_IMPAIRED: libc::c_int = 128;
pub const AV_DISPOSITION_VISUAL_IMPAIRED: libc::c_int = 256;
pub const AV_DISPOSITION_CLEAN_EFFECTS: libc::c_int = 512;
pub const AV_DISPOSITION_ATTACHED_PIC: libc::c_int = 1024;
pub const AV_DISPOSITION_TIMED_THUMBNAILS: libc::c_int = 2048;
pub const AV_DISPOSITION_CAPTIONS: libc::c_int = 65536;
pub const AV_DISPOSITION_DESCRIPTIONS: libc::c_int = 131072;
pub const AV_DISPOSITION_METADATA: libc::c_int = 262144;
pub const AV_PTS_WRAP_IGNORE: libc::c_int = 0;
pub const AV_PTS_WRAP_ADD_OFFSET: libc::c_int = 1;
pub const AV_PTS_WRAP_SUB_OFFSET: libc::c_int = -1;
pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED: libc::c_int = 1;
pub const MAX_STD_TIMEBASES: libc::c_int = 399;
pub const MAX_REORDER_DELAY: libc::c_int = 16;
pub const AV_PROGRAM_RUNNING: libc::c_int = 1;
pub const AVFMTCTX_NOHEADER: libc::c_int = 1;
pub const AVFMT_FLAG_GENPTS: libc::c_int = 1;
pub const AVFMT_FLAG_IGNIDX: libc::c_int = 2;
pub const AVFMT_FLAG_NONBLOCK: libc::c_int = 4;
pub const AVFMT_FLAG_IGNDTS: libc::c_int = 8;
pub const AVFMT_FLAG_NOFILLIN: libc::c_int = 16;
pub const AVFMT_FLAG_NOPARSE: libc::c_int = 32;
pub const AVFMT_FLAG_NOBUFFER: libc::c_int = 64;
pub const AVFMT_FLAG_CUSTOM_IO: libc::c_int = 128;
pub const AVFMT_FLAG_DISCARD_CORRUPT: libc::c_int = 256;
pub const AVFMT_FLAG_FLUSH_PACKETS: libc::c_int = 512;
pub const AVFMT_FLAG_BITEXACT: libc::c_int = 1024;
pub const AVFMT_FLAG_MP4A_LATM: libc::c_int = 32768;
pub const AVFMT_FLAG_SORT_DTS: libc::c_int = 65536;
pub const AVFMT_FLAG_PRIV_OPT: libc::c_int = 131072;
pub const AVFMT_FLAG_KEEP_SIDE_DATA: libc::c_int = 262144;
pub const AVFMT_FLAG_FAST_SEEK: libc::c_int = 524288;
pub const AVFMT_FLAG_SHORTEST: libc::c_int = 1048576;
pub const AVFMT_FLAG_AUTO_BSF: libc::c_int = 2097152;
pub const FF_FDEBUG_TS: libc::c_int = 1;
pub const AVFMT_EVENT_FLAG_METADATA_UPDATED: libc::c_int = 1;
pub const AVFMT_AVOID_NEG_TS_AUTO: libc::c_int = -1;
pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE: libc::c_int = 1;
pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO: libc::c_int = 2;
pub const AVSEEK_FLAG_BACKWARD: libc::c_int = 1;
pub const AVSEEK_FLAG_BYTE: libc::c_int = 2;
pub const AVSEEK_FLAG_ANY: libc::c_int = 4;
pub const AVSEEK_FLAG_FRAME: libc::c_int = 8;
pub const AVSTREAM_INIT_IN_WRITE_HEADER: libc::c_int = 0;
pub const AVSTREAM_INIT_IN_INIT_OUTPUT: libc::c_int = 1;
pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE: libc::c_int = 1;
pub const AV_PIX_FMT_FLAG_BE: libc::c_int = 1;
pub const AV_PIX_FMT_FLAG_PAL: libc::c_int = 2;
pub const AV_PIX_FMT_FLAG_BITSTREAM: libc::c_int = 4;
pub const AV_PIX_FMT_FLAG_HWACCEL: libc::c_int = 8;
pub const AV_PIX_FMT_FLAG_PLANAR: libc::c_int = 16;
pub const AV_PIX_FMT_FLAG_RGB: libc::c_int = 32;
pub const AV_PIX_FMT_FLAG_PSEUDOPAL: libc::c_int = 64;
pub const AV_PIX_FMT_FLAG_ALPHA: libc::c_int = 128;
pub const AV_PIX_FMT_FLAG_BAYER: libc::c_int = 256;
pub const FF_LOSS_RESOLUTION: libc::c_int = 1;
pub const FF_LOSS_DEPTH: libc::c_int = 2;
pub const FF_LOSS_COLORSPACE: libc::c_int = 4;
pub const FF_LOSS_ALPHA: libc::c_int = 8;
pub const FF_LOSS_COLORQUANT: libc::c_int = 16;
pub const FF_LOSS_CHROMA: libc::c_int = 32;
pub const LIBAVFILTER_VERSION_MAJOR: libc::c_int = 6;
pub const LIBAVFILTER_VERSION_MINOR: libc::c_int = 82;
pub const LIBAVFILTER_VERSION_MICRO: libc::c_int = 100;
pub const AVFILTER_FLAG_DYNAMIC_INPUTS: libc::c_int = 1;
pub const AVFILTER_FLAG_DYNAMIC_OUTPUTS: libc::c_int = 2;
pub const AVFILTER_FLAG_SLICE_THREADS: libc::c_int = 4;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC: libc::c_int = 65536;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL: libc::c_int = 131072;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE: libc::c_int = 196608;
pub const AVFILTER_THREAD_SLICE: libc::c_int = 1;
pub const AVFILTER_CMD_FLAG_ONE: libc::c_int = 1;
pub const AVFILTER_CMD_FLAG_FAST: libc::c_int = 2;
pub const AV_BUFFERSINK_FLAG_PEEK: libc::c_int = 1;
pub const AV_BUFFERSINK_FLAG_NO_REQUEST: libc::c_int = 2;
pub const LIBSWRESAMPLE_VERSION_MAJOR: libc::c_int = 2;
pub const LIBSWRESAMPLE_VERSION_MINOR: libc::c_int = 7;
pub const LIBSWRESAMPLE_VERSION_MICRO: libc::c_int = 100;
pub const SWR_FLAG_RESAMPLE: libc::c_int = 1;
pub const LIBSWSCALE_VERSION_MAJOR: libc::c_int = 4;
pub const LIBSWSCALE_VERSION_MINOR: libc::c_int = 6;
pub const LIBSWSCALE_VERSION_MICRO: libc::c_int = 100;
pub const SWS_FAST_BILINEAR: libc::c_int = 1;
pub const SWS_BILINEAR: libc::c_int = 2;
pub const SWS_BICUBIC: libc::c_int = 4;
pub const SWS_X: libc::c_int = 8;
pub const SWS_POINT: libc::c_int = 16;
pub const SWS_AREA: libc::c_int = 32;
pub const SWS_BICUBLIN: libc::c_int = 64;
pub const SWS_GAUSS: libc::c_int = 128;
pub const SWS_SINC: libc::c_int = 256;
pub const SWS_LANCZOS: libc::c_int = 512;
pub const SWS_SPLINE: libc::c_int = 1024;
pub const SWS_SRC_V_CHR_DROP_MASK: libc::c_int = 196608;
pub const SWS_SRC_V_CHR_DROP_SHIFT: libc::c_int = 16;
pub const SWS_PARAM_DEFAULT: libc::c_int = 123456;
pub const SWS_PRINT_INFO: libc::c_int = 4096;
pub const SWS_FULL_CHR_H_INT: libc::c_int = 8192;
pub const SWS_FULL_CHR_H_INP: libc::c_int = 16384;
pub const SWS_DIRECT_BGR: libc::c_int = 32768;
pub const SWS_ACCURATE_RND: libc::c_int = 262144;
pub const SWS_BITEXACT: libc::c_int = 524288;
pub const SWS_ERROR_DIFFUSION: libc::c_int = 8388608;
pub const SWS_MAX_REDUCE_CUTOFF: f64 = 0.002;
pub const SWS_CS_ITU709: libc::c_int = 1;
pub const SWS_CS_FCC: libc::c_int = 4;
pub const SWS_CS_ITU601: libc::c_int = 5;
pub const SWS_CS_ITU624: libc::c_int = 5;
pub const SWS_CS_SMPTE170M: libc::c_int = 5;
pub const SWS_CS_SMPTE240M: libc::c_int = 7;
pub const SWS_CS_DEFAULT: libc::c_int = 5;
pub const SWS_CS_BT2020: libc::c_int = 9;
pub const LIBAVDEVICE_VERSION_MAJOR: libc::c_int = 57;
pub const LIBAVDEVICE_VERSION_MINOR: libc::c_int = 6;
pub const LIBAVDEVICE_VERSION_MICRO: libc::c_int = 100;
pub const AV_OPT_FLAG_ENCODING_PARAM: libc::c_int = 1;
pub const AV_OPT_FLAG_DECODING_PARAM: libc::c_int = 2;
pub const AV_OPT_FLAG_METADATA: libc::c_int = 4;
pub const AV_OPT_FLAG_AUDIO_PARAM: libc::c_int = 8;
pub const AV_OPT_FLAG_VIDEO_PARAM: libc::c_int = 16;
pub const AV_OPT_FLAG_SUBTITLE_PARAM: libc::c_int = 32;
pub const AV_OPT_FLAG_EXPORT: libc::c_int = 64;
pub const AV_OPT_FLAG_READONLY: libc::c_int = 128;
pub const AV_OPT_FLAG_FILTERING_PARAM: libc::c_int = 65536;
pub const AV_OPT_SEARCH_CHILDREN: libc::c_int = 1;
pub const AV_OPT_SEARCH_FAKE_OBJ: libc::c_int = 2;
pub const AV_OPT_ALLOW_NULL: libc::c_int = 4;
pub const AV_OPT_MULTI_COMPONENT_RANGE: libc::c_int = 4096;
pub const AV_OPT_SERIALIZE_SKIP_DEFAULTS: libc::c_int = 1;
pub const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT: libc::c_int = 2;
extern "C" {
    pub fn __errno_location() -> *mut libc::c_int;
}
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type int_least8_t = libc::c_schar;
pub type int_least16_t = libc::c_short;
pub type int_least32_t = libc::c_int;
pub type int_least64_t = libc::c_long;
pub type uint_least8_t = libc::c_uchar;
pub type uint_least16_t = libc::c_ushort;
pub type uint_least32_t = libc::c_uint;
pub type uint_least64_t = libc::c_ulong;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn avutil_version() -> libc::c_uint;
}
extern "C" {
    pub fn av_version_info() -> *const libc::c_char;
}
extern "C" {
    pub fn avutil_configuration() -> *const libc::c_char;
}
extern "C" {
    pub fn avutil_license() -> *const libc::c_char;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVMediaType {
    AVMEDIA_TYPE_UNKNOWN = -1,
    AVMEDIA_TYPE_VIDEO = 0,
    AVMEDIA_TYPE_AUDIO = 1,
    AVMEDIA_TYPE_DATA = 2,
    AVMEDIA_TYPE_SUBTITLE = 3,
    AVMEDIA_TYPE_ATTACHMENT = 4,
    AVMEDIA_TYPE_NB = 5,
}
extern "C" {
    pub fn av_get_media_type_string(media_type: AVMediaType)
     -> *const libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVPictureType {
    AV_PICTURE_TYPE_NONE = 0,
    AV_PICTURE_TYPE_I = 1,
    AV_PICTURE_TYPE_P = 2,
    AV_PICTURE_TYPE_B = 3,
    AV_PICTURE_TYPE_S = 4,
    AV_PICTURE_TYPE_SI = 5,
    AV_PICTURE_TYPE_SP = 6,
    AV_PICTURE_TYPE_BI = 7,
}
extern "C" {
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> libc::c_char;
}
pub type __gwchar_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::std::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::std::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const libc::c_char,
                     __endptr: *mut *mut libc::c_char, __base: libc::c_int)
     -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const libc::c_char,
                     __endptr: *mut *mut libc::c_char, __base: libc::c_int)
     -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t, __base: libc::c_int)
     -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t, __base: libc::c_int)
     -> uintmax_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassify(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn isinfl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn isnanl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    #[link_name = "signgam"]
    pub static mut signgam: libc::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = _bindgen_ty_1::FP_NAN;
pub const FP_INFINITE: _bindgen_ty_1 = _bindgen_ty_1::FP_INFINITE;
pub const FP_ZERO: _bindgen_ty_1 = _bindgen_ty_1::FP_ZERO;
pub const FP_SUBNORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_SUBNORMAL;
pub const FP_NORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_NORMAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _LIB_VERSION_TYPE {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3,
}
extern "C" {
    #[link_name = "_LIB_VERSION"]
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exception {
    pub type_: libc::c_int,
    pub name: *mut libc::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(::std::mem::size_of::<exception>() , 40usize , concat ! (
               "Size of: " , stringify ! ( exception ) ));
    assert_eq! (::std::mem::align_of::<exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . retval as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( retval ) ));
}
impl Clone for exception {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn matherr(__exc: *mut exception) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut libc::c_void,
    pub __pad2: *mut libc::c_void,
    pub __pad3: *mut libc::c_void,
    pub __pad4: *mut libc::c_void,
    pub __pad5: usize,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<libc::c_uint>,
    pub __wchb: __BindgenUnionField<[libc::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: libc::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut libc::c_void,
                                               __buf: *mut libc::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut libc::c_void,
                                               __buf: *const libc::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut libc::c_void,
                                               __pos: *mut __off64_t,
                                               __w: libc::c_int)
                              -> libc::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut libc::c_void)
                              -> libc::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> libc::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> libc::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> libc::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: libc::c_int, __fp: *mut _IO_FILE) -> libc::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> libc::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> libc::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> libc::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> libc::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE, arg2: *const libc::c_char,
                       arg3: *mut __va_list_tag, arg4: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE, arg2: *const libc::c_char,
                        arg3: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: libc::c_int, arg3: __ssize_t)
     -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut libc::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: libc::c_int, arg4: libc::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: libc::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: libc::c_int, __old: *const libc::c_char,
                    __newfd: libc::c_int, __new: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const libc::c_char, __pfx: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const libc::c_char,
                 __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const libc::c_char,
                   __modes: *const libc::c_char, __stream: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char)
     -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut libc::c_void, __len: usize,
                    __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut libc::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut libc::c_char,
                   __modes: libc::c_int, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut libc::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut libc::c_char, __format: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const libc::c_char,
                    __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const libc::c_char, __arg: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut libc::c_char, __format: *const libc::c_char,
                    __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut libc::c_char, __maxlen: usize,
                    __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut libc::c_char, __maxlen: usize,
                     __format: *const libc::c_char, __arg: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: libc::c_int, __fmt: *const libc::c_char,
                    __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: libc::c_int, __fmt: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const libc::c_char,
                  __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const libc::c_char,
                   __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const libc::c_char,
                   __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const libc::c_char, __arg: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const libc::c_char, __format: *const libc::c_char,
                   __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const libc::c_char,
                    __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const libc::c_char, __arg: *mut __va_list_tag)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const libc::c_char, __format: *const libc::c_char,
                    __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: libc::c_int, __stream: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putw(__w: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut libc::c_char, __n: libc::c_int,
                 __stream: *mut FILE) -> *mut libc::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut libc::c_char, __n: *mut usize,
                      __delimiter: libc::c_int, __stream: *mut FILE)
     -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut libc::c_char, __n: *mut usize,
                    __delimiter: libc::c_int, __stream: *mut FILE)
     -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut libc::c_char, __n: *mut usize,
                   __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const libc::c_char, __stream: *mut FILE)
     -> libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut libc::c_void, __size: usize, __n: usize,
                 __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const libc::c_void, __size: usize, __n: usize,
                  __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut libc::c_void, __size: usize, __n: usize,
                          __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const libc::c_void, __size: usize,
                           __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: libc::c_long,
                 __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const libc::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: libc::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const libc::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const libc::c_char, __modes: *const libc::c_char)
     -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const libc::c_char,
                  __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const libc::c_char,
                  __endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const libc::c_char,
                   __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const libc::c_char,
                  __endptr: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const libc::c_char,
                   __endptr: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const libc::c_char,
                  __endptr: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const libc::c_char,
                   __endptr: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const libc::c_char,
                   __endptr: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const libc::c_char,
                    __endptr: *mut *mut libc::c_char, __base: libc::c_int)
     -> libc::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn a64l(__s: *const libc::c_char) -> libc::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulong;
pub type register_t = libc::c_long;
pub type __sig_atomic_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: libc::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> libc::c_int;
}
extern "C" {
    pub fn pselect(__nfds: libc::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> libc::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> libc::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> libc::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: libc::c_uint, __minor: libc::c_uint)
     -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[libc::c_char; 56usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[libc::c_char; 40usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[libc::c_char; 4usize]>,
    pub __align: __BindgenUnionField<libc::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[libc::c_char; 48usize]>,
    pub __align: __BindgenUnionField<libc::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __bindgen_anon_1: pthread_cond_t__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: pthread_cond_t__bindgen_ty_1__bindgen_ty_2,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    pub __wseq: __BindgenUnionField<libc::c_ulonglong>,
    pub __wseq32: __BindgenUnionField<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) .
                __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ) .
                __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( __high ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_1 )
                ) . __wseq as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __wseq ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_1 )
                ) . __wseq32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __wseq32 ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    pub __g1_start: __BindgenUnionField<libc::c_ulonglong>,
    pub __g1_start32: __BindgenUnionField<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ) .
                __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ) .
                __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( __high ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_2 )
                ) . __g1_start as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( __g1_start ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pthread_cond_t__bindgen_ty_1__bindgen_ty_2 )
                ) . __g1_start32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( __g1_start32 ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_refs as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __g_refs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_size as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __g_size
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g1_orig_size as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __g1_orig_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wrefs as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __wrefs
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __g_signals as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __g_signals ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[libc::c_char; 4usize]>,
    pub __align: __BindgenUnionField<libc::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[libc::c_char; 56usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __cur_writer: libc::c_int,
    pub __shared: libc::c_int,
    pub __rwelision: libc::c_schar,
    pub __pad1: [libc::c_uchar; 7usize],
    pub __pad2: libc::c_ulong,
    pub __flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __wrphase_futex as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wrphase_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writers_futex as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writers_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad3 as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad4 as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __cur_writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __cur_writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[libc::c_char; 8usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[libc::c_char; 32usize]>,
    pub __align: __BindgenUnionField<libc::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[libc::c_char; 4usize]>,
    pub __align: __BindgenUnionField<libc::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> libc::c_long;
}
extern "C" {
    pub fn srandom(__seed: libc::c_uint);
}
extern "C" {
    pub fn initstate(__seed: libc::c_uint, __statebuf: *mut libc::c_char,
                     __statelen: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: libc::c_int,
    pub rand_deg: libc::c_int,
    pub rand_sep: libc::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> libc::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: libc::c_uint, __buf: *mut random_data)
     -> libc::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: libc::c_uint, __statebuf: *mut libc::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> libc::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut libc::c_char, __buf: *mut random_data)
     -> libc::c_int;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(__seed: libc::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut libc::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> libc::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn mrand48() -> libc::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn srand48(__seedval: libc::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut libc::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [libc::c_ushort; 3usize],
    pub __old_x: [libc::c_ushort; 3usize],
    pub __c: libc::c_ushort,
    pub __init: libc::c_ushort,
    pub __a: libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> libc::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut libc::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> libc::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long)
     -> libc::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut libc::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut libc::c_long)
     -> libc::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long)
     -> libc::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut libc::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut libc::c_long)
     -> libc::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: libc::c_long, __buffer: *mut drand48_data)
     -> libc::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut libc::c_ushort,
                    __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut libc::c_ushort,
                     __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut libc::c_void, __size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut libc::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut libc::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut libc::c_void,
                          __alignment: usize, __size: usize) -> libc::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> libc::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> libc::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      libc::c_int,
                                                                  __arg:
                                                                      *mut libc::c_void)>,
                   __arg: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn exit(__status: libc::c_int);
}
extern "C" {
    pub fn quick_exit(__status: libc::c_int);
}
extern "C" {
    pub fn _Exit(__status: libc::c_int);
}
extern "C" {
    pub fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn setenv(__name: *const libc::c_char, __value: *const libc::c_char,
                  __replace: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn clearenv() -> libc::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut libc::c_char, __suffixlen: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(__command: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn realpath(__name: *const libc::c_char,
                    __resolved: *mut libc::c_char) -> *mut libc::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const libc::c_void,
                                               arg2: *const libc::c_void)
                              -> libc::c_int>;
extern "C" {
    pub fn bsearch(__key: *const libc::c_void, __base: *const libc::c_void,
                   __nmemb: usize, __size: usize, __compar: __compar_fn_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut libc::c_void, __nmemb: usize, __size: usize,
                 __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(__x: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(__x: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: libc::c_long, __denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: libc::c_longlong, __denom: libc::c_longlong)
     -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: libc::c_int,
                __decpt: *mut libc::c_int, __sign: *mut libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: libc::c_int,
                __decpt: *mut libc::c_int, __sign: *mut libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: libc::c_int, __buf: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: libc::c_int,
                 __decpt: *mut libc::c_int, __sign: *mut libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: libc::c_int,
                 __decpt: *mut libc::c_int, __sign: *mut libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: libc::c_int,
                 __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: libc::c_int,
                  __decpt: *mut libc::c_int, __sign: *mut libc::c_int,
                  __buf: *mut libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: libc::c_int,
                  __decpt: *mut libc::c_int, __sign: *mut libc::c_int,
                  __buf: *mut libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: libc::c_int,
                   __decpt: *mut libc::c_int, __sign: *mut libc::c_int,
                   __buf: *mut libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: libc::c_int,
                   __decpt: *mut libc::c_int, __sign: *mut libc::c_int,
                   __buf: *mut libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn mblen(__s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const libc::c_char, __n: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut libc::c_char, __wchar: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const libc::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut libc::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut libc::c_char,
                     __tokens: *const *const libc::c_char,
                     __valuep: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn memcpy(__dest: *mut libc::c_void, __src: *const libc::c_void,
                  __n: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut libc::c_void, __src: *const libc::c_void,
                   __n: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut libc::c_void, __src: *const libc::c_void,
                   __c: libc::c_int, __n: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(__s: *mut libc::c_void, __c: libc::c_int, __n: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const libc::c_void, __s2: *const libc::c_void,
                  __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn memchr(__s: *const libc::c_void, __c: libc::c_int, __n: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut libc::c_char, __src: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut libc::c_char, __src: *const libc::c_char,
                   __n: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut libc::c_char, __src: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut libc::c_char, __src: *const libc::c_char,
                   __n: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const libc::c_char, __s2: *const libc::c_char,
                   __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut libc::c_char, __src: *const libc::c_char,
                   __n: usize) -> libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const libc::c_char, __s2: *const libc::c_char,
                     __l: __locale_t) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut libc::c_char, __src: *const libc::c_char,
                     __n: usize, __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const libc::c_char, __n: usize)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const libc::c_char, __c: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const libc::c_char, __reject: *const libc::c_char)
     -> libc::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const libc::c_char, __accept: *const libc::c_char)
     -> libc::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const libc::c_char, __accept: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const libc::c_char,
                  __needle: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut libc::c_char, __delim: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut libc::c_char, __delim: *const libc::c_char,
                      __save_ptr: *mut *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut libc::c_char, __delim: *const libc::c_char,
                    __save_ptr: *mut *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(__s: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const libc::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: libc::c_int, __buf: *mut libc::c_char,
                      __buflen: usize) -> libc::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: libc::c_int, __l: __locale_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const libc::c_void, __dest: *mut libc::c_void,
                 __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn explicit_bzero(__s: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const libc::c_void, __s2: *const libc::c_void,
                __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn index(__s: *const libc::c_char, __c: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const libc::c_char, __c: libc::c_int)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn ffs(__i: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const libc::c_char, __s2: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const libc::c_char, __s2: *const libc::c_char,
                       __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut libc::c_char,
                  __delim: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut libc::c_char, __src: *const libc::c_char,
                     __n: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut libc::c_char, __src: *const libc::c_char,
                   __n: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn av_log2(v: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn av_strerror(errnum: libc::c_int, errbuf: *mut libc::c_char,
                       errbuf_size: usize) -> libc::c_int;
}
extern "C" {
    pub fn av_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_mallocz(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_realloc(ptr: *mut libc::c_void, size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn av_reallocp(ptr: *mut libc::c_void, size: usize) -> libc::c_int;
}
extern "C" {
    pub fn av_realloc_f(ptr: *mut libc::c_void, nelem: usize, elsize: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn av_realloc_array(ptr: *mut libc::c_void, nmemb: usize, size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn av_reallocp_array(ptr: *mut libc::c_void, nmemb: usize,
                             size: usize) -> libc::c_int;
}
extern "C" {
    pub fn av_fast_realloc(ptr: *mut libc::c_void, size: *mut libc::c_uint,
                           min_size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_fast_malloc(ptr: *mut libc::c_void, size: *mut libc::c_uint,
                          min_size: usize);
}
extern "C" {
    pub fn av_fast_mallocz(ptr: *mut libc::c_void, size: *mut libc::c_uint,
                           min_size: usize);
}
extern "C" {
    pub fn av_free(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn av_freep(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn av_strdup(s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn av_strndup(s: *const libc::c_char, len: usize)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn av_memdup(p: *const libc::c_void, size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn av_memcpy_backptr(dst: *mut u8, back: libc::c_int,
                             cnt: libc::c_int);
}
extern "C" {
    pub fn av_dynarray_add(tab_ptr: *mut libc::c_void,
                           nb_ptr: *mut libc::c_int, elem: *mut libc::c_void);
}
extern "C" {
    pub fn av_dynarray_add_nofree(tab_ptr: *mut libc::c_void,
                                  nb_ptr: *mut libc::c_int,
                                  elem: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn av_dynarray2_add(tab_ptr: *mut *mut libc::c_void,
                            nb_ptr: *mut libc::c_int, elem_size: usize,
                            elem_data: *const u8) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_max_alloc(max: usize);
}
extern "C" {
    pub fn av_reduce(dst_num: *mut libc::c_int, dst_den: *mut libc::c_int,
                     num: i64, den: i64, max: i64) -> libc::c_int;
}
extern "C" {
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    pub fn av_d2q(d: f64, max: libc::c_int) -> AVRational;
}
extern "C" {
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational)
     -> libc::c_int;
}
extern "C" {
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational)
     -> libc::c_int;
}
extern "C" {
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct av_intfloat32 {
    pub i: __BindgenUnionField<u32>,
    pub f: __BindgenUnionField<f32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_av_intfloat32() {
    assert_eq!(::std::mem::size_of::<av_intfloat32>() , 4usize , concat ! (
               "Size of: " , stringify ! ( av_intfloat32 ) ));
    assert_eq! (::std::mem::align_of::<av_intfloat32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( av_intfloat32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const av_intfloat32 ) ) . i as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( av_intfloat32 ) , "::"
                , stringify ! ( i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const av_intfloat32 ) ) . f as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( av_intfloat32 ) , "::"
                , stringify ! ( f ) ));
}
impl Clone for av_intfloat32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct av_intfloat64 {
    pub i: __BindgenUnionField<u64>,
    pub f: __BindgenUnionField<f64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_av_intfloat64() {
    assert_eq!(::std::mem::size_of::<av_intfloat64>() , 8usize , concat ! (
               "Size of: " , stringify ! ( av_intfloat64 ) ));
    assert_eq! (::std::mem::align_of::<av_intfloat64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( av_intfloat64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const av_intfloat64 ) ) . i as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( av_intfloat64 ) , "::"
                , stringify ! ( i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const av_intfloat64 ) ) . f as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( av_intfloat64 ) , "::"
                , stringify ! ( f ) ));
}
impl Clone for av_intfloat64 {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVRounding {
    AV_ROUND_ZERO = 0,
    AV_ROUND_INF = 1,
    AV_ROUND_DOWN = 2,
    AV_ROUND_UP = 3,
    AV_ROUND_NEAR_INF = 5,
    AV_ROUND_PASS_MINMAX = 8192,
}
extern "C" {
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational,
                            rnd: AVRounding) -> i64;
}
extern "C" {
    pub fn av_compare_ts(ts_a: i64, tb_a: AVRational, ts_b: i64,
                         tb_b: AVRational) -> libc::c_int;
}
extern "C" {
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    pub fn av_rescale_delta(in_tb: AVRational, in_ts: i64, fs_tb: AVRational,
                            duration: libc::c_int, last: *mut i64,
                            out_tb: AVRational) -> i64;
}
extern "C" {
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational,
                         inc: i64) -> i64;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVClassCategory {
    AV_CLASS_CATEGORY_NA = 0,
    AV_CLASS_CATEGORY_INPUT = 1,
    AV_CLASS_CATEGORY_OUTPUT = 2,
    AV_CLASS_CATEGORY_MUXER = 3,
    AV_CLASS_CATEGORY_DEMUXER = 4,
    AV_CLASS_CATEGORY_ENCODER = 5,
    AV_CLASS_CATEGORY_DECODER = 6,
    AV_CLASS_CATEGORY_FILTER = 7,
    AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8,
    AV_CLASS_CATEGORY_SWSCALER = 9,
    AV_CLASS_CATEGORY_SWRESAMPLER = 10,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43,
    AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44,
    AV_CLASS_CATEGORY_DEVICE_INPUT = 45,
    AV_CLASS_CATEGORY_NB = 46,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVOptionRanges {
    pub range: *mut *mut AVOptionRange,
    pub nb_ranges: libc::c_int,
    pub nb_components: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRanges() {
    assert_eq!(::std::mem::size_of::<AVOptionRanges>() , 16usize , concat ! (
               "Size of: " , stringify ! ( AVOptionRanges ) ));
    assert_eq! (::std::mem::align_of::<AVOptionRanges>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVOptionRanges ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRanges ) ) . range as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRanges ) , "::"
                , stringify ! ( range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRanges ) ) . nb_ranges as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRanges ) , "::"
                , stringify ! ( nb_ranges ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRanges ) ) . nb_components as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRanges ) , "::"
                , stringify ! ( nb_components ) ));
}
impl Clone for AVOptionRanges {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVClass {
    pub class_name: *const libc::c_char,
    pub item_name: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                                  *mut libc::c_void)
                                             -> *const libc::c_char>,
    pub option: *const AVOption,
    pub version: libc::c_int,
    pub log_level_offset_offset: libc::c_int,
    pub parent_log_context_offset: libc::c_int,
    pub child_next: ::std::option::Option<unsafe extern "C" fn(obj:
                                                                   *mut libc::c_void,
                                                               prev:
                                                                   *mut libc::c_void)
                                              -> *mut libc::c_void>,
    pub child_class_next: ::std::option::Option<unsafe extern "C" fn(prev:
                                                                         *const AVClass)
                                                    -> *const AVClass>,
    pub category: AVClassCategory,
    pub get_category: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                                     *mut libc::c_void)
                                                -> AVClassCategory>,
    pub query_ranges: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut *mut AVOptionRanges,
                                                                 obj:
                                                                     *mut libc::c_void,
                                                                 key:
                                                                     *const libc::c_char,
                                                                 flags:
                                                                     libc::c_int)
                                                -> libc::c_int>,
}
#[test]
fn bindgen_test_layout_AVClass() {
    assert_eq!(::std::mem::size_of::<AVClass>() , 80usize , concat ! (
               "Size of: " , stringify ! ( AVClass ) ));
    assert_eq! (::std::mem::align_of::<AVClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . class_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( class_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . item_name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( item_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . option as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( option ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . version as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . log_level_offset_offset as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( log_level_offset_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . parent_log_context_offset
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( parent_log_context_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . child_next as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( child_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . child_class_next as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( child_class_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . category as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( category ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . get_category as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( get_category ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVClass ) ) . query_ranges as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVClass ) , "::" ,
                stringify ! ( query_ranges ) ));
}
impl Clone for AVClass {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn av_log(avcl: *mut libc::c_void, level: libc::c_int,
                  fmt: *const libc::c_char, ...);
}
extern "C" {
    pub fn av_vlog(avcl: *mut libc::c_void, level: libc::c_int,
                   fmt: *const libc::c_char, vl: *mut __va_list_tag);
}
extern "C" {
    pub fn av_log_get_level() -> libc::c_int;
}
extern "C" {
    pub fn av_log_set_level(level: libc::c_int);
}
extern "C" {
    pub fn av_log_set_callback(callback:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut libc::c_void,
                                                                              arg2:
                                                                                  libc::c_int,
                                                                              arg3:
                                                                                  *const libc::c_char,
                                                                              arg4:
                                                                                  *mut __va_list_tag)>);
}
extern "C" {
    pub fn av_log_default_callback(avcl: *mut libc::c_void,
                                   level: libc::c_int,
                                   fmt: *const libc::c_char,
                                   vl: *mut __va_list_tag);
}
extern "C" {
    pub fn av_default_item_name(ctx: *mut libc::c_void)
     -> *const libc::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut libc::c_void) -> AVClassCategory;
}
extern "C" {
    pub fn av_log_format_line(ptr: *mut libc::c_void, level: libc::c_int,
                              fmt: *const libc::c_char,
                              vl: *mut __va_list_tag, line: *mut libc::c_char,
                              line_size: libc::c_int,
                              print_prefix: *mut libc::c_int);
}
extern "C" {
    pub fn av_log_format_line2(ptr: *mut libc::c_void, level: libc::c_int,
                               fmt: *const libc::c_char,
                               vl: *mut __va_list_tag,
                               line: *mut libc::c_char,
                               line_size: libc::c_int,
                               print_prefix: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: libc::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> libc::c_int;
}
pub const AV_PIX_FMT_XVMC: AVPixelFormat =
    AVPixelFormat::AV_PIX_FMT_XVMC_MPEG2_IDCT;
pub const AV_PIX_FMT_VAAPI: AVPixelFormat =
    AVPixelFormat::AV_PIX_FMT_VAAPI_VLD;
pub const AV_PIX_FMT_Y400A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
pub const AV_PIX_FMT_GBR24P: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_GBRP;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVPixelFormat {
    AV_PIX_FMT_NONE = -1,
    AV_PIX_FMT_YUV420P = 0,
    AV_PIX_FMT_YUYV422 = 1,
    AV_PIX_FMT_RGB24 = 2,
    AV_PIX_FMT_BGR24 = 3,
    AV_PIX_FMT_YUV422P = 4,
    AV_PIX_FMT_YUV444P = 5,
    AV_PIX_FMT_YUV410P = 6,
    AV_PIX_FMT_YUV411P = 7,
    AV_PIX_FMT_GRAY8 = 8,
    AV_PIX_FMT_MONOWHITE = 9,
    AV_PIX_FMT_MONOBLACK = 10,
    AV_PIX_FMT_PAL8 = 11,
    AV_PIX_FMT_YUVJ420P = 12,
    AV_PIX_FMT_YUVJ422P = 13,
    AV_PIX_FMT_YUVJ444P = 14,
    AV_PIX_FMT_XVMC_MPEG2_MC = 15,
    AV_PIX_FMT_XVMC_MPEG2_IDCT = 16,
    AV_PIX_FMT_UYVY422 = 17,
    AV_PIX_FMT_UYYVYY411 = 18,
    AV_PIX_FMT_BGR8 = 19,
    AV_PIX_FMT_BGR4 = 20,
    AV_PIX_FMT_BGR4_BYTE = 21,
    AV_PIX_FMT_RGB8 = 22,
    AV_PIX_FMT_RGB4 = 23,
    AV_PIX_FMT_RGB4_BYTE = 24,
    AV_PIX_FMT_NV12 = 25,
    AV_PIX_FMT_NV21 = 26,
    AV_PIX_FMT_ARGB = 27,
    AV_PIX_FMT_RGBA = 28,
    AV_PIX_FMT_ABGR = 29,
    AV_PIX_FMT_BGRA = 30,
    AV_PIX_FMT_GRAY16BE = 31,
    AV_PIX_FMT_GRAY16LE = 32,
    AV_PIX_FMT_YUV440P = 33,
    AV_PIX_FMT_YUVJ440P = 34,
    AV_PIX_FMT_YUVA420P = 35,
    AV_PIX_FMT_VDPAU_H264 = 36,
    AV_PIX_FMT_VDPAU_MPEG1 = 37,
    AV_PIX_FMT_VDPAU_MPEG2 = 38,
    AV_PIX_FMT_VDPAU_WMV3 = 39,
    AV_PIX_FMT_VDPAU_VC1 = 40,
    AV_PIX_FMT_RGB48BE = 41,
    AV_PIX_FMT_RGB48LE = 42,
    AV_PIX_FMT_RGB565BE = 43,
    AV_PIX_FMT_RGB565LE = 44,
    AV_PIX_FMT_RGB555BE = 45,
    AV_PIX_FMT_RGB555LE = 46,
    AV_PIX_FMT_BGR565BE = 47,
    AV_PIX_FMT_BGR565LE = 48,
    AV_PIX_FMT_BGR555BE = 49,
    AV_PIX_FMT_BGR555LE = 50,
    AV_PIX_FMT_VAAPI_MOCO = 51,
    AV_PIX_FMT_VAAPI_IDCT = 52,
    AV_PIX_FMT_VAAPI_VLD = 53,
    AV_PIX_FMT_YUV420P16LE = 54,
    AV_PIX_FMT_YUV420P16BE = 55,
    AV_PIX_FMT_YUV422P16LE = 56,
    AV_PIX_FMT_YUV422P16BE = 57,
    AV_PIX_FMT_YUV444P16LE = 58,
    AV_PIX_FMT_YUV444P16BE = 59,
    AV_PIX_FMT_VDPAU_MPEG4 = 60,
    AV_PIX_FMT_DXVA2_VLD = 61,
    AV_PIX_FMT_RGB444LE = 62,
    AV_PIX_FMT_RGB444BE = 63,
    AV_PIX_FMT_BGR444LE = 64,
    AV_PIX_FMT_BGR444BE = 65,
    AV_PIX_FMT_YA8 = 66,
    AV_PIX_FMT_BGR48BE = 67,
    AV_PIX_FMT_BGR48LE = 68,
    AV_PIX_FMT_YUV420P9BE = 69,
    AV_PIX_FMT_YUV420P9LE = 70,
    AV_PIX_FMT_YUV420P10BE = 71,
    AV_PIX_FMT_YUV420P10LE = 72,
    AV_PIX_FMT_YUV422P10BE = 73,
    AV_PIX_FMT_YUV422P10LE = 74,
    AV_PIX_FMT_YUV444P9BE = 75,
    AV_PIX_FMT_YUV444P9LE = 76,
    AV_PIX_FMT_YUV444P10BE = 77,
    AV_PIX_FMT_YUV444P10LE = 78,
    AV_PIX_FMT_YUV422P9BE = 79,
    AV_PIX_FMT_YUV422P9LE = 80,
    AV_PIX_FMT_VDA_VLD = 81,
    AV_PIX_FMT_GBRP = 82,
    AV_PIX_FMT_GBRP9BE = 83,
    AV_PIX_FMT_GBRP9LE = 84,
    AV_PIX_FMT_GBRP10BE = 85,
    AV_PIX_FMT_GBRP10LE = 86,
    AV_PIX_FMT_GBRP16BE = 87,
    AV_PIX_FMT_GBRP16LE = 88,
    AV_PIX_FMT_YUVA422P = 89,
    AV_PIX_FMT_YUVA444P = 90,
    AV_PIX_FMT_YUVA420P9BE = 91,
    AV_PIX_FMT_YUVA420P9LE = 92,
    AV_PIX_FMT_YUVA422P9BE = 93,
    AV_PIX_FMT_YUVA422P9LE = 94,
    AV_PIX_FMT_YUVA444P9BE = 95,
    AV_PIX_FMT_YUVA444P9LE = 96,
    AV_PIX_FMT_YUVA420P10BE = 97,
    AV_PIX_FMT_YUVA420P10LE = 98,
    AV_PIX_FMT_YUVA422P10BE = 99,
    AV_PIX_FMT_YUVA422P10LE = 100,
    AV_PIX_FMT_YUVA444P10BE = 101,
    AV_PIX_FMT_YUVA444P10LE = 102,
    AV_PIX_FMT_YUVA420P16BE = 103,
    AV_PIX_FMT_YUVA420P16LE = 104,
    AV_PIX_FMT_YUVA422P16BE = 105,
    AV_PIX_FMT_YUVA422P16LE = 106,
    AV_PIX_FMT_YUVA444P16BE = 107,
    AV_PIX_FMT_YUVA444P16LE = 108,
    AV_PIX_FMT_VDPAU = 109,
    AV_PIX_FMT_XYZ12LE = 110,
    AV_PIX_FMT_XYZ12BE = 111,
    AV_PIX_FMT_NV16 = 112,
    AV_PIX_FMT_NV20LE = 113,
    AV_PIX_FMT_NV20BE = 114,
    AV_PIX_FMT_RGBA64BE = 115,
    AV_PIX_FMT_RGBA64LE = 116,
    AV_PIX_FMT_BGRA64BE = 117,
    AV_PIX_FMT_BGRA64LE = 118,
    AV_PIX_FMT_YVYU422 = 119,
    AV_PIX_FMT_VDA = 120,
    AV_PIX_FMT_YA16BE = 121,
    AV_PIX_FMT_YA16LE = 122,
    AV_PIX_FMT_GBRAP = 123,
    AV_PIX_FMT_GBRAP16BE = 124,
    AV_PIX_FMT_GBRAP16LE = 125,
    AV_PIX_FMT_QSV = 126,
    AV_PIX_FMT_MMAL = 127,
    AV_PIX_FMT_D3D11VA_VLD = 128,
    AV_PIX_FMT_CUDA = 129,
    AV_PIX_FMT_0RGB = 295,
    AV_PIX_FMT_RGB0 = 296,
    AV_PIX_FMT_0BGR = 297,
    AV_PIX_FMT_BGR0 = 298,
    AV_PIX_FMT_YUV420P12BE = 299,
    AV_PIX_FMT_YUV420P12LE = 300,
    AV_PIX_FMT_YUV420P14BE = 301,
    AV_PIX_FMT_YUV420P14LE = 302,
    AV_PIX_FMT_YUV422P12BE = 303,
    AV_PIX_FMT_YUV422P12LE = 304,
    AV_PIX_FMT_YUV422P14BE = 305,
    AV_PIX_FMT_YUV422P14LE = 306,
    AV_PIX_FMT_YUV444P12BE = 307,
    AV_PIX_FMT_YUV444P12LE = 308,
    AV_PIX_FMT_YUV444P14BE = 309,
    AV_PIX_FMT_YUV444P14LE = 310,
    AV_PIX_FMT_GBRP12BE = 311,
    AV_PIX_FMT_GBRP12LE = 312,
    AV_PIX_FMT_GBRP14BE = 313,
    AV_PIX_FMT_GBRP14LE = 314,
    AV_PIX_FMT_YUVJ411P = 315,
    AV_PIX_FMT_BAYER_BGGR8 = 316,
    AV_PIX_FMT_BAYER_RGGB8 = 317,
    AV_PIX_FMT_BAYER_GBRG8 = 318,
    AV_PIX_FMT_BAYER_GRBG8 = 319,
    AV_PIX_FMT_BAYER_BGGR16LE = 320,
    AV_PIX_FMT_BAYER_BGGR16BE = 321,
    AV_PIX_FMT_BAYER_RGGB16LE = 322,
    AV_PIX_FMT_BAYER_RGGB16BE = 323,
    AV_PIX_FMT_BAYER_GBRG16LE = 324,
    AV_PIX_FMT_BAYER_GBRG16BE = 325,
    AV_PIX_FMT_BAYER_GRBG16LE = 326,
    AV_PIX_FMT_BAYER_GRBG16BE = 327,
    AV_PIX_FMT_YUV440P10LE = 328,
    AV_PIX_FMT_YUV440P10BE = 329,
    AV_PIX_FMT_YUV440P12LE = 330,
    AV_PIX_FMT_YUV440P12BE = 331,
    AV_PIX_FMT_AYUV64LE = 332,
    AV_PIX_FMT_AYUV64BE = 333,
    AV_PIX_FMT_VIDEOTOOLBOX = 334,
    AV_PIX_FMT_P010LE = 335,
    AV_PIX_FMT_P010BE = 336,
    AV_PIX_FMT_GBRAP12BE = 337,
    AV_PIX_FMT_GBRAP12LE = 338,
    AV_PIX_FMT_GBRAP10BE = 339,
    AV_PIX_FMT_GBRAP10LE = 340,
    AV_PIX_FMT_MEDIACODEC = 341,
    AV_PIX_FMT_GRAY12BE = 342,
    AV_PIX_FMT_GRAY12LE = 343,
    AV_PIX_FMT_GRAY10BE = 344,
    AV_PIX_FMT_GRAY10LE = 345,
    AV_PIX_FMT_P016LE = 346,
    AV_PIX_FMT_P016BE = 347,
    AV_PIX_FMT_NB = 348,
}
pub const AVCOL_PRI_SMPTEST428_1: AVColorPrimaries =
    AVColorPrimaries::AVCOL_PRI_SMPTE428;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVColorPrimaries {
    AVCOL_PRI_RESERVED0 = 0,
    AVCOL_PRI_BT709 = 1,
    AVCOL_PRI_UNSPECIFIED = 2,
    AVCOL_PRI_RESERVED = 3,
    AVCOL_PRI_BT470M = 4,
    AVCOL_PRI_BT470BG = 5,
    AVCOL_PRI_SMPTE170M = 6,
    AVCOL_PRI_SMPTE240M = 7,
    AVCOL_PRI_FILM = 8,
    AVCOL_PRI_BT2020 = 9,
    AVCOL_PRI_SMPTE428 = 10,
    AVCOL_PRI_SMPTE431 = 11,
    AVCOL_PRI_SMPTE432 = 12,
    AVCOL_PRI_JEDEC_P22 = 22,
    AVCOL_PRI_NB = 23,
}
pub const AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic =
    AVColorTransferCharacteristic::AVCOL_TRC_SMPTE2084;
pub const AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic =
    AVColorTransferCharacteristic::AVCOL_TRC_SMPTE428;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVColorTransferCharacteristic {
    AVCOL_TRC_RESERVED0 = 0,
    AVCOL_TRC_BT709 = 1,
    AVCOL_TRC_UNSPECIFIED = 2,
    AVCOL_TRC_RESERVED = 3,
    AVCOL_TRC_GAMMA22 = 4,
    AVCOL_TRC_GAMMA28 = 5,
    AVCOL_TRC_SMPTE170M = 6,
    AVCOL_TRC_SMPTE240M = 7,
    AVCOL_TRC_LINEAR = 8,
    AVCOL_TRC_LOG = 9,
    AVCOL_TRC_LOG_SQRT = 10,
    AVCOL_TRC_IEC61966_2_4 = 11,
    AVCOL_TRC_BT1361_ECG = 12,
    AVCOL_TRC_IEC61966_2_1 = 13,
    AVCOL_TRC_BT2020_10 = 14,
    AVCOL_TRC_BT2020_12 = 15,
    AVCOL_TRC_SMPTE2084 = 16,
    AVCOL_TRC_SMPTE428 = 17,
    AVCOL_TRC_ARIB_STD_B67 = 18,
    AVCOL_TRC_NB = 19,
}
pub const AVCOL_SPC_YCOCG: AVColorSpace = AVColorSpace::AVCOL_SPC_YCGCO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVColorSpace {
    AVCOL_SPC_RGB = 0,
    AVCOL_SPC_BT709 = 1,
    AVCOL_SPC_UNSPECIFIED = 2,
    AVCOL_SPC_RESERVED = 3,
    AVCOL_SPC_FCC = 4,
    AVCOL_SPC_BT470BG = 5,
    AVCOL_SPC_SMPTE170M = 6,
    AVCOL_SPC_SMPTE240M = 7,
    AVCOL_SPC_YCGCO = 8,
    AVCOL_SPC_BT2020_NCL = 9,
    AVCOL_SPC_BT2020_CL = 10,
    AVCOL_SPC_SMPTE2085 = 11,
    AVCOL_SPC_NB = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVColorRange {
    AVCOL_RANGE_UNSPECIFIED = 0,
    AVCOL_RANGE_MPEG = 1,
    AVCOL_RANGE_JPEG = 2,
    AVCOL_RANGE_NB = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVChromaLocation {
    AVCHROMA_LOC_UNSPECIFIED = 0,
    AVCHROMA_LOC_LEFT = 1,
    AVCHROMA_LOC_CENTER = 2,
    AVCHROMA_LOC_TOPLEFT = 3,
    AVCHROMA_LOC_TOP = 4,
    AVCHROMA_LOC_BOTTOMLEFT = 5,
    AVCHROMA_LOC_BOTTOM = 6,
    AVCHROMA_LOC_NB = 7,
}
extern "C" {
    pub fn av_int_list_length_for_size(elsize: libc::c_uint,
                                       list: *const libc::c_void, term: u64)
     -> libc::c_uint;
}
extern "C" {
    pub fn av_fopen_utf8(path: *const libc::c_char, mode: *const libc::c_char)
     -> *mut FILE;
}
extern "C" {
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    pub fn av_fourcc_make_string(buf: *mut libc::c_char, fourcc: u32)
     -> *mut libc::c_char;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVSampleFormat {
    AV_SAMPLE_FMT_NONE = -1,
    AV_SAMPLE_FMT_U8 = 0,
    AV_SAMPLE_FMT_S16 = 1,
    AV_SAMPLE_FMT_S32 = 2,
    AV_SAMPLE_FMT_FLT = 3,
    AV_SAMPLE_FMT_DBL = 4,
    AV_SAMPLE_FMT_U8P = 5,
    AV_SAMPLE_FMT_S16P = 6,
    AV_SAMPLE_FMT_S32P = 7,
    AV_SAMPLE_FMT_FLTP = 8,
    AV_SAMPLE_FMT_DBLP = 9,
    AV_SAMPLE_FMT_S64 = 10,
    AV_SAMPLE_FMT_S64P = 11,
    AV_SAMPLE_FMT_NB = 12,
}
extern "C" {
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat)
     -> *const libc::c_char;
}
extern "C" {
    pub fn av_get_sample_fmt(name: *const libc::c_char) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_alt_sample_fmt(sample_fmt: AVSampleFormat,
                                 planar: libc::c_int) -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat)
     -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat)
     -> AVSampleFormat;
}
extern "C" {
    pub fn av_get_sample_fmt_string(buf: *mut libc::c_char,
                                    buf_size: libc::c_int,
                                    sample_fmt: AVSampleFormat)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_get_buffer_size(linesize: *mut libc::c_int,
                                      nb_channels: libc::c_int,
                                      nb_samples: libc::c_int,
                                      sample_fmt: AVSampleFormat,
                                      align: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_fill_arrays(audio_data: *mut *mut u8,
                                  linesize: *mut libc::c_int, buf: *const u8,
                                  nb_channels: libc::c_int,
                                  nb_samples: libc::c_int,
                                  sample_fmt: AVSampleFormat,
                                  align: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_alloc(audio_data: *mut *mut u8,
                            linesize: *mut libc::c_int,
                            nb_channels: libc::c_int, nb_samples: libc::c_int,
                            sample_fmt: AVSampleFormat, align: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_samples_alloc_array_and_samples(audio_data: *mut *mut *mut u8,
                                              linesize: *mut libc::c_int,
                                              nb_channels: libc::c_int,
                                              nb_samples: libc::c_int,
                                              sample_fmt: AVSampleFormat,
                                              align: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_samples_copy(dst: *mut *mut u8, src: *const *const u8,
                           dst_offset: libc::c_int, src_offset: libc::c_int,
                           nb_samples: libc::c_int, nb_channels: libc::c_int,
                           sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    pub fn av_samples_set_silence(audio_data: *mut *mut u8,
                                  offset: libc::c_int,
                                  nb_samples: libc::c_int,
                                  nb_channels: libc::c_int,
                                  sample_fmt: AVSampleFormat) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    pub data: *mut u8,
    pub size: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVBufferRef() {
    assert_eq!(::std::mem::size_of::<AVBufferRef>() , 24usize , concat ! (
               "Size of: " , stringify ! ( AVBufferRef ) ));
    assert_eq! (::std::mem::align_of::<AVBufferRef>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVBufferRef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferRef ) ) . buffer as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferRef ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferRef ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferRef ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferRef ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferRef ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for AVBufferRef {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn av_buffer_alloc(size: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_allocz(size: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_create(data: *mut u8, size: libc::c_int,
                            free:
                                ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                               *mut libc::c_void,
                                                                           data:
                                                                               *mut u8)>,
                            opaque: *mut libc::c_void, flags: libc::c_int)
     -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_default_free(opaque: *mut libc::c_void, data: *mut u8);
}
extern "C" {
    pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> libc::c_int;
}
extern "C" {
    pub fn av_buffer_realloc(buf: *mut *mut AVBufferRef, size: libc::c_int)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_buffer_pool_init(size: libc::c_int,
                               alloc:
                                   ::std::option::Option<unsafe extern "C" fn(size:
                                                                                  libc::c_int)
                                                             ->
                                                                 *mut AVBufferRef>)
     -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_init2(size: libc::c_int, opaque: *mut libc::c_void,
                                alloc:
                                    ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                                   *mut libc::c_void,
                                                                               size:
                                                                                   libc::c_int)
                                                              ->
                                                                  *mut AVBufferRef>,
                                pool_free:
                                    ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                                   *mut libc::c_void)>)
     -> *mut AVBufferPool;
}
extern "C" {
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_get_cpu_flags() -> libc::c_int;
}
extern "C" {
    pub fn av_force_cpu_flags(flags: libc::c_int);
}
extern "C" {
    pub fn av_set_cpu_flags_mask(mask: libc::c_int);
}
extern "C" {
    pub fn av_parse_cpu_flags(s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn av_parse_cpu_caps(flags: *mut libc::c_uint, s: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn av_cpu_count() -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVMatrixEncoding {
    AV_MATRIX_ENCODING_NONE = 0,
    AV_MATRIX_ENCODING_DOLBY = 1,
    AV_MATRIX_ENCODING_DPLII = 2,
    AV_MATRIX_ENCODING_DPLIIX = 3,
    AV_MATRIX_ENCODING_DPLIIZ = 4,
    AV_MATRIX_ENCODING_DOLBYEX = 5,
    AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6,
    AV_MATRIX_ENCODING_NB = 7,
}
extern "C" {
    pub fn av_get_channel_layout(name: *const libc::c_char) -> u64;
}
extern "C" {
    pub fn av_get_extended_channel_layout(name: *const libc::c_char,
                                          channel_layout: *mut u64,
                                          nb_channels: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_get_channel_layout_string(buf: *mut libc::c_char,
                                        buf_size: libc::c_int,
                                        nb_channels: libc::c_int,
                                        channel_layout: u64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_bprint_channel_layout(bp: *mut AVBPrint,
                                    nb_channels: libc::c_int,
                                    channel_layout: u64);
}
extern "C" {
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64)
     -> libc::c_int;
}
extern "C" {
    pub fn av_get_default_channel_layout(nb_channels: libc::c_int) -> i64;
}
extern "C" {
    pub fn av_get_channel_layout_channel_index(channel_layout: u64,
                                               channel: u64) -> libc::c_int;
}
extern "C" {
    pub fn av_channel_layout_extract_channel(channel_layout: u64,
                                             index: libc::c_int) -> u64;
}
extern "C" {
    pub fn av_get_channel_name(channel: u64) -> *const libc::c_char;
}
extern "C" {
    pub fn av_get_channel_description(channel: u64) -> *const libc::c_char;
}
extern "C" {
    pub fn av_get_standard_channel_layout(index: libc::c_uint,
                                          layout: *mut u64,
                                          name: *mut *const libc::c_char)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVDictionaryEntry {
    pub key: *mut libc::c_char,
    pub value: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_AVDictionaryEntry() {
    assert_eq!(::std::mem::size_of::<AVDictionaryEntry>() , 16usize , concat !
               ( "Size of: " , stringify ! ( AVDictionaryEntry ) ));
    assert_eq! (::std::mem::align_of::<AVDictionaryEntry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AVDictionaryEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDictionaryEntry ) ) . key as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDictionaryEntry ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDictionaryEntry ) ) . value as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDictionaryEntry ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for AVDictionaryEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    pub fn av_dict_get(m: *const AVDictionary, key: *const libc::c_char,
                       prev: *const AVDictionaryEntry, flags: libc::c_int)
     -> *mut AVDictionaryEntry;
}
extern "C" {
    pub fn av_dict_count(m: *const AVDictionary) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_set(pm: *mut *mut AVDictionary, key: *const libc::c_char,
                       value: *const libc::c_char, flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_dict_set_int(pm: *mut *mut AVDictionary,
                           key: *const libc::c_char, value: i64,
                           flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_parse_string(pm: *mut *mut AVDictionary,
                                str: *const libc::c_char,
                                key_val_sep: *const libc::c_char,
                                pairs_sep: *const libc::c_char,
                                flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_copy(dst: *mut *mut AVDictionary, src: *const AVDictionary,
                        flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    pub fn av_dict_get_string(m: *const AVDictionary,
                              buffer: *mut *mut libc::c_char,
                              key_val_sep: libc::c_char,
                              pairs_sep: libc::c_char) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVFrameSideDataType {
    AV_FRAME_DATA_PANSCAN = 0,
    AV_FRAME_DATA_A53_CC = 1,
    AV_FRAME_DATA_STEREO3D = 2,
    AV_FRAME_DATA_MATRIXENCODING = 3,
    AV_FRAME_DATA_DOWNMIX_INFO = 4,
    AV_FRAME_DATA_REPLAYGAIN = 5,
    AV_FRAME_DATA_DISPLAYMATRIX = 6,
    AV_FRAME_DATA_AFD = 7,
    AV_FRAME_DATA_MOTION_VECTORS = 8,
    AV_FRAME_DATA_SKIP_SAMPLES = 9,
    AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10,
    AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11,
    AV_FRAME_DATA_GOP_TIMECODE = 12,
    AV_FRAME_DATA_SPHERICAL = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVActiveFormatDescription {
    AV_AFD_SAME = 8,
    AV_AFD_4_3 = 9,
    AV_AFD_16_9 = 10,
    AV_AFD_14_9 = 11,
    AV_AFD_4_3_SP_14_9 = 13,
    AV_AFD_16_9_SP_14_9 = 14,
    AV_AFD_SP_4_3 = 15,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: libc::c_int,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrameSideData() {
    assert_eq!(::std::mem::size_of::<AVFrameSideData>() , 40usize , concat ! (
               "Size of: " , stringify ! ( AVFrameSideData ) ));
    assert_eq! (::std::mem::align_of::<AVFrameSideData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AVFrameSideData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrameSideData ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrameSideData ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrameSideData ) ) . data as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrameSideData ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrameSideData ) ) . size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrameSideData ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrameSideData ) ) . metadata as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrameSideData ) ,
                "::" , stringify ! ( metadata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrameSideData ) ) . buf as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrameSideData ) ,
                "::" , stringify ! ( buf ) ));
}
impl Clone for AVFrameSideData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFrame {
    pub data: [*mut u8; 8usize],
    pub linesize: [libc::c_int; 8usize],
    pub extended_data: *mut *mut u8,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub nb_samples: libc::c_int,
    pub format: libc::c_int,
    pub key_frame: libc::c_int,
    pub pict_type: AVPictureType,
    pub sample_aspect_ratio: AVRational,
    pub pts: i64,
    pub pkt_pts: i64,
    pub pkt_dts: i64,
    pub coded_picture_number: libc::c_int,
    pub display_picture_number: libc::c_int,
    pub quality: libc::c_int,
    pub opaque: *mut libc::c_void,
    pub error: [u64; 8usize],
    pub repeat_pict: libc::c_int,
    pub interlaced_frame: libc::c_int,
    pub top_field_first: libc::c_int,
    pub palette_has_changed: libc::c_int,
    pub reordered_opaque: i64,
    pub sample_rate: libc::c_int,
    pub channel_layout: u64,
    pub buf: [*mut AVBufferRef; 8usize],
    pub extended_buf: *mut *mut AVBufferRef,
    pub nb_extended_buf: libc::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: libc::c_int,
    pub flags: libc::c_int,
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    pub best_effort_timestamp: i64,
    pub pkt_pos: i64,
    pub pkt_duration: i64,
    pub metadata: *mut AVDictionary,
    pub decode_error_flags: libc::c_int,
    pub channels: libc::c_int,
    pub pkt_size: libc::c_int,
    pub qscale_table: *mut i8,
    pub qstride: libc::c_int,
    pub qscale_type: libc::c_int,
    pub qp_table_buf: *mut AVBufferRef,
    pub hw_frames_ctx: *mut AVBufferRef,
    pub opaque_ref: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrame() {
    assert_eq!(::std::mem::size_of::<AVFrame>() , 496usize , concat ! (
               "Size of: " , stringify ! ( AVFrame ) ));
    assert_eq! (::std::mem::align_of::<AVFrame>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . data as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . linesize as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( linesize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . extended_data as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( extended_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . width as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . height as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . nb_samples as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( nb_samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . format as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . key_frame as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( key_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . pict_type as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( pict_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . sample_aspect_ratio as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( sample_aspect_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . pts as * const _ as usize }
                , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . pkt_pts as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( pkt_pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . pkt_dts as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( pkt_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . coded_picture_number as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( coded_picture_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . display_picture_number as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( display_picture_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . quality as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( quality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . opaque as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . error as * const _ as usize
                } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . repeat_pict as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( repeat_pict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . interlaced_frame as * const
                _ as usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( interlaced_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . top_field_first as * const
                _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( top_field_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . palette_has_changed as *
                const _ as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( palette_has_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . reordered_opaque as * const
                _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( reordered_opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . sample_rate as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( sample_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . channel_layout as * const _
                as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( channel_layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . buf as * const _ as usize }
                , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . extended_buf as * const _
                as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( extended_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . nb_extended_buf as * const
                _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( nb_extended_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . side_data as * const _ as
                usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( side_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . nb_side_data as * const _
                as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( nb_side_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . flags as * const _ as usize
                } , 380usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . color_range as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( color_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . color_primaries as * const
                _ as usize } , 388usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( color_primaries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . color_trc as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( color_trc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . colorspace as * const _ as
                usize } , 396usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( colorspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . chroma_location as * const
                _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( chroma_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . best_effort_timestamp as *
                const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( best_effort_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . pkt_pos as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( pkt_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . pkt_duration as * const _
                as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( pkt_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . metadata as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( metadata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . decode_error_flags as *
                const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( decode_error_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . channels as * const _ as
                usize } , 444usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . pkt_size as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( pkt_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . qscale_table as * const _
                as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( qscale_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . qstride as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( qstride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . qscale_type as * const _ as
                usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( qscale_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . qp_table_buf as * const _
                as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( qp_table_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . hw_frames_ctx as * const _
                as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( hw_frames_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrame ) ) . opaque_ref as * const _ as
                usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrame ) , "::" ,
                stringify ! ( opaque_ref ) ));
}
impl Clone for AVFrame {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn av_frame_get_best_effort_timestamp(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_duration(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_pos(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channel_layout(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channels(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_channels(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_sample_rate(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_metadata(frame: *const AVFrame) -> *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
}
extern "C" {
    pub fn av_frame_get_decode_error_flags(frame: *const AVFrame)
     -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame,
                                           val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_pkt_size(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn avpriv_frame_get_metadatap(frame: *mut AVFrame)
     -> *mut *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_get_qp_table(f: *mut AVFrame, stride: *mut libc::c_int,
                                 type_: *mut libc::c_int) -> *mut i8;
}
extern "C" {
    pub fn av_frame_set_qp_table(f: *mut AVFrame, buf: *mut AVBufferRef,
                                 stride: libc::c_int, type_: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_frame_get_colorspace(frame: *const AVFrame) -> AVColorSpace;
}
extern "C" {
    pub fn av_frame_set_colorspace(frame: *mut AVFrame, val: AVColorSpace);
}
extern "C" {
    pub fn av_frame_get_color_range(frame: *const AVFrame) -> AVColorRange;
}
extern "C" {
    pub fn av_frame_set_color_range(frame: *mut AVFrame, val: AVColorRange);
}
extern "C" {
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const libc::c_char;
}
extern "C" {
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame)
     -> libc::c_int;
}
extern "C" {
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    pub fn av_frame_get_buffer(frame: *mut AVFrame, align: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame)
     -> libc::c_int;
}
extern "C" {
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame)
     -> libc::c_int;
}
extern "C" {
    pub fn av_frame_get_plane_buffer(frame: *mut AVFrame, plane: libc::c_int)
     -> *mut AVBufferRef;
}
extern "C" {
    pub fn av_frame_new_side_data(frame: *mut AVFrame,
                                  type_: AVFrameSideDataType,
                                  size: libc::c_int) -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_get_side_data(frame: *const AVFrame,
                                  type_: AVFrameSideDataType)
     -> *mut AVFrameSideData;
}
extern "C" {
    pub fn av_frame_remove_side_data(frame: *mut AVFrame,
                                     type_: AVFrameSideDataType);
}
extern "C" {
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType)
     -> *const libc::c_char;
}
pub const AV_CODEC_ID_PCM_S16LE: AVCodecID =
    AVCodecID::AV_CODEC_ID_FIRST_AUDIO;
pub const AV_CODEC_ID_VIMA: AVCodecID = AVCodecID::AV_CODEC_ID_ADPCM_VIMA;
pub const AV_CODEC_ID_DVD_SUBTITLE: AVCodecID =
    AVCodecID::AV_CODEC_ID_FIRST_SUBTITLE;
pub const AV_CODEC_ID_TTF: AVCodecID = AVCodecID::AV_CODEC_ID_FIRST_UNKNOWN;
#[repr(u32)]
/**
 * Identify the syntax and semantics of the bitstream.
 * The principle is roughly:
 * Two decoders with the same ID can decode the same streams.
 * Two encoders with the same ID can encode compatible streams.
 * There may be slight deviations from the principle due to implementation
 * details.
 *
 * If you add a codec ID to this list, add it so that
 * 1. no value of an existing codec ID changes (that would break ABI),
 * 2. it is as close as possible to similar codecs
 *
 * After adding new codec IDs, do not forget to add an entry to the codec
 * descriptor list and bump libavcodec minor version.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVCodecID {
    AV_CODEC_ID_NONE = 0,
    AV_CODEC_ID_MPEG1VIDEO = 1,
    AV_CODEC_ID_MPEG2VIDEO = 2,
    AV_CODEC_ID_MPEG2VIDEO_XVMC = 3,
    AV_CODEC_ID_H261 = 4,
    AV_CODEC_ID_H263 = 5,
    AV_CODEC_ID_RV10 = 6,
    AV_CODEC_ID_RV20 = 7,
    AV_CODEC_ID_MJPEG = 8,
    AV_CODEC_ID_MJPEGB = 9,
    AV_CODEC_ID_LJPEG = 10,
    AV_CODEC_ID_SP5X = 11,
    AV_CODEC_ID_JPEGLS = 12,
    AV_CODEC_ID_MPEG4 = 13,
    AV_CODEC_ID_RAWVIDEO = 14,
    AV_CODEC_ID_MSMPEG4V1 = 15,
    AV_CODEC_ID_MSMPEG4V2 = 16,
    AV_CODEC_ID_MSMPEG4V3 = 17,
    AV_CODEC_ID_WMV1 = 18,
    AV_CODEC_ID_WMV2 = 19,
    AV_CODEC_ID_H263P = 20,
    AV_CODEC_ID_H263I = 21,
    AV_CODEC_ID_FLV1 = 22,
    AV_CODEC_ID_SVQ1 = 23,
    AV_CODEC_ID_SVQ3 = 24,
    AV_CODEC_ID_DVVIDEO = 25,
    AV_CODEC_ID_HUFFYUV = 26,
    AV_CODEC_ID_CYUV = 27,
    AV_CODEC_ID_H264 = 28,
    AV_CODEC_ID_INDEO3 = 29,
    AV_CODEC_ID_VP3 = 30,
    AV_CODEC_ID_THEORA = 31,
    AV_CODEC_ID_ASV1 = 32,
    AV_CODEC_ID_ASV2 = 33,
    AV_CODEC_ID_FFV1 = 34,
    AV_CODEC_ID_4XM = 35,
    AV_CODEC_ID_VCR1 = 36,
    AV_CODEC_ID_CLJR = 37,
    AV_CODEC_ID_MDEC = 38,
    AV_CODEC_ID_ROQ = 39,
    AV_CODEC_ID_INTERPLAY_VIDEO = 40,
    AV_CODEC_ID_XAN_WC3 = 41,
    AV_CODEC_ID_XAN_WC4 = 42,
    AV_CODEC_ID_RPZA = 43,
    AV_CODEC_ID_CINEPAK = 44,
    AV_CODEC_ID_WS_VQA = 45,
    AV_CODEC_ID_MSRLE = 46,
    AV_CODEC_ID_MSVIDEO1 = 47,
    AV_CODEC_ID_IDCIN = 48,
    AV_CODEC_ID_8BPS = 49,
    AV_CODEC_ID_SMC = 50,
    AV_CODEC_ID_FLIC = 51,
    AV_CODEC_ID_TRUEMOTION1 = 52,
    AV_CODEC_ID_VMDVIDEO = 53,
    AV_CODEC_ID_MSZH = 54,
    AV_CODEC_ID_ZLIB = 55,
    AV_CODEC_ID_QTRLE = 56,
    AV_CODEC_ID_TSCC = 57,
    AV_CODEC_ID_ULTI = 58,
    AV_CODEC_ID_QDRAW = 59,
    AV_CODEC_ID_VIXL = 60,
    AV_CODEC_ID_QPEG = 61,
    AV_CODEC_ID_PNG = 62,
    AV_CODEC_ID_PPM = 63,
    AV_CODEC_ID_PBM = 64,
    AV_CODEC_ID_PGM = 65,
    AV_CODEC_ID_PGMYUV = 66,
    AV_CODEC_ID_PAM = 67,
    AV_CODEC_ID_FFVHUFF = 68,
    AV_CODEC_ID_RV30 = 69,
    AV_CODEC_ID_RV40 = 70,
    AV_CODEC_ID_VC1 = 71,
    AV_CODEC_ID_WMV3 = 72,
    AV_CODEC_ID_LOCO = 73,
    AV_CODEC_ID_WNV1 = 74,
    AV_CODEC_ID_AASC = 75,
    AV_CODEC_ID_INDEO2 = 76,
    AV_CODEC_ID_FRAPS = 77,
    AV_CODEC_ID_TRUEMOTION2 = 78,
    AV_CODEC_ID_BMP = 79,
    AV_CODEC_ID_CSCD = 80,
    AV_CODEC_ID_MMVIDEO = 81,
    AV_CODEC_ID_ZMBV = 82,
    AV_CODEC_ID_AVS = 83,
    AV_CODEC_ID_SMACKVIDEO = 84,
    AV_CODEC_ID_NUV = 85,
    AV_CODEC_ID_KMVC = 86,
    AV_CODEC_ID_FLASHSV = 87,
    AV_CODEC_ID_CAVS = 88,
    AV_CODEC_ID_JPEG2000 = 89,
    AV_CODEC_ID_VMNC = 90,
    AV_CODEC_ID_VP5 = 91,
    AV_CODEC_ID_VP6 = 92,
    AV_CODEC_ID_VP6F = 93,
    AV_CODEC_ID_TARGA = 94,
    AV_CODEC_ID_DSICINVIDEO = 95,
    AV_CODEC_ID_TIERTEXSEQVIDEO = 96,
    AV_CODEC_ID_TIFF = 97,
    AV_CODEC_ID_GIF = 98,
    AV_CODEC_ID_DXA = 99,
    AV_CODEC_ID_DNXHD = 100,
    AV_CODEC_ID_THP = 101,
    AV_CODEC_ID_SGI = 102,
    AV_CODEC_ID_C93 = 103,
    AV_CODEC_ID_BETHSOFTVID = 104,
    AV_CODEC_ID_PTX = 105,
    AV_CODEC_ID_TXD = 106,
    AV_CODEC_ID_VP6A = 107,
    AV_CODEC_ID_AMV = 108,
    AV_CODEC_ID_VB = 109,
    AV_CODEC_ID_PCX = 110,
    AV_CODEC_ID_SUNRAST = 111,
    AV_CODEC_ID_INDEO4 = 112,
    AV_CODEC_ID_INDEO5 = 113,
    AV_CODEC_ID_MIMIC = 114,
    AV_CODEC_ID_RL2 = 115,
    AV_CODEC_ID_ESCAPE124 = 116,
    AV_CODEC_ID_DIRAC = 117,
    AV_CODEC_ID_BFI = 118,
    AV_CODEC_ID_CMV = 119,
    AV_CODEC_ID_MOTIONPIXELS = 120,
    AV_CODEC_ID_TGV = 121,
    AV_CODEC_ID_TGQ = 122,
    AV_CODEC_ID_TQI = 123,
    AV_CODEC_ID_AURA = 124,
    AV_CODEC_ID_AURA2 = 125,
    AV_CODEC_ID_V210X = 126,
    AV_CODEC_ID_TMV = 127,
    AV_CODEC_ID_V210 = 128,
    AV_CODEC_ID_DPX = 129,
    AV_CODEC_ID_MAD = 130,
    AV_CODEC_ID_FRWU = 131,
    AV_CODEC_ID_FLASHSV2 = 132,
    AV_CODEC_ID_CDGRAPHICS = 133,
    AV_CODEC_ID_R210 = 134,
    AV_CODEC_ID_ANM = 135,
    AV_CODEC_ID_BINKVIDEO = 136,
    AV_CODEC_ID_IFF_ILBM = 137,
    AV_CODEC_ID_KGV1 = 138,
    AV_CODEC_ID_YOP = 139,
    AV_CODEC_ID_VP8 = 140,
    AV_CODEC_ID_PICTOR = 141,
    AV_CODEC_ID_ANSI = 142,
    AV_CODEC_ID_A64_MULTI = 143,
    AV_CODEC_ID_A64_MULTI5 = 144,
    AV_CODEC_ID_R10K = 145,
    AV_CODEC_ID_MXPEG = 146,
    AV_CODEC_ID_LAGARITH = 147,
    AV_CODEC_ID_PRORES = 148,
    AV_CODEC_ID_JV = 149,
    AV_CODEC_ID_DFA = 150,
    AV_CODEC_ID_WMV3IMAGE = 151,
    AV_CODEC_ID_VC1IMAGE = 152,
    AV_CODEC_ID_UTVIDEO = 153,
    AV_CODEC_ID_BMV_VIDEO = 154,
    AV_CODEC_ID_VBLE = 155,
    AV_CODEC_ID_DXTORY = 156,
    AV_CODEC_ID_V410 = 157,
    AV_CODEC_ID_XWD = 158,
    AV_CODEC_ID_CDXL = 159,
    AV_CODEC_ID_XBM = 160,
    AV_CODEC_ID_ZEROCODEC = 161,
    AV_CODEC_ID_MSS1 = 162,
    AV_CODEC_ID_MSA1 = 163,
    AV_CODEC_ID_TSCC2 = 164,
    AV_CODEC_ID_MTS2 = 165,
    AV_CODEC_ID_CLLC = 166,
    AV_CODEC_ID_MSS2 = 167,
    AV_CODEC_ID_VP9 = 168,
    AV_CODEC_ID_AIC = 169,
    AV_CODEC_ID_ESCAPE130 = 170,
    AV_CODEC_ID_G2M = 171,
    AV_CODEC_ID_WEBP = 172,
    AV_CODEC_ID_HNM4_VIDEO = 173,
    AV_CODEC_ID_HEVC = 174,
    AV_CODEC_ID_FIC = 175,
    AV_CODEC_ID_ALIAS_PIX = 176,
    AV_CODEC_ID_BRENDER_PIX = 177,
    AV_CODEC_ID_PAF_VIDEO = 178,
    AV_CODEC_ID_EXR = 179,
    AV_CODEC_ID_VP7 = 180,
    AV_CODEC_ID_SANM = 181,
    AV_CODEC_ID_SGIRLE = 182,
    AV_CODEC_ID_MVC1 = 183,
    AV_CODEC_ID_MVC2 = 184,
    AV_CODEC_ID_HQX = 185,
    AV_CODEC_ID_TDSC = 186,
    AV_CODEC_ID_HQ_HQA = 187,
    AV_CODEC_ID_HAP = 188,
    AV_CODEC_ID_DDS = 189,
    AV_CODEC_ID_DXV = 190,
    AV_CODEC_ID_SCREENPRESSO = 191,
    AV_CODEC_ID_RSCC = 192,
    AV_CODEC_ID_Y41P = 32768,
    AV_CODEC_ID_AVRP = 32769,
    AV_CODEC_ID_012V = 32770,
    AV_CODEC_ID_AVUI = 32771,
    AV_CODEC_ID_AYUV = 32772,
    AV_CODEC_ID_TARGA_Y216 = 32773,
    AV_CODEC_ID_V308 = 32774,
    AV_CODEC_ID_V408 = 32775,
    AV_CODEC_ID_YUV4 = 32776,
    AV_CODEC_ID_AVRN = 32777,
    AV_CODEC_ID_CPIA = 32778,
    AV_CODEC_ID_XFACE = 32779,
    AV_CODEC_ID_SNOW = 32780,
    AV_CODEC_ID_SMVJPEG = 32781,
    AV_CODEC_ID_APNG = 32782,
    AV_CODEC_ID_DAALA = 32783,
    AV_CODEC_ID_CFHD = 32784,
    AV_CODEC_ID_TRUEMOTION2RT = 32785,
    AV_CODEC_ID_M101 = 32786,
    AV_CODEC_ID_MAGICYUV = 32787,
    AV_CODEC_ID_SHEERVIDEO = 32788,
    AV_CODEC_ID_YLC = 32789,
    AV_CODEC_ID_PSD = 32790,
    AV_CODEC_ID_PIXLET = 32791,
    AV_CODEC_ID_SPEEDHQ = 32792,
    AV_CODEC_ID_FMVC = 32793,
    AV_CODEC_ID_SCPR = 32794,
    AV_CODEC_ID_CLEARVIDEO = 32795,
    AV_CODEC_ID_XPM = 32796,
    AV_CODEC_ID_AV1 = 32797,
    AV_CODEC_ID_FIRST_AUDIO = 65536,
    AV_CODEC_ID_PCM_S16BE = 65537,
    AV_CODEC_ID_PCM_U16LE = 65538,
    AV_CODEC_ID_PCM_U16BE = 65539,
    AV_CODEC_ID_PCM_S8 = 65540,
    AV_CODEC_ID_PCM_U8 = 65541,
    AV_CODEC_ID_PCM_MULAW = 65542,
    AV_CODEC_ID_PCM_ALAW = 65543,
    AV_CODEC_ID_PCM_S32LE = 65544,
    AV_CODEC_ID_PCM_S32BE = 65545,
    AV_CODEC_ID_PCM_U32LE = 65546,
    AV_CODEC_ID_PCM_U32BE = 65547,
    AV_CODEC_ID_PCM_S24LE = 65548,
    AV_CODEC_ID_PCM_S24BE = 65549,
    AV_CODEC_ID_PCM_U24LE = 65550,
    AV_CODEC_ID_PCM_U24BE = 65551,
    AV_CODEC_ID_PCM_S24DAUD = 65552,
    AV_CODEC_ID_PCM_ZORK = 65553,
    AV_CODEC_ID_PCM_S16LE_PLANAR = 65554,
    AV_CODEC_ID_PCM_DVD = 65555,
    AV_CODEC_ID_PCM_F32BE = 65556,
    AV_CODEC_ID_PCM_F32LE = 65557,
    AV_CODEC_ID_PCM_F64BE = 65558,
    AV_CODEC_ID_PCM_F64LE = 65559,
    AV_CODEC_ID_PCM_BLURAY = 65560,
    AV_CODEC_ID_PCM_LXF = 65561,
    AV_CODEC_ID_S302M = 65562,
    AV_CODEC_ID_PCM_S8_PLANAR = 65563,
    AV_CODEC_ID_PCM_S24LE_PLANAR = 65564,
    AV_CODEC_ID_PCM_S32LE_PLANAR = 65565,
    AV_CODEC_ID_PCM_S16BE_PLANAR = 65566,
    AV_CODEC_ID_PCM_S64LE = 67584,
    AV_CODEC_ID_PCM_S64BE = 67585,
    AV_CODEC_ID_PCM_F16LE = 67586,
    AV_CODEC_ID_PCM_F24LE = 67587,
    AV_CODEC_ID_ADPCM_IMA_QT = 69632,
    AV_CODEC_ID_ADPCM_IMA_WAV = 69633,
    AV_CODEC_ID_ADPCM_IMA_DK3 = 69634,
    AV_CODEC_ID_ADPCM_IMA_DK4 = 69635,
    AV_CODEC_ID_ADPCM_IMA_WS = 69636,
    AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
    AV_CODEC_ID_ADPCM_MS = 69638,
    AV_CODEC_ID_ADPCM_4XM = 69639,
    AV_CODEC_ID_ADPCM_XA = 69640,
    AV_CODEC_ID_ADPCM_ADX = 69641,
    AV_CODEC_ID_ADPCM_EA = 69642,
    AV_CODEC_ID_ADPCM_G726 = 69643,
    AV_CODEC_ID_ADPCM_CT = 69644,
    AV_CODEC_ID_ADPCM_SWF = 69645,
    AV_CODEC_ID_ADPCM_YAMAHA = 69646,
    AV_CODEC_ID_ADPCM_SBPRO_4 = 69647,
    AV_CODEC_ID_ADPCM_SBPRO_3 = 69648,
    AV_CODEC_ID_ADPCM_SBPRO_2 = 69649,
    AV_CODEC_ID_ADPCM_THP = 69650,
    AV_CODEC_ID_ADPCM_IMA_AMV = 69651,
    AV_CODEC_ID_ADPCM_EA_R1 = 69652,
    AV_CODEC_ID_ADPCM_EA_R3 = 69653,
    AV_CODEC_ID_ADPCM_EA_R2 = 69654,
    AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
    AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
    AV_CODEC_ID_ADPCM_EA_XAS = 69657,
    AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
    AV_CODEC_ID_ADPCM_IMA_ISS = 69659,
    AV_CODEC_ID_ADPCM_G722 = 69660,
    AV_CODEC_ID_ADPCM_IMA_APC = 69661,
    AV_CODEC_ID_ADPCM_VIMA = 69662,
    AV_CODEC_ID_ADPCM_AFC = 71680,
    AV_CODEC_ID_ADPCM_IMA_OKI = 71681,
    AV_CODEC_ID_ADPCM_DTK = 71682,
    AV_CODEC_ID_ADPCM_IMA_RAD = 71683,
    AV_CODEC_ID_ADPCM_G726LE = 71684,
    AV_CODEC_ID_ADPCM_THP_LE = 71685,
    AV_CODEC_ID_ADPCM_PSX = 71686,
    AV_CODEC_ID_ADPCM_AICA = 71687,
    AV_CODEC_ID_ADPCM_IMA_DAT4 = 71688,
    AV_CODEC_ID_ADPCM_MTAF = 71689,
    AV_CODEC_ID_AMR_NB = 73728,
    AV_CODEC_ID_AMR_WB = 73729,
    AV_CODEC_ID_RA_144 = 77824,
    AV_CODEC_ID_RA_288 = 77825,
    AV_CODEC_ID_ROQ_DPCM = 81920,
    AV_CODEC_ID_INTERPLAY_DPCM = 81921,
    AV_CODEC_ID_XAN_DPCM = 81922,
    AV_CODEC_ID_SOL_DPCM = 81923,
    AV_CODEC_ID_SDX2_DPCM = 83968,
    AV_CODEC_ID_MP2 = 86016,
    AV_CODEC_ID_MP3 = 86017,
    AV_CODEC_ID_AAC = 86018,
    AV_CODEC_ID_AC3 = 86019,
    AV_CODEC_ID_DTS = 86020,
    AV_CODEC_ID_VORBIS = 86021,
    AV_CODEC_ID_DVAUDIO = 86022,
    AV_CODEC_ID_WMAV1 = 86023,
    AV_CODEC_ID_WMAV2 = 86024,
    AV_CODEC_ID_MACE3 = 86025,
    AV_CODEC_ID_MACE6 = 86026,
    AV_CODEC_ID_VMDAUDIO = 86027,
    AV_CODEC_ID_FLAC = 86028,
    AV_CODEC_ID_MP3ADU = 86029,
    AV_CODEC_ID_MP3ON4 = 86030,
    AV_CODEC_ID_SHORTEN = 86031,
    AV_CODEC_ID_ALAC = 86032,
    AV_CODEC_ID_WESTWOOD_SND1 = 86033,
    AV_CODEC_ID_GSM = 86034,
    AV_CODEC_ID_QDM2 = 86035,
    AV_CODEC_ID_COOK = 86036,
    AV_CODEC_ID_TRUESPEECH = 86037,
    AV_CODEC_ID_TTA = 86038,
    AV_CODEC_ID_SMACKAUDIO = 86039,
    AV_CODEC_ID_QCELP = 86040,
    AV_CODEC_ID_WAVPACK = 86041,
    AV_CODEC_ID_DSICINAUDIO = 86042,
    AV_CODEC_ID_IMC = 86043,
    AV_CODEC_ID_MUSEPACK7 = 86044,
    AV_CODEC_ID_MLP = 86045,
    AV_CODEC_ID_GSM_MS = 86046,
    AV_CODEC_ID_ATRAC3 = 86047,
    AV_CODEC_ID_VOXWARE = 86048,
    AV_CODEC_ID_APE = 86049,
    AV_CODEC_ID_NELLYMOSER = 86050,
    AV_CODEC_ID_MUSEPACK8 = 86051,
    AV_CODEC_ID_SPEEX = 86052,
    AV_CODEC_ID_WMAVOICE = 86053,
    AV_CODEC_ID_WMAPRO = 86054,
    AV_CODEC_ID_WMALOSSLESS = 86055,
    AV_CODEC_ID_ATRAC3P = 86056,
    AV_CODEC_ID_EAC3 = 86057,
    AV_CODEC_ID_SIPR = 86058,
    AV_CODEC_ID_MP1 = 86059,
    AV_CODEC_ID_TWINVQ = 86060,
    AV_CODEC_ID_TRUEHD = 86061,
    AV_CODEC_ID_MP4ALS = 86062,
    AV_CODEC_ID_ATRAC1 = 86063,
    AV_CODEC_ID_BINKAUDIO_RDFT = 86064,
    AV_CODEC_ID_BINKAUDIO_DCT = 86065,
    AV_CODEC_ID_AAC_LATM = 86066,
    AV_CODEC_ID_QDMC = 86067,
    AV_CODEC_ID_CELT = 86068,
    AV_CODEC_ID_G723_1 = 86069,
    AV_CODEC_ID_G729 = 86070,
    AV_CODEC_ID_8SVX_EXP = 86071,
    AV_CODEC_ID_8SVX_FIB = 86072,
    AV_CODEC_ID_BMV_AUDIO = 86073,
    AV_CODEC_ID_RALF = 86074,
    AV_CODEC_ID_IAC = 86075,
    AV_CODEC_ID_ILBC = 86076,
    AV_CODEC_ID_OPUS = 86077,
    AV_CODEC_ID_COMFORT_NOISE = 86078,
    AV_CODEC_ID_TAK = 86079,
    AV_CODEC_ID_METASOUND = 86080,
    AV_CODEC_ID_PAF_AUDIO = 86081,
    AV_CODEC_ID_ON2AVC = 86082,
    AV_CODEC_ID_DSS_SP = 86083,
    AV_CODEC_ID_FFWAVESYNTH = 88064,
    AV_CODEC_ID_SONIC = 88065,
    AV_CODEC_ID_SONIC_LS = 88066,
    AV_CODEC_ID_EVRC = 88067,
    AV_CODEC_ID_SMV = 88068,
    AV_CODEC_ID_DSD_LSBF = 88069,
    AV_CODEC_ID_DSD_MSBF = 88070,
    AV_CODEC_ID_DSD_LSBF_PLANAR = 88071,
    AV_CODEC_ID_DSD_MSBF_PLANAR = 88072,
    AV_CODEC_ID_4GV = 88073,
    AV_CODEC_ID_INTERPLAY_ACM = 88074,
    AV_CODEC_ID_XMA1 = 88075,
    AV_CODEC_ID_XMA2 = 88076,
    AV_CODEC_ID_DST = 88077,
    AV_CODEC_ID_ATRAC3AL = 88078,
    AV_CODEC_ID_ATRAC3PAL = 88079,
    AV_CODEC_ID_FIRST_SUBTITLE = 94208,
    AV_CODEC_ID_DVB_SUBTITLE = 94209,
    AV_CODEC_ID_TEXT = 94210,
    AV_CODEC_ID_XSUB = 94211,
    AV_CODEC_ID_SSA = 94212,
    AV_CODEC_ID_MOV_TEXT = 94213,
    AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
    AV_CODEC_ID_DVB_TELETEXT = 94215,
    AV_CODEC_ID_SRT = 94216,
    AV_CODEC_ID_MICRODVD = 96256,
    AV_CODEC_ID_EIA_608 = 96257,
    AV_CODEC_ID_JACOSUB = 96258,
    AV_CODEC_ID_SAMI = 96259,
    AV_CODEC_ID_REALTEXT = 96260,
    AV_CODEC_ID_STL = 96261,
    AV_CODEC_ID_SUBVIEWER1 = 96262,
    AV_CODEC_ID_SUBVIEWER = 96263,
    AV_CODEC_ID_SUBRIP = 96264,
    AV_CODEC_ID_WEBVTT = 96265,
    AV_CODEC_ID_MPL2 = 96266,
    AV_CODEC_ID_VPLAYER = 96267,
    AV_CODEC_ID_PJS = 96268,
    AV_CODEC_ID_ASS = 96269,
    AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 96270,
    AV_CODEC_ID_FIRST_UNKNOWN = 98304,
    AV_CODEC_ID_SCTE_35 = 98305,
    AV_CODEC_ID_BINTEXT = 100352,
    AV_CODEC_ID_XBIN = 100353,
    AV_CODEC_ID_IDF = 100354,
    AV_CODEC_ID_OTF = 100355,
    AV_CODEC_ID_SMPTE_KLV = 100356,
    AV_CODEC_ID_DVD_NAV = 100357,
    AV_CODEC_ID_TIMED_ID3 = 100358,
    AV_CODEC_ID_BIN_DATA = 100359,
    AV_CODEC_ID_PROBE = 102400,
    AV_CODEC_ID_MPEG2TS = 131072,
    AV_CODEC_ID_MPEG4SYSTEMS = 131073,
    AV_CODEC_ID_FFMETADATA = 135168,
    AV_CODEC_ID_WRAPPED_AVFRAME = 135169,
}
/**
 * This struct describes the properties of a single codec described by an
 * AVCodecID.
 * @see avcodec_descriptor_get()
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    /**
     * Name of the codec described by this descriptor. It is non-empty and
     * unique for each codec descriptor. It should contain alphanumeric
     * characters and '_' only.
     */
    pub name: *const libc::c_char,
    /**
     * A more descriptive name for this codec. May be NULL.
     */
    pub long_name: *const libc::c_char,
    /**
     * Codec properties, a combination of AV_CODEC_PROP_* flags.
     */
    pub props: libc::c_int,
    /**
     * MIME type(s) associated with the codec.
     * May be NULL; if not, a NULL-terminated array of MIME types.
     * The first item is always non-NULL and is the preferred MIME type.
     */
    pub mime_types: *const *const libc::c_char,
    /**
     * If non-NULL, an array of profiles recognized for this codec.
     * Terminated with FF_PROFILE_UNKNOWN.
     */
    pub profiles: *const AVProfile,
}
#[test]
fn bindgen_test_layout_AVCodecDescriptor() {
    assert_eq!(::std::mem::size_of::<AVCodecDescriptor>() , 48usize , concat !
               ( "Size of: " , stringify ! ( AVCodecDescriptor ) ));
    assert_eq! (::std::mem::align_of::<AVCodecDescriptor>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AVCodecDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecDescriptor ) ) . id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecDescriptor ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecDescriptor ) ) . type_ as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecDescriptor ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecDescriptor ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecDescriptor ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecDescriptor ) ) . long_name as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecDescriptor ) ,
                "::" , stringify ! ( long_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecDescriptor ) ) . props as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecDescriptor ) ,
                "::" , stringify ! ( props ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecDescriptor ) ) . mime_types as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecDescriptor ) ,
                "::" , stringify ! ( mime_types ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecDescriptor ) ) . profiles as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecDescriptor ) ,
                "::" , stringify ! ( profiles ) ));
}
impl Clone for AVCodecDescriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Motion_Est_ID {
    ME_ZERO = 1,
    ME_FULL = 2,
    ME_LOG = 3,
    ME_PHODS = 4,
    ME_EPZS = 5,
    ME_X1 = 6,
    ME_HEX = 7,
    ME_UMH = 8,
    ME_TESA = 9,
    ME_ITER = 50,
}
#[repr(i32)]
/**
 * @ingroup lavc_decoding
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVDiscard {
    AVDISCARD_NONE = -16,
    AVDISCARD_DEFAULT = 0,
    AVDISCARD_NONREF = 8,
    AVDISCARD_BIDIR = 16,
    AVDISCARD_NONINTRA = 24,
    AVDISCARD_NONKEY = 32,
    AVDISCARD_ALL = 48,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVAudioServiceType {
    AV_AUDIO_SERVICE_TYPE_MAIN = 0,
    AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
    AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
    AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
    AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
    AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
    AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
    AV_AUDIO_SERVICE_TYPE_NB = 9,
}
/**
 * @ingroup lavc_encoding
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RcOverride {
    pub start_frame: libc::c_int,
    pub end_frame: libc::c_int,
    pub qscale: libc::c_int,
    pub quality_factor: f32,
}
#[test]
fn bindgen_test_layout_RcOverride() {
    assert_eq!(::std::mem::size_of::<RcOverride>() , 16usize , concat ! (
               "Size of: " , stringify ! ( RcOverride ) ));
    assert_eq! (::std::mem::align_of::<RcOverride>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( RcOverride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RcOverride ) ) . start_frame as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RcOverride ) , "::" ,
                stringify ! ( start_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RcOverride ) ) . end_frame as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RcOverride ) , "::" ,
                stringify ! ( end_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RcOverride ) ) . qscale as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RcOverride ) , "::" ,
                stringify ! ( qscale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RcOverride ) ) . quality_factor as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RcOverride ) , "::" ,
                stringify ! ( quality_factor ) ));
}
impl Clone for RcOverride {
    fn clone(&self) -> Self { *self }
}
/**
 * Pan Scan area.
 * This specifies the area which should be displayed.
 * Note there may be multiple such areas for one frame.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVPanScan {
    /**
     * id
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    pub id: libc::c_int,
    /**
     * width and height in 1/16 pel
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    pub width: libc::c_int,
    pub height: libc::c_int,
    /**
     * position of the top left corner in 1/16 pel for up to 3 fields/frames
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    pub position: [[i16; 2usize]; 3usize],
}
#[test]
fn bindgen_test_layout_AVPanScan() {
    assert_eq!(::std::mem::size_of::<AVPanScan>() , 24usize , concat ! (
               "Size of: " , stringify ! ( AVPanScan ) ));
    assert_eq! (::std::mem::align_of::<AVPanScan>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( AVPanScan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPanScan ) ) . id as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPanScan ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPanScan ) ) . width as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPanScan ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPanScan ) ) . height as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPanScan ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPanScan ) ) . position as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPanScan ) , "::" ,
                stringify ! ( position ) ));
}
impl Clone for AVPanScan {
    fn clone(&self) -> Self { *self }
}
/**
 * This structure describes the bitrate properties of an encoded bitstream. It
 * roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
 * parameters for H.264/HEVC.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVCPBProperties {
    /**
     * Maximum bitrate of the stream, in bits per second.
     * Zero if unknown or unspecified.
     */
    pub max_bitrate: libc::c_int,
    /**
     * Minimum bitrate of the stream, in bits per second.
     * Zero if unknown or unspecified.
     */
    pub min_bitrate: libc::c_int,
    /**
     * Average bitrate of the stream, in bits per second.
     * Zero if unknown or unspecified.
     */
    pub avg_bitrate: libc::c_int,
    /**
     * The size of the buffer to which the ratecontrol is applied, in bits.
     * Zero if unknown or unspecified.
     */
    pub buffer_size: libc::c_int,
    /**
     * The delay between the time the packet this structure is associated with
     * is received and the time when it should be decoded, in periods of a 27MHz
     * clock.
     *
     * UINT64_MAX when unknown or unspecified.
     */
    pub vbv_delay: u64,
}
#[test]
fn bindgen_test_layout_AVCPBProperties() {
    assert_eq!(::std::mem::size_of::<AVCPBProperties>() , 24usize , concat ! (
               "Size of: " , stringify ! ( AVCPBProperties ) ));
    assert_eq! (::std::mem::align_of::<AVCPBProperties>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AVCPBProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCPBProperties ) ) . max_bitrate as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCPBProperties ) ,
                "::" , stringify ! ( max_bitrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCPBProperties ) ) . min_bitrate as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCPBProperties ) ,
                "::" , stringify ! ( min_bitrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCPBProperties ) ) . avg_bitrate as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCPBProperties ) ,
                "::" , stringify ! ( avg_bitrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCPBProperties ) ) . buffer_size as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCPBProperties ) ,
                "::" , stringify ! ( buffer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCPBProperties ) ) . vbv_delay as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCPBProperties ) ,
                "::" , stringify ! ( vbv_delay ) ));
}
impl Clone for AVCPBProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * @defgroup lavc_packet AVPacket
 *
 * Types and functions for working with AVPacket.
 * @{
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVPacketSideDataType {
    AV_PKT_DATA_PALETTE = 0,
    AV_PKT_DATA_NEW_EXTRADATA = 1,
    AV_PKT_DATA_PARAM_CHANGE = 2,
    AV_PKT_DATA_H263_MB_INFO = 3,
    AV_PKT_DATA_REPLAYGAIN = 4,
    AV_PKT_DATA_DISPLAYMATRIX = 5,
    AV_PKT_DATA_STEREO3D = 6,
    AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7,
    AV_PKT_DATA_QUALITY_STATS = 8,
    AV_PKT_DATA_FALLBACK_TRACK = 9,
    AV_PKT_DATA_CPB_PROPERTIES = 10,
    AV_PKT_DATA_SKIP_SAMPLES = 70,
    AV_PKT_DATA_JP_DUALMONO = 71,
    AV_PKT_DATA_STRINGS_METADATA = 72,
    AV_PKT_DATA_SUBTITLE_POSITION = 73,
    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 74,
    AV_PKT_DATA_WEBVTT_IDENTIFIER = 75,
    AV_PKT_DATA_WEBVTT_SETTINGS = 76,
    AV_PKT_DATA_METADATA_UPDATE = 77,
    AV_PKT_DATA_MPEGTS_STREAM_ID = 78,
    AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 79,
    AV_PKT_DATA_SPHERICAL = 80,
    AV_PKT_DATA_NB = 81,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: libc::c_int,
    pub type_: AVPacketSideDataType,
}
#[test]
fn bindgen_test_layout_AVPacketSideData() {
    assert_eq!(::std::mem::size_of::<AVPacketSideData>() , 16usize , concat !
               ( "Size of: " , stringify ! ( AVPacketSideData ) ));
    assert_eq! (::std::mem::align_of::<AVPacketSideData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AVPacketSideData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacketSideData ) ) . data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacketSideData ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacketSideData ) ) . size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacketSideData ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacketSideData ) ) . type_ as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacketSideData ) ,
                "::" , stringify ! ( type_ ) ));
}
impl Clone for AVPacketSideData {
    fn clone(&self) -> Self { *self }
}
/**
 * This structure stores compressed data. It is typically exported by demuxers
 * and then passed as input to decoders, or received as output from encoders and
 * then passed to muxers.
 *
 * For video, it should typically contain one compressed frame. For audio it may
 * contain several compressed frames. Encoders are allowed to output empty
 * packets, with no compressed data, containing only side data
 * (e.g. to update some stream parameters at the end of encoding).
 *
 * AVPacket is one of the few structs in FFmpeg, whose size is a part of public
 * ABI. Thus it may be allocated on stack and no new fields can be added to it
 * without libavcodec and libavformat major bump.
 *
 * The semantics of data ownership depends on the buf field.
 * If it is set, the packet data is dynamically allocated and is
 * valid indefinitely until a call to av_packet_unref() reduces the
 * reference count to 0.
 *
 * If the buf field is not set av_packet_ref() would make a copy instead
 * of increasing the reference count.
 *
 * The side data is always allocated with av_malloc(), copied by
 * av_packet_ref() and freed by av_packet_unref().
 *
 * @see av_packet_ref
 * @see av_packet_unref
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVPacket {
    /**
     * A reference to the reference-counted buffer where the packet data is
     * stored.
     * May be NULL, then the packet data is not reference-counted.
     */
    pub buf: *mut AVBufferRef,
    /**
     * Presentation timestamp in AVStream->time_base units; the time at which
     * the decompressed packet will be presented to the user.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     * pts MUST be larger or equal to dts as presentation cannot happen before
     * decompression, unless one wants to view hex dumps. Some formats misuse
     * the terms dts and pts/cts to mean something different. Such timestamps
     * must be converted to true pts/dts before they are stored in AVPacket.
     */
    pub pts: i64,
    /**
     * Decompression timestamp in AVStream->time_base units; the time at which
     * the packet is decompressed.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     */
    pub dts: i64,
    pub data: *mut u8,
    pub size: libc::c_int,
    pub stream_index: libc::c_int,
    /**
     * A combination of AV_PKT_FLAG values
     */
    pub flags: libc::c_int,
    /**
     * Additional packet data that can be provided by the container.
     * Packet can contain several types of side information.
     */
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: libc::c_int,
    /**
     * Duration of this packet in AVStream->time_base units, 0 if unknown.
     * Equals next_pts - this_pts in presentation order.
     */
    pub duration: i64,
    ///< byte position in stream, -1 if unknown
    pub pos: i64,
    /**
     * @deprecated Same as the duration field, but as int64_t. This was required
     * for Matroska subtitles, whose duration values could overflow when the
     * duration field was still an int.
     */
    pub convergence_duration: i64,
}
#[test]
fn bindgen_test_layout_AVPacket() {
    assert_eq!(::std::mem::size_of::<AVPacket>() , 88usize , concat ! (
               "Size of: " , stringify ! ( AVPacket ) ));
    assert_eq! (::std::mem::align_of::<AVPacket>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVPacket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . buf as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . pts as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . dts as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . data as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . size as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . stream_index as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( stream_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . flags as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . side_data as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( side_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . side_data_elems as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( side_data_elems ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . duration as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . pos as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacket ) ) . convergence_duration as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacket ) , "::" ,
                stringify ! ( convergence_duration ) ));
}
impl Clone for AVPacket {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVSideDataParamChangeFlags {
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1,
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2,
    AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4,
    AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVFieldOrder {
    AV_FIELD_UNKNOWN = 0,
    AV_FIELD_PROGRESSIVE = 1,
    AV_FIELD_TT = 2,
    AV_FIELD_BB = 3,
    AV_FIELD_TB = 4,
    AV_FIELD_BT = 5,
}
/**
 * main external API structure.
 * New fields can be added to the end with minor version bumps.
 * Removal, reordering and changes to existing fields require a major
 * version bump.
 * You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user
 * applications.
 * The name string for AVOptions options matches the associated command line
 * parameter name and can be found in libavcodec/options_table.h
 * The AVOption/command line parameter names differ in some cases from the C
 * structure field names for historic reasons or brevity.
 * sizeof(AVCodecContext) must not be used outside libav*.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVCodecContext {
    /**
     * information on struct for av_log
     * - set by avcodec_alloc_context3
     */
    pub av_class: *const AVClass,
    pub log_level_offset: libc::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    /**
     * @deprecated this field is not used for anything in libavcodec
     */
    pub codec_name: [libc::c_char; 32usize],
    pub codec_id: AVCodecID,
    /**
     * fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
     * This is used to work around some encoder bugs.
     * A demuxer should set this to what is stored in the field used to identify the codec.
     * If there are multiple such fields in a container then the demuxer should choose the one
     * which maximizes the information about the used codec.
     * If the codec tag field in a container is larger than 32 bits then the demuxer should
     * remap the longer ID to 32 bits with a table or other structure. Alternatively a new
     * extra_codec_tag + size could be added but for this a clear advantage must be demonstrated
     * first.
     * - encoding: Set by user, if not then the default based on codec_id will be used.
     * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
     */
    pub codec_tag: libc::c_uint,
    /**
     * @deprecated this field is unused
     */
    pub stream_codec_tag: libc::c_uint,
    pub priv_data: *mut libc::c_void,
    /**
     * Private context used for internal data.
     *
     * Unlike priv_data, this is not codec-specific. It is used in general
     * libavcodec functions.
     */
    pub internal: *mut AVCodecInternal,
    /**
     * Private data of the user, can be used to carry app specific stuff.
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub opaque: *mut libc::c_void,
    /**
     * the average bitrate
     * - encoding: Set by user; unused for constant quantizer encoding.
     * - decoding: Set by user, may be overwritten by libavcodec
     *             if this info is available in the stream
     */
    pub bit_rate: i64,
    /**
     * number of bits the bitstream is allowed to diverge from the reference.
     *           the reference can be CBR (for CBR pass1) or VBR (for pass2)
     * - encoding: Set by user; unused for constant quantizer encoding.
     * - decoding: unused
     */
    pub bit_rate_tolerance: libc::c_int,
    /**
     * Global quality for codecs which cannot change it per frame.
     * This should be proportional to MPEG-1/2/4 qscale.
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub global_quality: libc::c_int,
    /**
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub compression_level: libc::c_int,
    /**
     * AV_CODEC_FLAG_*.
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub flags: libc::c_int,
    /**
     * AV_CODEC_FLAG2_*
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub flags2: libc::c_int,
    /**
     * some codecs need / can use extradata like Huffman tables.
     * MJPEG: Huffman tables
     * rv10: additional flags
     * MPEG-4: global headers (they can be in the bitstream or here)
     * The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger
     * than extradata_size to avoid problems if it is read with the bitstream reader.
     * The bytewise contents of extradata must not depend on the architecture or CPU endianness.
     * - encoding: Set/allocated/freed by libavcodec.
     * - decoding: Set/allocated/freed by user.
     */
    pub extradata: *mut u8,
    pub extradata_size: libc::c_int,
    /**
     * This is the fundamental unit of time (in seconds) in terms
     * of which frame timestamps are represented. For fixed-fps content,
     * timebase should be 1/framerate and timestamp increments should be
     * identically 1.
     * This often, but not always is the inverse of the frame rate or field rate
     * for video. 1/time_base is not the average frame rate if the frame rate is not
     * constant.
     *
     * Like containers, elementary streams also can store timestamps, 1/time_base
     * is the unit in which these timestamps are specified.
     * As example of such codec time base see ISO/IEC 14496-2:2001(E)
     * vop_time_increment_resolution and fixed_vop_rate
     * (fixed_vop_rate == 0 implies that it is different from the framerate)
     *
     * - encoding: MUST be set by user.
     * - decoding: the use of this field for decoding is deprecated.
     *             Use framerate instead.
     */
    pub time_base: AVRational,
    /**
     * For some codecs, the time base is closer to the field rate than the frame rate.
     * Most notably, H.264 and MPEG-2 specify time_base as half of frame duration
     * if no telecine is used ...
     *
     * Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
     */
    pub ticks_per_frame: libc::c_int,
    /**
     * Codec delay.
     *
     * Encoding: Number of frames delay there will be from the encoder input to
     *           the decoder output. (we assume the decoder matches the spec)
     * Decoding: Number of frames delay in addition to what a standard decoder
     *           as specified in the spec would produce.
     *
     * Video:
     *   Number of frames the decoded output will be delayed relative to the
     *   encoded input.
     *
     * Audio:
     *   For encoding, this field is unused (see initial_padding).
     *
     *   For decoding, this is the number of samples the decoder needs to
     *   output before the decoder's output is valid. When seeking, you should
     *   start decoding this many samples prior to your desired seek point.
     *
     * - encoding: Set by libavcodec.
     * - decoding: Set by libavcodec.
     */
    pub delay: libc::c_int,
    /**
     * picture width / height.
     *
     * @note Those fields may not match the values of the last
     * AVFrame output by avcodec_decode_video2 due frame
     * reordering.
     *
     * - encoding: MUST be set by user.
     * - decoding: May be set by the user before opening the decoder if known e.g.
     *             from the container. Some decoders will require the dimensions
     *             to be set by the caller. During decoding, the decoder may
     *             overwrite those values as required while parsing the data.
     */
    pub width: libc::c_int,
    /**
     * picture width / height.
     *
     * @note Those fields may not match the values of the last
     * AVFrame output by avcodec_decode_video2 due frame
     * reordering.
     *
     * - encoding: MUST be set by user.
     * - decoding: May be set by the user before opening the decoder if known e.g.
     *             from the container. Some decoders will require the dimensions
     *             to be set by the caller. During decoding, the decoder may
     *             overwrite those values as required while parsing the data.
     */
    pub height: libc::c_int,
    /**
     * Bitstream width / height, may be different from width/height e.g. when
     * the decoded frame is cropped before being output or lowres is enabled.
     *
     * @note Those field may not match the value of the last
     * AVFrame output by avcodec_receive_frame() due frame
     * reordering.
     *
     * - encoding: unused
     * - decoding: May be set by the user before opening the decoder if known
     *             e.g. from the container. During decoding, the decoder may
     *             overwrite those values as required while parsing the data.
     */
    pub coded_width: libc::c_int,
    /**
     * Bitstream width / height, may be different from width/height e.g. when
     * the decoded frame is cropped before being output or lowres is enabled.
     *
     * @note Those field may not match the value of the last
     * AVFrame output by avcodec_receive_frame() due frame
     * reordering.
     *
     * - encoding: unused
     * - decoding: May be set by the user before opening the decoder if known
     *             e.g. from the container. During decoding, the decoder may
     *             overwrite those values as required while parsing the data.
     */
    pub coded_height: libc::c_int,
    /**
     * the number of pictures in a group of pictures, or 0 for intra_only
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub gop_size: libc::c_int,
    /**
     * Pixel format, see AV_PIX_FMT_xxx.
     * May be set by the demuxer if known from headers.
     * May be overridden by the decoder if it knows better.
     *
     * @note This field may not match the value of the last
     * AVFrame output by avcodec_receive_frame() due frame
     * reordering.
     *
     * - encoding: Set by user.
     * - decoding: Set by user if known, overridden by libavcodec while
     *             parsing the data.
     */
    pub pix_fmt: AVPixelFormat,
    /**
     * This option does nothing
     * @deprecated use codec private options instead
     */
    pub me_method: libc::c_int,
    /**
     * If non NULL, 'draw_horiz_band' is called by the libavcodec
     * decoder to draw a horizontal band. It improves cache usage. Not
     * all codecs can do that. You must check the codec capabilities
     * beforehand.
     * When multithreading is used, it may be called from multiple threads
     * at the same time; threads might draw different parts of the same AVFrame,
     * or multiple AVFrames, and there is no guarantee that slices will be drawn
     * in order.
     * The function is also used by hardware acceleration APIs.
     * It is called at least once during frame decoding to pass
     * the data needed for hardware render.
     * In that mode instead of pixel data, AVFrame points to
     * a structure specific to the acceleration API. The application
     * reads the structure and can change some fields to indicate progress
     * or mark state.
     * - encoding: unused
     * - decoding: Set by user.
     * @param height the height of the slice
     * @param y the y position of the slice
     * @param type 1->top field, 2->bottom field, 3->frame
     * @param offset offset into the AVFrame.data from which the slice should be read
     */
    pub draw_horiz_band: ::std::option::Option<unsafe extern "C" fn(s:
                                                                        *mut AVCodecContext,
                                                                    src:
                                                                        *const AVFrame,
                                                                    offset:
                                                                        *mut libc::c_int,
                                                                    y:
                                                                        libc::c_int,
                                                                    type_:
                                                                        libc::c_int,
                                                                    height:
                                                                        libc::c_int)>,
    /**
     * callback to negotiate the pixelFormat
     * @param fmt is the list of formats which are supported by the codec,
     * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
     * The first is always the native one.
     * @note The callback may be called again immediately if initialization for
     * the selected (hardware-accelerated) pixel format failed.
     * @warning Behavior is undefined if the callback returns a value not
     * in the fmt list of formats.
     * @return the chosen format
     * - encoding: unused
     * - decoding: Set by user, if not set the native format will be chosen.
     */
    pub get_format: ::std::option::Option<unsafe extern "C" fn(s:
                                                                   *mut AVCodecContext,
                                                               fmt:
                                                                   *const AVPixelFormat)
                                              -> AVPixelFormat>,
    /**
     * maximum number of B-frames between non-B-frames
     * Note: The output will be delayed by max_b_frames+1 relative to the input.
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub max_b_frames: libc::c_int,
    /**
     * qscale factor between IP and B-frames
     * If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
     * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub b_quant_factor: f32,
    /** @deprecated use codec private option instead */
    pub rc_strategy: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub b_frame_strategy: libc::c_int,
    /**
     * qscale offset between IP and B-frames
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub b_quant_offset: f32,
    /**
     * Size of the frame reordering buffer in the decoder.
     * For MPEG-2 it is 1 IPB or 0 low delay IP.
     * - encoding: Set by libavcodec.
     * - decoding: Set by libavcodec.
     */
    pub has_b_frames: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub mpeg_quant: libc::c_int,
    /**
     * qscale factor between P- and I-frames
     * If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).
     * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub i_quant_factor: f32,
    /**
     * qscale offset between P and I-frames
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub i_quant_offset: f32,
    /**
     * luminance masking (0-> disabled)
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub lumi_masking: f32,
    /**
     * temporary complexity masking (0-> disabled)
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub temporal_cplx_masking: f32,
    /**
     * spatial complexity masking (0-> disabled)
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub spatial_cplx_masking: f32,
    /**
     * p block masking (0-> disabled)
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub p_masking: f32,
    /**
     * darkness masking (0-> disabled)
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub dark_masking: f32,
    /**
     * slice count
     * - encoding: Set by libavcodec.
     * - decoding: Set by user (or 0).
     */
    pub slice_count: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub prediction_method: libc::c_int,
    /**
     * slice offsets in the frame in bytes
     * - encoding: Set/allocated by libavcodec.
     * - decoding: Set/allocated by user (or NULL).
     */
    pub slice_offset: *mut libc::c_int,
    /**
     * sample aspect ratio (0 if unknown)
     * That is the width of a pixel divided by the height of the pixel.
     * Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    pub sample_aspect_ratio: AVRational,
    /**
     * motion estimation comparison function
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub me_cmp: libc::c_int,
    /**
     * subpixel motion estimation comparison function
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub me_sub_cmp: libc::c_int,
    /**
     * macroblock comparison function (not supported yet)
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub mb_cmp: libc::c_int,
    /**
     * interlaced DCT comparison function
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub ildct_cmp: libc::c_int,
    /**
     * ME diamond size & shape
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub dia_size: libc::c_int,
    /**
     * amount of previous MV predictors (2a+1 x 2a+1 square)
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub last_predictor_count: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub pre_me: libc::c_int,
    /**
     * motion estimation prepass comparison function
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub me_pre_cmp: libc::c_int,
    /**
     * ME prepass diamond size & shape
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub pre_dia_size: libc::c_int,
    /**
     * subpel ME quality
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub me_subpel_quality: libc::c_int,
    /**
     * DTG active format information (additional aspect ratio
     * information only used in DVB MPEG-2 transport streams)
     * 0 if not set.
     *
     * - encoding: unused
     * - decoding: Set by decoder.
     * @deprecated Deprecated in favor of AVSideData
     */
    pub dtg_active_format: libc::c_int,
    /**
     * maximum motion estimation search range in subpel units
     * If 0 then no limit.
     *
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub me_range: libc::c_int,
    /**
     * @deprecated use encoder private option instead
     */
    pub intra_quant_bias: libc::c_int,
    /**
     * @deprecated use encoder private option instead
     */
    pub inter_quant_bias: libc::c_int,
    /**
     * slice flags
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub slice_flags: libc::c_int,
    /**
     * XVideo Motion Acceleration
     * - encoding: forbidden
     * - decoding: set by decoder
     * @deprecated XvMC doesn't need it anymore.
     */
    pub xvmc_acceleration: libc::c_int,
    /**
     * macroblock decision mode
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub mb_decision: libc::c_int,
    /**
     * custom intra quantization matrix
     * - encoding: Set by user, can be NULL.
     * - decoding: Set by libavcodec.
     */
    pub intra_matrix: *mut u16,
    /**
     * custom inter quantization matrix
     * - encoding: Set by user, can be NULL.
     * - decoding: Set by libavcodec.
     */
    pub inter_matrix: *mut u16,
    /** @deprecated use encoder private options instead */
    pub scenechange_threshold: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub noise_reduction: libc::c_int,
    /**
     * @deprecated this field is unused
     */
    pub me_threshold: libc::c_int,
    /**
     * @deprecated this field is unused
     */
    pub mb_threshold: libc::c_int,
    /**
     * precision of the intra DC coefficient - 8
     * - encoding: Set by user.
     * - decoding: Set by libavcodec
     */
    pub intra_dc_precision: libc::c_int,
    /**
     * Number of macroblock rows at the top which are skipped.
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub skip_top: libc::c_int,
    /**
     * Number of macroblock rows at the bottom which are skipped.
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub skip_bottom: libc::c_int,
    /**
     * @deprecated use encoder private options instead
     */
    pub border_masking: f32,
    /**
     * minimum MB Lagrange multiplier
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub mb_lmin: libc::c_int,
    /**
     * maximum MB Lagrange multiplier
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub mb_lmax: libc::c_int,
    /**
     * @deprecated use encoder private options instead
     */
    pub me_penalty_compensation: libc::c_int,
    /**
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub bidir_refine: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub brd_scale: libc::c_int,
    /**
     * minimum GOP size
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub keyint_min: libc::c_int,
    /**
     * number of reference frames
     * - encoding: Set by user.
     * - decoding: Set by lavc.
     */
    pub refs: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub chromaoffset: libc::c_int,
    /**
     * Multiplied by qscale for each frame and added to scene_change_score.
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub scenechange_factor: libc::c_int,
    /**
     * Note: Value depends upon the compare function used for fullpel ME.
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub mv0_threshold: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub b_sensitivity: libc::c_int,
    /**
     * Chromaticity coordinates of the source primaries.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    pub color_primaries: AVColorPrimaries,
    /**
     * Color Transfer Characteristic.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    pub color_trc: AVColorTransferCharacteristic,
    /**
     * YUV colorspace type.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    pub colorspace: AVColorSpace,
    /**
     * MPEG vs JPEG YUV range.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    pub color_range: AVColorRange,
    /**
     * This defines the location of chroma samples.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    pub chroma_sample_location: AVChromaLocation,
    /**
     * Number of slices.
     * Indicates number of picture subdivisions. Used for parallelized
     * decoding.
     * - encoding: Set by user
     * - decoding: unused
     */
    pub slices: libc::c_int,
    /** Field order
     * - encoding: set by libavcodec
     * - decoding: Set by user.
     */
    pub field_order: AVFieldOrder,
    ///< samples per second
    pub sample_rate: libc::c_int,
    ///< number of audio channels
    pub channels: libc::c_int,
    ///< sample format
    pub sample_fmt: AVSampleFormat,
    /**
     * Number of samples per channel in an audio frame.
     *
     * - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
     *   except the last must contain exactly frame_size samples per channel.
     *   May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the
     *   frame size is not restricted.
     * - decoding: may be set by some decoders to indicate constant frame size
     */
    pub frame_size: libc::c_int,
    /**
     * Frame counter, set by libavcodec.
     *
     * - decoding: total number of frames returned from the decoder so far.
     * - encoding: total number of frames passed to the encoder so far.
     *
     *   @note the counter is not incremented if encoding/decoding resulted in
     *   an error.
     */
    pub frame_number: libc::c_int,
    /**
     * number of bytes per packet if constant and known or 0
     * Used by some WAV based audio codecs.
     */
    pub block_align: libc::c_int,
    /**
     * Audio cutoff bandwidth (0 means "automatic")
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub cutoff: libc::c_int,
    /**
     * Audio channel layout.
     * - encoding: set by user.
     * - decoding: set by user, may be overwritten by libavcodec.
     */
    pub channel_layout: u64,
    /**
     * Request decoder to use this channel layout if it can (0 for default)
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub request_channel_layout: u64,
    /**
     * Type of service that the audio stream conveys.
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    pub audio_service_type: AVAudioServiceType,
    /**
     * desired sample format
     * - encoding: Not used.
     * - decoding: Set by user.
     * Decoder will decode to this format if it can.
     */
    pub request_sample_fmt: AVSampleFormat,
    /**
     * This callback is called at the beginning of each frame to get data
     * buffer(s) for it. There may be one contiguous buffer for all the data or
     * there may be a buffer per each data plane or anything in between. What
     * this means is, you may set however many entries in buf[] you feel necessary.
     * Each buffer must be reference-counted using the AVBuffer API (see description
     * of buf[] below).
     *
     * The following fields will be set in the frame before this callback is
     * called:
     * - format
     * - width, height (video only)
     * - sample_rate, channel_layout, nb_samples (audio only)
     * Their values may differ from the corresponding values in
     * AVCodecContext. This callback must use the frame values, not the codec
     * context values, to calculate the required buffer size.
     *
     * This callback must fill the following fields in the frame:
     * - data[]
     * - linesize[]
     * - extended_data:
     *   * if the data is planar audio with more than 8 channels, then this
     *     callback must allocate and fill extended_data to contain all pointers
     *     to all data planes. data[] must hold as many pointers as it can.
     *     extended_data must be allocated with av_malloc() and will be freed in
     *     av_frame_unref().
     *   * otherwise extended_data must point to data
     * - buf[] must contain one or more pointers to AVBufferRef structures. Each of
     *   the frame's data and extended_data pointers must be contained in these. That
     *   is, one AVBufferRef for each allocated chunk of memory, not necessarily one
     *   AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),
     *   and av_buffer_ref().
     * - extended_buf and nb_extended_buf must be allocated with av_malloc() by
     *   this callback and filled with the extra buffers if there are more
     *   buffers than buf[] can hold. extended_buf will be freed in
     *   av_frame_unref().
     *
     * If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call
     * avcodec_default_get_buffer2() instead of providing buffers allocated by
     * some other means.
     *
     * Each data plane must be aligned to the maximum required by the target
     * CPU.
     *
     * @see avcodec_default_get_buffer2()
     *
     * Video:
     *
     * If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
     * (read and/or written to if it is writable) later by libavcodec.
     *
     * avcodec_align_dimensions2() should be used to find the required width and
     * height, as they normally need to be rounded up to the next multiple of 16.
     *
     * Some decoders do not support linesizes changing between frames.
     *
     * If frame multithreading is used and thread_safe_callbacks is set,
     * this callback may be called from a different thread, but not from more
     * than one at once. Does not need to be reentrant.
     *
     * @see avcodec_align_dimensions2()
     *
     * Audio:
     *
     * Decoders request a buffer of a particular size by setting
     * AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
     * however, utilize only part of the buffer by setting AVFrame.nb_samples
     * to a smaller value in the output frame.
     *
     * As a convenience, av_samples_get_buffer_size() and
     * av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
     * functions to find the required data size and to fill data pointers and
     * linesize. In AVFrame.linesize, only linesize[0] may be set for audio
     * since all planes must be the same size.
     *
     * @see av_samples_get_buffer_size(), av_samples_fill_arrays()
     *
     * - encoding: unused
     * - decoding: Set by libavcodec, user can override.
     */
    pub get_buffer2: ::std::option::Option<unsafe extern "C" fn(s:
                                                                    *mut AVCodecContext,
                                                                frame:
                                                                    *mut AVFrame,
                                                                flags:
                                                                    libc::c_int)
                                               -> libc::c_int>,
    /**
     * If non-zero, the decoded audio and video frames returned from
     * avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
     * and are valid indefinitely. The caller must free them with
     * av_frame_unref() when they are not needed anymore.
     * Otherwise, the decoded frames must not be freed by the caller and are
     * only valid until the next decode call.
     *
     * This is always automatically enabled if avcodec_receive_frame() is used.
     *
     * - encoding: unused
     * - decoding: set by the caller before avcodec_open2().
     */
    pub refcounted_frames: libc::c_int,
    ///< amount of qscale change between easy & hard scenes (0.0-1.0)
    pub qcompress: f32,
    ///< amount of qscale smoothing over time (0.0-1.0)
    pub qblur: f32,
    /**
     * minimum quantizer
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub qmin: libc::c_int,
    /**
     * maximum quantizer
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub qmax: libc::c_int,
    /**
     * maximum quantizer difference between frames
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub max_qdiff: libc::c_int,
    /**
     * @deprecated use encoder private options instead
     */
    pub rc_qsquish: f32,
    pub rc_qmod_amp: f32,
    pub rc_qmod_freq: libc::c_int,
    /**
     * decoder bitstream buffer size
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub rc_buffer_size: libc::c_int,
    /**
     * ratecontrol override, see RcOverride
     * - encoding: Allocated/set/freed by user.
     * - decoding: unused
     */
    pub rc_override_count: libc::c_int,
    pub rc_override: *mut RcOverride,
    /**
     * @deprecated use encoder private options instead
     */
    pub rc_eq: *const libc::c_char,
    /**
     * maximum bitrate
     * - encoding: Set by user.
     * - decoding: Set by user, may be overwritten by libavcodec.
     */
    pub rc_max_rate: i64,
    /**
     * minimum bitrate
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub rc_min_rate: i64,
    /**
     * @deprecated use encoder private options instead
     */
    pub rc_buffer_aggressivity: f32,
    pub rc_initial_cplx: f32,
    /**
     * Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.
     * - encoding: Set by user.
     * - decoding: unused.
     */
    pub rc_max_available_vbv_use: f32,
    /**
     * Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.
     * - encoding: Set by user.
     * - decoding: unused.
     */
    pub rc_min_vbv_overflow_use: f32,
    /**
     * Number of bits which should be loaded into the rc buffer before decoding starts.
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub rc_initial_buffer_occupancy: libc::c_int,
    /**
     * @deprecated use encoder private options instead
     */
    pub coder_type: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub context_model: libc::c_int,
    /**
     * @deprecated use encoder private options instead
     */
    pub lmin: libc::c_int,
    /**
     * @deprecated use encoder private options instead
     */
    pub lmax: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub frame_skip_threshold: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub frame_skip_factor: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub frame_skip_exp: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub frame_skip_cmp: libc::c_int,
    /**
     * trellis RD quantization
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub trellis: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub min_prediction_order: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub max_prediction_order: libc::c_int,
    /** @deprecated use encoder private options instead */
    pub timecode_frame_start: i64,
    /**
     * @deprecated unused
     */
    pub rtp_callback: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                     *mut AVCodecContext,
                                                                 data:
                                                                     *mut libc::c_void,
                                                                 size:
                                                                     libc::c_int,
                                                                 mb_nb:
                                                                     libc::c_int)>,
    /** @deprecated use encoder private options instead */
    pub rtp_payload_size: libc::c_int,
    pub mv_bits: libc::c_int,
    pub header_bits: libc::c_int,
    pub i_tex_bits: libc::c_int,
    pub p_tex_bits: libc::c_int,
    pub i_count: libc::c_int,
    pub p_count: libc::c_int,
    pub skip_count: libc::c_int,
    pub misc_bits: libc::c_int,
    /** @deprecated this field is unused */
    pub frame_bits: libc::c_int,
    /**
     * pass1 encoding statistics output buffer
     * - encoding: Set by libavcodec.
     * - decoding: unused
     */
    pub stats_out: *mut libc::c_char,
    /**
     * pass2 encoding statistics input buffer
     * Concatenated stuff from stats_out of pass1 should be placed here.
     * - encoding: Allocated/set/freed by user.
     * - decoding: unused
     */
    pub stats_in: *mut libc::c_char,
    /**
     * Work around bugs in encoders which sometimes cannot be detected automatically.
     * - encoding: Set by user
     * - decoding: Set by user
     */
    pub workaround_bugs: libc::c_int,
    /**
     * strictly follow the standard (MPEG-4, ...).
     * - encoding: Set by user.
     * - decoding: Set by user.
     * Setting this to STRICT or higher means the encoder and decoder will
     * generally do stupid things, whereas setting it to unofficial or lower
     * will mean the encoder might produce output that is not supported by all
     * spec-compliant decoders. Decoders don't differentiate between normal,
     * unofficial and experimental (that is, they always try to decode things
     * when they can) unless they are explicitly asked to behave stupidly
     * (=strictly conform to the specs)
     */
    pub strict_std_compliance: libc::c_int,
    /**
     * error concealment flags
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub error_concealment: libc::c_int,
    /**
     * debug
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub debug: libc::c_int,
    /**
     * debug
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub debug_mv: libc::c_int,
    /**
     * Error recognition; may misdetect some more or less valid parts as errors.
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub err_recognition: libc::c_int,
    /**
     * opaque 64-bit number (generally a PTS) that will be reordered and
     * output in AVFrame.reordered_opaque
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub reordered_opaque: i64,
    /**
     * Hardware accelerator in use
     * - encoding: unused.
     * - decoding: Set by libavcodec
     */
    pub hwaccel: *mut AVHWAccel,
    /**
     * Hardware accelerator context.
     * For some hardware accelerators, a global context needs to be
     * provided by the user. In that case, this holds display-dependent
     * data FFmpeg cannot instantiate itself. Please refer to the
     * FFmpeg HW accelerator documentation to know how to fill this
     * is. e.g. for VA API, this is a struct vaapi_context.
     * - encoding: unused
     * - decoding: Set by user
     */
    pub hwaccel_context: *mut libc::c_void,
    /**
     * error
     * - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.
     * - decoding: unused
     */
    pub error: [u64; 8usize],
    /**
     * DCT algorithm, see FF_DCT_* below
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub dct_algo: libc::c_int,
    /**
     * IDCT algorithm, see FF_IDCT_* below.
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub idct_algo: libc::c_int,
    /**
     * bits per sample/pixel from the demuxer (needed for huffyuv).
     * - encoding: Set by libavcodec.
     * - decoding: Set by user.
     */
    pub bits_per_coded_sample: libc::c_int,
    /**
     * Bits per sample/pixel of internal libavcodec pixel/sample format.
     * - encoding: set by user.
     * - decoding: set by libavcodec.
     */
    pub bits_per_raw_sample: libc::c_int,
    /**
     * low resolution decoding, 1-> 1/2 size, 2->1/4 size
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub lowres: libc::c_int,
    /**
     * the picture in the bitstream
     * - encoding: Set by libavcodec.
     * - decoding: unused
     *
     * @deprecated use the quality factor packet side data instead
     */
    pub coded_frame: *mut AVFrame,
    /**
     * thread count
     * is used to decide how many independent tasks should be passed to execute()
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub thread_count: libc::c_int,
    /**
     * Which multithreading methods to use.
     * Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,
     * so clients which cannot provide future frames should not use it.
     *
     * - encoding: Set by user, otherwise the default is used.
     * - decoding: Set by user, otherwise the default is used.
     */
    pub thread_type: libc::c_int,
    /**
     * Which multithreading methods are in use by the codec.
     * - encoding: Set by libavcodec.
     * - decoding: Set by libavcodec.
     */
    pub active_thread_type: libc::c_int,
    /**
     * Set by the client if its custom get_buffer() callback can be called
     * synchronously from another thread, which allows faster multithreaded decoding.
     * draw_horiz_band() will be called from other threads regardless of this setting.
     * Ignored if the default get_buffer() is used.
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub thread_safe_callbacks: libc::c_int,
    /**
     * The codec may call this to execute several independent things.
     * It will return only after finishing all tasks.
     * The user may replace this with some multithreaded implementation,
     * the default implementation will execute the parts serially.
     * @param count the number of things to execute
     * - encoding: Set by libavcodec, user can override.
     * - decoding: Set by libavcodec, user can override.
     */
    pub execute: ::std::option::Option<unsafe extern "C" fn(c:
                                                                *mut AVCodecContext,
                                                            func:
                                                                ::std::option::Option<unsafe extern "C" fn(c2:
                                                                                                               *mut AVCodecContext,
                                                                                                           arg:
                                                                                                               *mut libc::c_void)
                                                                                          ->
                                                                                              libc::c_int>,
                                                            arg2:
                                                                *mut libc::c_void,
                                                            ret:
                                                                *mut libc::c_int,
                                                            count:
                                                                libc::c_int,
                                                            size: libc::c_int)
                                           -> libc::c_int>,
    /**
     * The codec may call this to execute several independent things.
     * It will return only after finishing all tasks.
     * The user may replace this with some multithreaded implementation,
     * the default implementation will execute the parts serially.
     * Also see avcodec_thread_init and e.g. the --enable-pthread configure option.
     * @param c context passed also to func
     * @param count the number of things to execute
     * @param arg2 argument passed unchanged to func
     * @param ret return values of executed functions, must have space for "count" values. May be NULL.
     * @param func function that will be called count times, with jobnr from 0 to count-1.
     *             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no
     *             two instances of func executing at the same time will have the same threadnr.
     * @return always 0 currently, but code should handle a future improvement where when any call to func
     *         returns < 0 no further calls to func may be done and < 0 is returned.
     * - encoding: Set by libavcodec, user can override.
     * - decoding: Set by libavcodec, user can override.
     */
    pub execute2: ::std::option::Option<unsafe extern "C" fn(c:
                                                                 *mut AVCodecContext,
                                                             func:
                                                                 ::std::option::Option<unsafe extern "C" fn(c2:
                                                                                                                *mut AVCodecContext,
                                                                                                            arg:
                                                                                                                *mut libc::c_void,
                                                                                                            jobnr:
                                                                                                                libc::c_int,
                                                                                                            threadnr:
                                                                                                                libc::c_int)
                                                                                           ->
                                                                                               libc::c_int>,
                                                             arg2:
                                                                 *mut libc::c_void,
                                                             ret:
                                                                 *mut libc::c_int,
                                                             count:
                                                                 libc::c_int)
                                            -> libc::c_int>,
    /**
     * noise vs. sse weight for the nsse comparison function
     * - encoding: Set by user.
     * - decoding: unused
     */
    pub nsse_weight: libc::c_int,
    /**
     * profile
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    pub profile: libc::c_int,
    /**
     * level
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    pub level: libc::c_int,
    /**
     * Skip loop filtering for selected frames.
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub skip_loop_filter: AVDiscard,
    /**
     * Skip IDCT/dequantization for selected frames.
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub skip_idct: AVDiscard,
    /**
     * Skip decoding for selected frames.
     * - encoding: unused
     * - decoding: Set by user.
     */
    pub skip_frame: AVDiscard,
    /**
     * Header containing style information for text subtitles.
     * For SUBTITLE_ASS subtitle type, it should contain the whole ASS
     * [Script Info] and [V4+ Styles] section, plus the [Events] line and
     * the Format line following. It shouldn't include any Dialogue line.
     * - encoding: Set/allocated/freed by user (before avcodec_open2())
     * - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
     */
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: libc::c_int,
    /**
     * @deprecated use the 'error_rate' private AVOption of the mpegvideo
     * encoders
     */
    pub error_rate: libc::c_int,
    /**
     * VBV delay coded in the last frame (in periods of a 27 MHz clock).
     * Used for compliant TS muxing.
     * - encoding: Set by libavcodec.
     * - decoding: unused.
     * @deprecated this value is now exported as a part of
     * AV_PKT_DATA_CPB_PROPERTIES packet side data
     */
    pub vbv_delay: u64,
    /**
     * Encoding only and set by default. Allow encoders to output packets
     * that do not contain any encoded data, only side data.
     *
     * Some encoders need to output such packets, e.g. to update some stream
     * parameters at the end of encoding.
     *
     * @deprecated this field disables the default behaviour and
     *             it is kept only for compatibility.
     */
    pub side_data_only_packets: libc::c_int,
    /**
     * Audio only. The number of "priming" samples (padding) inserted by the
     * encoder at the beginning of the audio. I.e. this number of leading
     * decoded samples must be discarded by the caller to get the original audio
     * without leading padding.
     *
     * - decoding: unused
     * - encoding: Set by libavcodec. The timestamps on the output packets are
     *             adjusted by the encoder so that they always refer to the
     *             first sample of the data actually contained in the packet,
     *             including any added padding.  E.g. if the timebase is
     *             1/samplerate and the timestamp of the first input sample is
     *             0, the timestamp of the first output packet will be
     *             -initial_padding.
     */
    pub initial_padding: libc::c_int,
    /**
     * - decoding: For codecs that store a framerate value in the compressed
     *             bitstream, the decoder may export it here. { 0, 1} when
     *             unknown.
     * - encoding: May be used to signal the framerate of CFR content to an
     *             encoder.
     */
    pub framerate: AVRational,
    /**
     * Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
     * - encoding: unused.
     * - decoding: Set by libavcodec before calling get_format()
     */
    pub sw_pix_fmt: AVPixelFormat,
    /**
     * Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
     * - encoding unused.
     * - decoding set by user.
     */
    pub pkt_timebase: AVRational,
    /**
     * AVCodecDescriptor
     * - encoding: unused.
     * - decoding: set by libavcodec.
     */
    pub codec_descriptor: *const AVCodecDescriptor,
    /**
     * Current statistics for PTS correction.
     * - decoding: maintained and used by libavcodec, not intended to be used by user apps
     * - encoding: unused
     */
    pub pts_correction_num_faulty_pts: i64,
    /// Number of incorrect PTS values so far
    pub pts_correction_num_faulty_dts: i64,
    /// Number of incorrect DTS values so far
    pub pts_correction_last_pts: i64,
    /// PTS of the last frame
    pub pts_correction_last_dts: i64,
    /**
     * Character encoding of the input subtitles file.
     * - decoding: set by user
     * - encoding: unused
     */
    pub sub_charenc: *mut libc::c_char,
    /**
     * Subtitles character encoding mode. Formats or codecs might be adjusting
     * this setting (if they are doing the conversion themselves for instance).
     * - decoding: set by libavcodec
     * - encoding: unused
     */
    pub sub_charenc_mode: libc::c_int,
    /**
     * Skip processing alpha if supported by codec.
     * Note that if the format uses pre-multiplied alpha (common with VP6,
     * and recommended due to better video quality/compression)
     * the image will look as if alpha-blended onto a black background.
     * However for formats that do not use pre-multiplied alpha
     * there might be serious artefacts (though e.g. libswscale currently
     * assumes pre-multiplied alpha anyway).
     *
     * - decoding: set by user
     * - encoding: unused
     */
    pub skip_alpha: libc::c_int,
    /**
     * Number of samples to skip after a discontinuity
     * - decoding: unused
     * - encoding: set by libavcodec
     */
    pub seek_preroll: libc::c_int,
    /**
     * custom intra quantization matrix
     * - encoding: Set by user, can be NULL.
     * - decoding: unused.
     */
    pub chroma_intra_matrix: *mut u16,
    /**
     * dump format separator.
     * can be ", " or "\n      " or anything else
     * - encoding: Set by user.
     * - decoding: Set by user.
     */
    pub dump_separator: *mut u8,
    /**
     * ',' separated list of allowed decoders.
     * If NULL then all are allowed
     * - encoding: unused
     * - decoding: set by user
     */
    pub codec_whitelist: *mut libc::c_char,
    pub properties: libc::c_uint,
    /**
     * Additional data associated with the entire coded stream.
     *
     * - decoding: unused
     * - encoding: may be set by libavcodec after avcodec_open2().
     */
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: libc::c_int,
    /**
     * A reference to the AVHWFramesContext describing the input (for encoding)
     * or output (decoding) frames. The reference is set by the caller and
     * afterwards owned (and freed) by libavcodec - it should never be read by
     * the caller after being set.
     *
     * - decoding: This field should be set by the caller from the get_format()
     *             callback. The previous reference (if any) will always be
     *             unreffed by libavcodec before the get_format() call.
     *
     *             If the default get_buffer2() is used with a hwaccel pixel
     *             format, then this AVHWFramesContext will be used for
     *             allocating the frame buffers.
     *
     * - encoding: For hardware encoders configured to use a hwaccel pixel
     *             format, this field should be set by the caller to a reference
     *             to the AVHWFramesContext describing input frames.
     *             AVHWFramesContext.format must be equal to
     *             AVCodecContext.pix_fmt.
     *
     *             This field should be set before avcodec_open2() is called.
     */
    pub hw_frames_ctx: *mut AVBufferRef,
    /**
     * Control the form of AVSubtitle.rects[N]->ass
     * - decoding: set by user
     * - encoding: unused
     */
    pub sub_text_format: libc::c_int,
    /**
     * Audio only. The amount of padding (in samples) appended by the encoder to
     * the end of the audio. I.e. this number of decoded samples must be
     * discarded by the caller from the end of the stream to get the original
     * audio without any trailing padding.
     *
     * - decoding: unused
     * - encoding: unused
     */
    pub trailing_padding: libc::c_int,
    /**
     * The number of pixels per image to maximally accept.
     *
     * - decoding: set by user
     * - encoding: set by user
     */
    pub max_pixels: i64,
    /**
     * A reference to the AVHWDeviceContext describing the device which will
     * be used by a hardware encoder/decoder.  The reference is set by the
     * caller and afterwards owned (and freed) by libavcodec.
     *
     * This should be used if either the codec device does not require
     * hardware frames or any that are used are to be allocated internally by
     * libavcodec.  If the user wishes to supply any of the frames used as
     * encoder input or decoder output then hw_frames_ctx should be used
     * instead.  When hw_frames_ctx is set in get_format() for a decoder, this
     * field will be ignored while decoding the associated stream segment, but
     * may again be used on a following one after another get_format() call.
     *
     * For both encoders and decoders this field should be set before
     * avcodec_open2() is called and must not be written to thereafter.
     *
     * Note that some decoders may require this field to be set initially in
     * order to support hw_frames_ctx at all - in that case, all frames
     * contexts used must be created on the same device.
     */
    pub hw_device_ctx: *mut AVBufferRef,
    /**
     * Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
     * decoding (if active).
     * - encoding: unused
     * - decoding: Set by user (either before avcodec_open2(), or in the
     *             AVCodecContext.get_format callback)
     */
    pub hwaccel_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecContext() {
    assert_eq!(::std::mem::size_of::<AVCodecContext>() , 1160usize , concat !
               ( "Size of: " , stringify ! ( AVCodecContext ) ));
    assert_eq! (::std::mem::align_of::<AVCodecContext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVCodecContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . av_class as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( av_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . log_level_offset as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( log_level_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . codec_type as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( codec_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . codec as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . codec_name as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( codec_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . codec_id as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( codec_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . codec_tag as * const
                _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( codec_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . stream_codec_tag as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( stream_codec_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . priv_data as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( priv_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . internal as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . opaque as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . bit_rate as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( bit_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . bit_rate_tolerance
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( bit_rate_tolerance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . global_quality as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( global_quality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . compression_level as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( compression_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . flags as * const _
                as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . flags2 as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . extradata as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( extradata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . extradata_size as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( extradata_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . time_base as * const
                _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( time_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . ticks_per_frame as *
                const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( ticks_per_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . delay as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . width as * const _
                as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . height as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . coded_width as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( coded_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . coded_height as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( coded_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . gop_size as * const
                _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( gop_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . pix_fmt as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( pix_fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . me_method as * const
                _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( me_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . draw_horiz_band as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( draw_horiz_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . get_format as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( get_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . max_b_frames as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( max_b_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . b_quant_factor as *
                const _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( b_quant_factor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_strategy as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . b_frame_strategy as
                * const _ as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( b_frame_strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . b_quant_offset as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( b_quant_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . has_b_frames as *
                const _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( has_b_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . mpeg_quant as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( mpeg_quant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . i_quant_factor as *
                const _ as usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( i_quant_factor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . i_quant_offset as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( i_quant_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . lumi_masking as *
                const _ as usize } , 236usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( lumi_masking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                temporal_cplx_masking as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( temporal_cplx_masking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . spatial_cplx_masking
                as * const _ as usize } , 244usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( spatial_cplx_masking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . p_masking as * const
                _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( p_masking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . dark_masking as *
                const _ as usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( dark_masking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . slice_count as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( slice_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . prediction_method as
                * const _ as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( prediction_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . slice_offset as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( slice_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . sample_aspect_ratio
                as * const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( sample_aspect_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . me_cmp as * const _
                as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( me_cmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . me_sub_cmp as *
                const _ as usize } , 284usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( me_sub_cmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . mb_cmp as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( mb_cmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . ildct_cmp as * const
                _ as usize } , 292usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( ildct_cmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . dia_size as * const
                _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( dia_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . last_predictor_count
                as * const _ as usize } , 300usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( last_predictor_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . pre_me as * const _
                as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( pre_me ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . me_pre_cmp as *
                const _ as usize } , 308usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( me_pre_cmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . pre_dia_size as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( pre_dia_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . me_subpel_quality as
                * const _ as usize } , 316usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( me_subpel_quality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . dtg_active_format as
                * const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( dtg_active_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . me_range as * const
                _ as usize } , 324usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( me_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . intra_quant_bias as
                * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( intra_quant_bias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . inter_quant_bias as
                * const _ as usize } , 332usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( inter_quant_bias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . slice_flags as *
                const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( slice_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . xvmc_acceleration as
                * const _ as usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( xvmc_acceleration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . mb_decision as *
                const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( mb_decision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . intra_matrix as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( intra_matrix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . inter_matrix as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( inter_matrix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                scenechange_threshold as * const _ as usize } , 368usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( scenechange_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . noise_reduction as *
                const _ as usize } , 372usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( noise_reduction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . me_threshold as *
                const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( me_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . mb_threshold as *
                const _ as usize } , 380usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( mb_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . intra_dc_precision
                as * const _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( intra_dc_precision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . skip_top as * const
                _ as usize } , 388usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( skip_top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . skip_bottom as *
                const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( skip_bottom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . border_masking as *
                const _ as usize } , 396usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( border_masking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . mb_lmin as * const _
                as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( mb_lmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . mb_lmax as * const _
                as usize } , 404usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( mb_lmax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                me_penalty_compensation as * const _ as usize } , 408usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( me_penalty_compensation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . bidir_refine as *
                const _ as usize } , 412usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( bidir_refine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . brd_scale as * const
                _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( brd_scale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . keyint_min as *
                const _ as usize } , 420usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( keyint_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . refs as * const _ as
                usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . chromaoffset as *
                const _ as usize } , 428usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( chromaoffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . scenechange_factor
                as * const _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( scenechange_factor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . mv0_threshold as *
                const _ as usize } , 436usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( mv0_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . b_sensitivity as *
                const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( b_sensitivity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . color_primaries as *
                const _ as usize } , 444usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( color_primaries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . color_trc as * const
                _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( color_trc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . colorspace as *
                const _ as usize } , 452usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( colorspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . color_range as *
                const _ as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( color_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                chroma_sample_location as * const _ as usize } , 460usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( chroma_sample_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . slices as * const _
                as usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( slices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . field_order as *
                const _ as usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( field_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . sample_rate as *
                const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( sample_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . channels as * const
                _ as usize } , 476usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . sample_fmt as *
                const _ as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( sample_fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . frame_size as *
                const _ as usize } , 484usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . frame_number as *
                const _ as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( frame_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . block_align as *
                const _ as usize } , 492usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( block_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . cutoff as * const _
                as usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( cutoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . channel_layout as *
                const _ as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( channel_layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                request_channel_layout as * const _ as usize } , 512usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( request_channel_layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . audio_service_type
                as * const _ as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( audio_service_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . request_sample_fmt
                as * const _ as usize } , 524usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( request_sample_fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . get_buffer2 as *
                const _ as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( get_buffer2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . refcounted_frames as
                * const _ as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( refcounted_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . qcompress as * const
                _ as usize } , 540usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( qcompress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . qblur as * const _
                as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( qblur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . qmin as * const _ as
                usize } , 548usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( qmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . qmax as * const _ as
                usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( qmax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . max_qdiff as * const
                _ as usize } , 556usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( max_qdiff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_qsquish as *
                const _ as usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_qsquish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_qmod_amp as *
                const _ as usize } , 564usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_qmod_amp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_qmod_freq as *
                const _ as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_qmod_freq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_buffer_size as *
                const _ as usize } , 572usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_buffer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_override_count as
                * const _ as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_override_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_override as *
                const _ as usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_override ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_eq as * const _
                as usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_eq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_max_rate as *
                const _ as usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_max_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_min_rate as *
                const _ as usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_min_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                rc_buffer_aggressivity as * const _ as usize } , 616usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_buffer_aggressivity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rc_initial_cplx as *
                const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_initial_cplx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                rc_max_available_vbv_use as * const _ as usize } , 624usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_max_available_vbv_use ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                rc_min_vbv_overflow_use as * const _ as usize } , 628usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_min_vbv_overflow_use ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                rc_initial_buffer_occupancy as * const _ as usize } , 632usize
                , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rc_initial_buffer_occupancy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . coder_type as *
                const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( coder_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . context_model as *
                const _ as usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( context_model ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . lmin as * const _ as
                usize } , 644usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( lmin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . lmax as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( lmax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . frame_skip_threshold
                as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( frame_skip_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . frame_skip_factor as
                * const _ as usize } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( frame_skip_factor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . frame_skip_exp as *
                const _ as usize } , 660usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( frame_skip_exp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . frame_skip_cmp as *
                const _ as usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( frame_skip_cmp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . trellis as * const _
                as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( trellis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . min_prediction_order
                as * const _ as usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( min_prediction_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . max_prediction_order
                as * const _ as usize } , 676usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( max_prediction_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . timecode_frame_start
                as * const _ as usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( timecode_frame_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rtp_callback as *
                const _ as usize } , 688usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rtp_callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . rtp_payload_size as
                * const _ as usize } , 696usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( rtp_payload_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . mv_bits as * const _
                as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( mv_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . header_bits as *
                const _ as usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( header_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . i_tex_bits as *
                const _ as usize } , 708usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( i_tex_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . p_tex_bits as *
                const _ as usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( p_tex_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . i_count as * const _
                as usize } , 716usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( i_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . p_count as * const _
                as usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( p_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . skip_count as *
                const _ as usize } , 724usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( skip_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . misc_bits as * const
                _ as usize } , 728usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( misc_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . frame_bits as *
                const _ as usize } , 732usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( frame_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . stats_out as * const
                _ as usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( stats_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . stats_in as * const
                _ as usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( stats_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . workaround_bugs as *
                const _ as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( workaround_bugs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                strict_std_compliance as * const _ as usize } , 756usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( strict_std_compliance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . error_concealment as
                * const _ as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( error_concealment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . debug as * const _
                as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( debug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . debug_mv as * const
                _ as usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( debug_mv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . err_recognition as *
                const _ as usize } , 772usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( err_recognition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . reordered_opaque as
                * const _ as usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( reordered_opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . hwaccel as * const _
                as usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( hwaccel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . hwaccel_context as *
                const _ as usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( hwaccel_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . error as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . dct_algo as * const
                _ as usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( dct_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . idct_algo as * const
                _ as usize } , 868usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( idct_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                bits_per_coded_sample as * const _ as usize } , 872usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( bits_per_coded_sample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . bits_per_raw_sample
                as * const _ as usize } , 876usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( bits_per_raw_sample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . lowres as * const _
                as usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( lowres ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . coded_frame as *
                const _ as usize } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( coded_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . thread_count as *
                const _ as usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( thread_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . thread_type as *
                const _ as usize } , 900usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( thread_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . active_thread_type
                as * const _ as usize } , 904usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( active_thread_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                thread_safe_callbacks as * const _ as usize } , 908usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( thread_safe_callbacks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . execute as * const _
                as usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( execute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . execute2 as * const
                _ as usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( execute2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . nsse_weight as *
                const _ as usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( nsse_weight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . profile as * const _
                as usize } , 932usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( profile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . level as * const _
                as usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . skip_loop_filter as
                * const _ as usize } , 940usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( skip_loop_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . skip_idct as * const
                _ as usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( skip_idct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . skip_frame as *
                const _ as usize } , 948usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( skip_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . subtitle_header as *
                const _ as usize } , 952usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( subtitle_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . subtitle_header_size
                as * const _ as usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( subtitle_header_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . error_rate as *
                const _ as usize } , 964usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( error_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . vbv_delay as * const
                _ as usize } , 968usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( vbv_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                side_data_only_packets as * const _ as usize } , 976usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( side_data_only_packets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . initial_padding as *
                const _ as usize } , 980usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( initial_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . framerate as * const
                _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( framerate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . sw_pix_fmt as *
                const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( sw_pix_fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . pkt_timebase as *
                const _ as usize } , 996usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( pkt_timebase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . codec_descriptor as
                * const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( codec_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                pts_correction_num_faulty_pts as * const _ as usize } ,
                1016usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( pts_correction_num_faulty_pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                pts_correction_num_faulty_dts as * const _ as usize } ,
                1024usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( pts_correction_num_faulty_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                pts_correction_last_pts as * const _ as usize } , 1032usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( pts_correction_last_pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) .
                pts_correction_last_dts as * const _ as usize } , 1040usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( pts_correction_last_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . sub_charenc as *
                const _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( sub_charenc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . sub_charenc_mode as
                * const _ as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( sub_charenc_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . skip_alpha as *
                const _ as usize } , 1060usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( skip_alpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . seek_preroll as *
                const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( seek_preroll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . chroma_intra_matrix
                as * const _ as usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( chroma_intra_matrix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . dump_separator as *
                const _ as usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( dump_separator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . codec_whitelist as *
                const _ as usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( codec_whitelist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . properties as *
                const _ as usize } , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( properties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . coded_side_data as *
                const _ as usize } , 1104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( coded_side_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . nb_coded_side_data
                as * const _ as usize } , 1112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( nb_coded_side_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . hw_frames_ctx as *
                const _ as usize } , 1120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( hw_frames_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . sub_text_format as *
                const _ as usize } , 1128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( sub_text_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . trailing_padding as
                * const _ as usize } , 1132usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( trailing_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . max_pixels as *
                const _ as usize } , 1136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( max_pixels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . hw_device_ctx as *
                const _ as usize } , 1144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( hw_device_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecContext ) ) . hwaccel_flags as *
                const _ as usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecContext ) , "::"
                , stringify ! ( hwaccel_flags ) ));
}
impl Clone for AVCodecContext {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn av_codec_get_pkt_timebase(avctx: *const AVCodecContext)
     -> AVRational;
}
extern "C" {
    pub fn av_codec_set_pkt_timebase(avctx: *mut AVCodecContext,
                                     val: AVRational);
}
extern "C" {
    pub fn av_codec_get_codec_descriptor(avctx: *const AVCodecContext)
     -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn av_codec_set_codec_descriptor(avctx: *mut AVCodecContext,
                                         desc: *const AVCodecDescriptor);
}
extern "C" {
    pub fn av_codec_get_codec_properties(avctx: *const AVCodecContext)
     -> libc::c_uint;
}
extern "C" {
    pub fn av_codec_get_lowres(avctx: *const AVCodecContext) -> libc::c_int;
}
extern "C" {
    pub fn av_codec_set_lowres(avctx: *mut AVCodecContext, val: libc::c_int);
}
extern "C" {
    pub fn av_codec_get_seek_preroll(avctx: *const AVCodecContext)
     -> libc::c_int;
}
extern "C" {
    pub fn av_codec_set_seek_preroll(avctx: *mut AVCodecContext,
                                     val: libc::c_int);
}
extern "C" {
    pub fn av_codec_get_chroma_intra_matrix(avctx: *const AVCodecContext)
     -> *mut u16;
}
extern "C" {
    pub fn av_codec_set_chroma_intra_matrix(avctx: *mut AVCodecContext,
                                            val: *mut u16);
}
/**
 * AVProfile.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVProfile {
    pub profile: libc::c_int,
    ///< short name for the profile
    pub name: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVProfile() {
    assert_eq!(::std::mem::size_of::<AVProfile>() , 16usize , concat ! (
               "Size of: " , stringify ! ( AVProfile ) ));
    assert_eq! (::std::mem::align_of::<AVProfile>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVProfile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProfile ) ) . profile as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProfile ) , "::" ,
                stringify ! ( profile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProfile ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProfile ) , "::" ,
                stringify ! ( name ) ));
}
impl Clone for AVProfile {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDefault {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: libc::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    ///< Same as packet pts, in AV_TIME_BASE
    pub pts: i64,
}
#[test]
fn bindgen_test_layout_AVSubtitle() {
    assert_eq!(::std::mem::size_of::<AVSubtitle>() , 32usize , concat ! (
               "Size of: " , stringify ! ( AVSubtitle ) ));
    assert_eq! (::std::mem::align_of::<AVSubtitle>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVSubtitle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitle ) ) . format as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" ,
                stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitle ) ) . start_display_time as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" ,
                stringify ! ( start_display_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitle ) ) . end_display_time as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" ,
                stringify ! ( end_display_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitle ) ) . num_rects as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" ,
                stringify ! ( num_rects ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitle ) ) . rects as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" ,
                stringify ! ( rects ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitle ) ) . pts as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitle ) , "::" ,
                stringify ! ( pts ) ));
}
impl Clone for AVSubtitle {
    fn clone(&self) -> Self { *self }
}
/**
 * AVCodec.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVCodec {
    /**
     * Name of the codec implementation.
     * The name is globally unique among encoders and among decoders (but an
     * encoder and a decoder can share the same name).
     * This is the primary way to find a codec from the user perspective.
     */
    pub name: *const libc::c_char,
    /**
     * Descriptive name for the codec, meant to be more human readable than name.
     * You should use the NULL_IF_CONFIG_SMALL() macro to define it.
     */
    pub long_name: *const libc::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    /**
     * Codec capabilities.
     * see AV_CODEC_CAP_*
     */
    pub capabilities: libc::c_int,
    ///< array of supported framerates, or NULL if any, array is terminated by {0,0}
    pub supported_framerates: *const AVRational,
    ///< array of supported pixel formats, or NULL if unknown, array is terminated by -1
    pub pix_fmts: *const AVPixelFormat,
    ///< array of supported audio samplerates, or NULL if unknown, array is terminated by 0
    pub supported_samplerates: *const libc::c_int,
    ///< array of supported sample formats, or NULL if unknown, array is terminated by -1
    pub sample_fmts: *const AVSampleFormat,
    ///< array of support channel layouts, or NULL if unknown. array is terminated by 0
    pub channel_layouts: *const u64,
    ///< maximum value for lowres supported by the decoder
    pub max_lowres: u8,
    ///< AVClass for the private context
    pub priv_class: *const AVClass,
    ///< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
    pub profiles: *const AVProfile,
    /*****************************************************************
     * No fields below this line are part of the public API. They
     * may not be used outside of libavcodec and can be changed and
     * removed at will.
     * New public fields should be added right above.
     *****************************************************************
     */
    pub priv_data_size: libc::c_int,
    pub next: *mut AVCodec,
    /**
     * @name Frame-level threading support functions
     * @{
     */
    /**
     * If defined, called on thread contexts when they are created.
     * If the codec allocates writable tables in init(), re-allocate them here.
     * priv_data will be set to a copy of the original.
     */
    pub init_thread_copy: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut AVCodecContext)
                                                    -> libc::c_int>,
    /**
     * Copy necessary context variables from a previous thread context to the current one.
     * If not defined, the next thread will start automatically; otherwise, the codec
     * must call ff_thread_finish_setup().
     *
     * dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
     */
    pub update_thread_context: ::std::option::Option<unsafe extern "C" fn(dst:
                                                                              *mut AVCodecContext,
                                                                          src:
                                                                              *const AVCodecContext)
                                                         -> libc::c_int>,
    /**
     * Private codec-specific defaults.
     */
    pub defaults: *const AVCodecDefault,
    /**
     * Initialize codec static data, called from avcodec_register().
     */
    pub init_static_data: ::std::option::Option<unsafe extern "C" fn(codec:
                                                                         *mut AVCodec)>,
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             *mut AVCodecContext)
                                        -> libc::c_int>,
    pub encode_sub: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut AVCodecContext,
                                                               buf: *mut u8,
                                                               buf_size:
                                                                   libc::c_int,
                                                               sub:
                                                                   *const AVSubtitle)
                                              -> libc::c_int>,
    /**
     * Encode data to an AVPacket.
     *
     * @param      avctx          codec context
     * @param      avpkt          output AVPacket (may contain a user-provided buffer)
     * @param[in]  frame          AVFrame containing the raw data to be encoded
     * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
     *                            non-empty packet was returned in avpkt.
     * @return 0 on success, negative error code on failure
     */
    pub encode2: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                *mut AVCodecContext,
                                                            avpkt:
                                                                *mut AVPacket,
                                                            frame:
                                                                *const AVFrame,
                                                            got_packet_ptr:
                                                                *mut libc::c_int)
                                           -> libc::c_int>,
    pub decode: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut AVCodecContext,
                                                           outdata:
                                                               *mut libc::c_void,
                                                           outdata_size:
                                                               *mut libc::c_int,
                                                           avpkt:
                                                               *mut AVPacket)
                                          -> libc::c_int>,
    pub close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut AVCodecContext)
                                         -> libc::c_int>,
    /**
     * Decode/encode API with decoupled packet/frame dataflow. The API is the
     * same as the avcodec_ prefixed APIs (avcodec_send_frame() etc.), except
     * that:
     * - never called if the codec is closed or the wrong type,
     * - AVPacket parameter change side data is applied right before calling
     *   AVCodec->send_packet,
     * - if AV_CODEC_CAP_DELAY is not set, drain packets or frames are never sent,
     * - only one drain packet is ever passed down (until the next flush()),
     * - a drain AVPacket is always NULL (no need to check for avpkt->size).
     */
    pub send_frame: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                   *mut AVCodecContext,
                                                               frame:
                                                                   *const AVFrame)
                                              -> libc::c_int>,
    pub send_packet: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                    *mut AVCodecContext,
                                                                avpkt:
                                                                    *const AVPacket)
                                               -> libc::c_int>,
    pub receive_frame: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                      *mut AVCodecContext,
                                                                  frame:
                                                                      *mut AVFrame)
                                                 -> libc::c_int>,
    pub receive_packet: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                       *mut AVCodecContext,
                                                                   avpkt:
                                                                       *mut AVPacket)
                                                  -> libc::c_int>,
    /**
     * Flush buffers.
     * Will be called when seeking
     */
    pub flush: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut AVCodecContext)>,
    /**
     * Internal codec capabilities.
     * See FF_CODEC_CAP_* in internal.h
     */
    pub caps_internal: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVCodec() {
    assert_eq!(::std::mem::size_of::<AVCodec>() , 232usize , concat ! (
               "Size of: " , stringify ! ( AVCodec ) ));
    assert_eq! (::std::mem::align_of::<AVCodec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVCodec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . name as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . long_name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( long_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . type_ as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . id as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . capabilities as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . supported_framerates as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( supported_framerates ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . pix_fmts as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( pix_fmts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . supported_samplerates as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( supported_samplerates ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . sample_fmts as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( sample_fmts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . channel_layouts as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( channel_layouts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . max_lowres as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( max_lowres ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . priv_class as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( priv_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . profiles as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( profiles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . priv_data_size as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( priv_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . next as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . init_thread_copy as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( init_thread_copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . update_thread_context as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( update_thread_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . defaults as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( defaults ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . init_static_data as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( init_static_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . init as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . encode_sub as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( encode_sub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . encode2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( encode2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . decode as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( decode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . close as * const _ as usize
                } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . send_frame as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( send_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . send_packet as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( send_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . receive_frame as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( receive_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . receive_packet as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( receive_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . flush as * const _ as usize
                } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodec ) ) . caps_internal as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodec ) , "::" ,
                stringify ! ( caps_internal ) ));
}
impl Clone for AVCodec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn av_codec_get_max_lowres(codec: *const AVCodec) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MpegEncContext {
    _unused: [u8; 0],
}
/**
 * @defgroup lavc_hwaccel AVHWAccel
 * @{
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVHWAccel {
    /**
     * Name of the hardware accelerated codec.
     * The name is globally unique among encoders and among decoders (but an
     * encoder and a decoder can share the same name).
     */
    pub name: *const libc::c_char,
    /**
     * Type of codec implemented by the hardware accelerator.
     *
     * See AVMEDIA_TYPE_xxx
     */
    pub type_: AVMediaType,
    /**
     * Codec implemented by the hardware accelerator.
     *
     * See AV_CODEC_ID_xxx
     */
    pub id: AVCodecID,
    /**
     * Supported pixel format.
     *
     * Only hardware accelerated formats are supported here.
     */
    pub pix_fmt: AVPixelFormat,
    /**
     * Hardware accelerated codec capabilities.
     * see HWACCEL_CODEC_CAP_*
     */
    pub capabilities: libc::c_int,
    /*****************************************************************
     * No fields below this line are part of the public API. They
     * may not be used outside of libavcodec and can be changed and
     * removed at will.
     * New public fields should be added right above.
     *****************************************************************
     */
    pub next: *mut AVHWAccel,
    /**
     * Allocate a custom buffer
     */
    pub alloc_frame: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                    *mut AVCodecContext,
                                                                frame:
                                                                    *mut AVFrame)
                                               -> libc::c_int>,
    /**
     * Called at the beginning of each frame or field picture.
     *
     * Meaningful frame information (codec specific) is guaranteed to
     * be parsed at this point. This function is mandatory.
     *
     * Note that buf can be NULL along with buf_size set to 0.
     * Otherwise, this means the whole frame is available at this point.
     *
     * @param avctx the codec context
     * @param buf the frame data buffer base
     * @param buf_size the size of the frame in bytes
     * @return zero if successful, a negative value otherwise
     */
    pub start_frame: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                    *mut AVCodecContext,
                                                                buf:
                                                                    *const u8,
                                                                buf_size: u32)
                                               -> libc::c_int>,
    /**
     * Callback for each slice.
     *
     * Meaningful slice information (codec specific) is guaranteed to
     * be parsed at this point. This function is mandatory.
     * The only exception is XvMC, that works on MB level.
     *
     * @param avctx the codec context
     * @param buf the slice data buffer base
     * @param buf_size the size of the slice in bytes
     * @return zero if successful, a negative value otherwise
     */
    pub decode_slice: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                     *mut AVCodecContext,
                                                                 buf:
                                                                     *const u8,
                                                                 buf_size:
                                                                     u32)
                                                -> libc::c_int>,
    /**
     * Called at the end of each frame or field picture.
     *
     * The whole picture is parsed at this point and can now be sent
     * to the hardware accelerator. This function is mandatory.
     *
     * @param avctx the codec context
     * @return zero if successful, a negative value otherwise
     */
    pub end_frame: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                                  *mut AVCodecContext)
                                             -> libc::c_int>,
    /**
     * Size of per-frame hardware accelerator private data.
     *
     * Private data is allocated with av_mallocz() before
     * AVCodecContext.get_buffer() and deallocated after
     * AVCodecContext.release_buffer().
     */
    pub frame_priv_data_size: libc::c_int,
    /**
     * Called for every Macroblock in a slice.
     *
     * XvMC uses it to replace the ff_mpv_decode_mb().
     * Instead of decoding to raw picture, MB parameters are
     * stored in an array provided by the video driver.
     *
     * @param s the mpeg context
     */
    pub decode_mb: ::std::option::Option<unsafe extern "C" fn(s:
                                                                  *mut MpegEncContext)>,
    /**
     * Initialize the hwaccel private data.
     *
     * This will be called from ff_get_format(), after hwaccel and
     * hwaccel_context are set and the hwaccel private data in AVCodecInternal
     * is allocated.
     */
    pub init: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                             *mut AVCodecContext)
                                        -> libc::c_int>,
    /**
     * Uninitialize the hwaccel private data.
     *
     * This will be called from get_format() or avcodec_close(), after hwaccel
     * and hwaccel_context are already uninitialized.
     */
    pub uninit: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                               *mut AVCodecContext)
                                          -> libc::c_int>,
    /**
     * Size of the private data to allocate in
     * AVCodecInternal.hwaccel_priv_data.
     */
    pub priv_data_size: libc::c_int,
    /**
     * Internal hwaccel capabilities.
     */
    pub caps_internal: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVHWAccel() {
    assert_eq!(::std::mem::size_of::<AVHWAccel>() , 104usize , concat ! (
               "Size of: " , stringify ! ( AVHWAccel ) ));
    assert_eq! (::std::mem::align_of::<AVHWAccel>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVHWAccel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . id as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . pix_fmt as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( pix_fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . capabilities as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . next as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . alloc_frame as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( alloc_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . start_frame as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( start_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . decode_slice as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( decode_slice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . end_frame as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( end_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . frame_priv_data_size as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( frame_priv_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . decode_mb as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( decode_mb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . init as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . uninit as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( uninit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . priv_data_size as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( priv_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVHWAccel ) ) . caps_internal as * const
                _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( AVHWAccel ) , "::" ,
                stringify ! ( caps_internal ) ));
}
impl Clone for AVHWAccel {
    fn clone(&self) -> Self { *self }
}
/**
 * Picture data structure.
 *
 * Up to four components can be stored into it, the last component is
 * alpha.
 * @deprecated use AVFrame or imgutils functions instead
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVPicture {
    ///< pointers to the image data planes
    pub data: [*mut u8; 8usize],
    ///< number of bytes per line
    pub linesize: [libc::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_AVPicture() {
    assert_eq!(::std::mem::size_of::<AVPicture>() , 96usize , concat ! (
               "Size of: " , stringify ! ( AVPicture ) ));
    assert_eq! (::std::mem::align_of::<AVPicture>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVPicture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPicture ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPicture ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPicture ) ) . linesize as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPicture ) , "::" ,
                stringify ! ( linesize ) ));
}
impl Clone for AVPicture {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVSubtitleType {
    SUBTITLE_NONE = 0,
    SUBTITLE_BITMAP = 1,
    SUBTITLE_TEXT = 2,
    SUBTITLE_ASS = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVSubtitleRect {
    ///< top left corner  of pict, undefined when pict is not set
    pub x: libc::c_int,
    ///< top left corner  of pict, undefined when pict is not set
    pub y: libc::c_int,
    ///< width            of pict, undefined when pict is not set
    pub w: libc::c_int,
    ///< height           of pict, undefined when pict is not set
    pub h: libc::c_int,
    ///< number of colors in pict, undefined when pict is not set
    pub nb_colors: libc::c_int,
    /**
     * @deprecated unused
     */
    pub pict: AVPicture,
    /**
     * data+linesize for the bitmap of this subtitle.
     * Can be set for text/ass as well once they are rendered.
     */
    pub data: [*mut u8; 4usize],
    pub linesize: [libc::c_int; 4usize],
    pub type_: AVSubtitleType,
    ///< 0 terminated plain UTF-8 text
    pub text: *mut libc::c_char,
    /**
     * 0 terminated ASS/SSA compatible event line.
     * The presentation of this is unaffected by the other values in this
     * struct.
     */
    pub ass: *mut libc::c_char,
    pub flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVSubtitleRect() {
    assert_eq!(::std::mem::size_of::<AVSubtitleRect>() , 200usize , concat ! (
               "Size of: " , stringify ! ( AVSubtitleRect ) ));
    assert_eq! (::std::mem::align_of::<AVSubtitleRect>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVSubtitleRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . w as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . h as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . nb_colors as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( nb_colors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . pict as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( pict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . data as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . linesize as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( linesize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . type_ as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . text as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . ass as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( ass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVSubtitleRect ) ) . flags as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( AVSubtitleRect ) , "::"
                , stringify ! ( flags ) ));
}
impl Clone for AVSubtitleRect {
    fn clone(&self) -> Self { *self }
}
/**
 * This struct describes the properties of an encoded stream.
 *
 * sizeof(AVCodecParameters) is not a part of the public ABI, this struct must
 * be allocated with avcodec_parameters_alloc() and freed with
 * avcodec_parameters_free().
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVCodecParameters {
    /**
     * General type of the encoded data.
     */
    pub codec_type: AVMediaType,
    /**
     * Specific type of the encoded data (the codec used).
     */
    pub codec_id: AVCodecID,
    /**
     * Additional information about the codec (corresponds to the AVI FOURCC).
     */
    pub codec_tag: u32,
    /**
     * Extra binary data needed for initializing the decoder, codec-dependent.
     *
     * Must be allocated with av_malloc() and will be freed by
     * avcodec_parameters_free(). The allocated size of extradata must be at
     * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
     * bytes zeroed.
     */
    pub extradata: *mut u8,
    /**
     * Size of the extradata content in bytes.
     */
    pub extradata_size: libc::c_int,
    /**
     * - video: the pixel format, the value corresponds to enum AVPixelFormat.
     * - audio: the sample format, the value corresponds to enum AVSampleFormat.
     */
    pub format: libc::c_int,
    /**
     * The average bitrate of the encoded data (in bits per second).
     */
    pub bit_rate: i64,
    /**
     * The number of bits per sample in the codedwords.
     *
     * This is basically the bitrate per sample. It is mandatory for a bunch of
     * formats to actually decode them. It's the number of bits for one sample in
     * the actual coded bitstream.
     *
     * This could be for example 4 for ADPCM
     * For PCM formats this matches bits_per_raw_sample
     * Can be 0
     */
    pub bits_per_coded_sample: libc::c_int,
    /**
     * This is the number of valid bits in each output sample. If the
     * sample format has more bits, the least significant bits are additional
     * padding bits, which are always 0. Use right shifts to reduce the sample
     * to its actual size. For example, audio formats with 24 bit samples will
     * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
     * To get the original sample use "(int32_t)sample >> 8"."
     *
     * For ADPCM this might be 12 or 16 or similar
     * Can be 0
     */
    pub bits_per_raw_sample: libc::c_int,
    /**
     * Codec-specific bitstream restrictions that the stream conforms to.
     */
    pub profile: libc::c_int,
    pub level: libc::c_int,
    /**
     * Video only. The dimensions of the video frame in pixels.
     */
    pub width: libc::c_int,
    pub height: libc::c_int,
    /**
     * Video only. The aspect ratio (width / height) which a single pixel
     * should have when displayed.
     *
     * When the aspect ratio is unknown / undefined, the numerator should be
     * set to 0 (the denominator may have any value).
     */
    pub sample_aspect_ratio: AVRational,
    /**
     * Video only. The order of the fields in interlaced video.
     */
    pub field_order: AVFieldOrder,
    /**
     * Video only. Additional colorspace characteristics.
     */
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    /**
     * Video only. Number of delayed frames.
     */
    pub video_delay: libc::c_int,
    /**
     * Audio only. The channel layout bitmask. May be 0 if the channel layout is
     * unknown or unspecified, otherwise the number of bits set must be equal to
     * the channels field.
     */
    pub channel_layout: u64,
    /**
     * Audio only. The number of audio channels.
     */
    pub channels: libc::c_int,
    /**
     * Audio only. The number of audio samples per second.
     */
    pub sample_rate: libc::c_int,
    /**
     * Audio only. The number of bytes per coded audio frame, required by some
     * formats.
     *
     * Corresponds to nBlockAlign in WAVEFORMATEX.
     */
    pub block_align: libc::c_int,
    /**
     * Audio only. Audio frame size, if known. Required by some formats to be static.
     */
    pub frame_size: libc::c_int,
    /**
     * Audio only. The amount of padding (in samples) inserted by the encoder at
     * the beginning of the audio. I.e. this number of leading decoded samples
     * must be discarded by the caller to get the original audio without leading
     * padding.
     */
    pub initial_padding: libc::c_int,
    /**
     * Audio only. The amount of padding (in samples) appended by the encoder to
     * the end of the audio. I.e. this number of decoded samples must be
     * discarded by the caller from the end of the stream to get the original
     * audio without any trailing padding.
     */
    pub trailing_padding: libc::c_int,
    /**
     * Audio only. Number of samples to skip after a discontinuity.
     */
    pub seek_preroll: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParameters() {
    assert_eq!(::std::mem::size_of::<AVCodecParameters>() , 144usize , concat
               ! ( "Size of: " , stringify ! ( AVCodecParameters ) ));
    assert_eq! (::std::mem::align_of::<AVCodecParameters>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AVCodecParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . codec_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( codec_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . codec_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( codec_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . codec_tag as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( codec_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . extradata as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( extradata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . extradata_size as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( extradata_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . format as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . bit_rate as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( bit_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) .
                bits_per_coded_sample as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( bits_per_coded_sample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) .
                bits_per_raw_sample as * const _ as usize } , 44usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( bits_per_raw_sample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . profile as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( profile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . level as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . width as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . height as * const
                _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) .
                sample_aspect_ratio as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( sample_aspect_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . field_order as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( field_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . color_range as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( color_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . color_primaries
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( color_primaries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . color_trc as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( color_trc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . color_space as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( color_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . chroma_location
                as * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( chroma_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . video_delay as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( video_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . channel_layout as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( channel_layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . channels as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . sample_rate as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( sample_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . block_align as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( block_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . frame_size as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . initial_padding
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( initial_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . trailing_padding
                as * const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( trailing_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParameters ) ) . seek_preroll as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParameters ) ,
                "::" , stringify ! ( seek_preroll ) ));
}
impl Clone for AVCodecParameters {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * If c is NULL, returns the first registered codec,
 * if c is non-NULL, returns the next registered codec after c,
 * or NULL if c is the last one.
 */
    pub fn av_codec_next(c: *const AVCodec) -> *mut AVCodec;
}
extern "C" {
    /**
 * Return the LIBAVCODEC_VERSION_INT constant.
 */
    pub fn avcodec_version() -> libc::c_uint;
}
extern "C" {
    /**
 * Return the libavcodec build-time configuration.
 */
    pub fn avcodec_configuration() -> *const libc::c_char;
}
extern "C" {
    /**
 * Return the libavcodec license.
 */
    pub fn avcodec_license() -> *const libc::c_char;
}
extern "C" {
    /**
 * Register the codec codec and initialize libavcodec.
 *
 * @warning either this function or avcodec_register_all() must be called
 * before any other libavcodec functions.
 *
 * @see avcodec_register_all()
 */
    pub fn avcodec_register(codec: *mut AVCodec);
}
extern "C" {
    /**
 * Register all the codecs, parsers and bitstream filters which were enabled at
 * configuration time. If you do not call this function you can select exactly
 * which formats you want to support, by using the individual registration
 * functions.
 *
 * @see avcodec_register
 * @see av_register_codec_parser
 * @see av_register_bitstream_filter
 */
    pub fn avcodec_register_all();
}
extern "C" {
    /**
 * Allocate an AVCodecContext and set its fields to default values. The
 * resulting struct should be freed with avcodec_free_context().
 *
 * @param codec if non-NULL, allocate private data and initialize defaults
 *              for the given codec. It is illegal to then call avcodec_open2()
 *              with a different codec.
 *              If NULL, then the codec-specific defaults won't be initialized,
 *              which may result in suboptimal default settings (this is
 *              important mainly for encoders, e.g. libx264).
 *
 * @return An AVCodecContext filled with default values or NULL on failure.
 */
    pub fn avcodec_alloc_context3(codec: *const AVCodec)
     -> *mut AVCodecContext;
}
extern "C" {
    /**
 * Free the codec context and everything associated with it and write NULL to
 * the provided pointer.
 */
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    /**
 * @deprecated This function should not be used, as closing and opening a codec
 * context multiple time is not supported. A new codec context should be
 * allocated for each new use.
 */
    pub fn avcodec_get_context_defaults3(s: *mut AVCodecContext,
                                         codec: *const AVCodec)
     -> libc::c_int;
}
extern "C" {
    /**
 * Get the AVClass for AVCodecContext. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    /**
 * Get the AVClass for AVFrame. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
    pub fn avcodec_get_frame_class() -> *const AVClass;
}
extern "C" {
    /**
 * Get the AVClass for AVSubtitleRect. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    /**
 * Copy the settings of the source AVCodecContext into the destination
 * AVCodecContext. The resulting destination codec context will be
 * unopened, i.e. you are required to call avcodec_open2() before you
 * can use this AVCodecContext to decode/encode video/audio data.
 *
 * @param dest target codec context, should be initialized with
 *             avcodec_alloc_context3(NULL), but otherwise uninitialized
 * @param src source codec context
 * @return AVERROR() on error (e.g. memory allocation error), 0 on success
 *
 * @deprecated The semantics of this function are ill-defined and it should not
 * be used. If you need to transfer the stream parameters from one codec context
 * to another, use an intermediate AVCodecParameters instance and the
 * avcodec_parameters_from_context() / avcodec_parameters_to_context()
 * functions.
 */
    pub fn avcodec_copy_context(dest: *mut AVCodecContext,
                                src: *const AVCodecContext) -> libc::c_int;
}
extern "C" {
    /**
 * Allocate a new AVCodecParameters and set its fields to default values
 * (unknown/invalid/0). The returned struct must be freed with
 * avcodec_parameters_free().
 */
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    /**
 * Free an AVCodecParameters instance and everything associated with it and
 * write NULL to the supplied pointer.
 */
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    /**
 * Copy the contents of src to dst. Any allocated fields in dst are freed and
 * replaced with newly allocated duplicates of the corresponding fields in src.
 *
 * @return >= 0 on success, a negative AVERROR code on failure.
 */
    pub fn avcodec_parameters_copy(dst: *mut AVCodecParameters,
                                   src: *const AVCodecParameters)
     -> libc::c_int;
}
extern "C" {
    /**
 * Fill the parameters struct based on the values from the supplied codec
 * context. Any allocated fields in par are freed and replaced with duplicates
 * of the corresponding fields in codec.
 *
 * @return >= 0 on success, a negative AVERROR code on failure
 */
    pub fn avcodec_parameters_from_context(par: *mut AVCodecParameters,
                                           codec: *const AVCodecContext)
     -> libc::c_int;
}
extern "C" {
    /**
 * Fill the codec context based on the values from the supplied codec
 * parameters. Any allocated fields in codec that have a corresponding field in
 * par are freed and replaced with duplicates of the corresponding field in par.
 * Fields in codec that do not have a counterpart in par are not touched.
 *
 * @return >= 0 on success, a negative AVERROR code on failure.
 */
    pub fn avcodec_parameters_to_context(codec: *mut AVCodecContext,
                                         par: *const AVCodecParameters)
     -> libc::c_int;
}
extern "C" {
    /**
 * Initialize the AVCodecContext to use the given AVCodec. Prior to using this
 * function the context has to be allocated with avcodec_alloc_context3().
 *
 * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
 * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
 * retrieving a codec.
 *
 * @warning This function is not thread safe!
 *
 * @note Always call this function before using decoding routines (such as
 * @ref avcodec_receive_frame()).
 *
 * @code
 * avcodec_register_all();
 * av_dict_set(&opts, "b", "2.5M", 0);
 * codec = avcodec_find_decoder(AV_CODEC_ID_H264);
 * if (!codec)
 *     exit(1);
 *
 * context = avcodec_alloc_context3(codec);
 *
 * if (avcodec_open2(context, codec, opts) < 0)
 *     exit(1);
 * @endcode
 *
 * @param avctx The context to initialize.
 * @param codec The codec to open this context for. If a non-NULL codec has been
 *              previously passed to avcodec_alloc_context3() or
 *              for this context, then this parameter MUST be either NULL or
 *              equal to the previously passed codec.
 * @param options A dictionary filled with AVCodecContext and codec-private options.
 *                On return this object will be filled with options that were not found.
 *
 * @return zero on success, a negative value on error
 * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
 *      av_dict_set(), av_opt_find().
 */
    pub fn avcodec_open2(avctx: *mut AVCodecContext, codec: *const AVCodec,
                         options: *mut *mut AVDictionary) -> libc::c_int;
}
extern "C" {
    /**
 * Close a given AVCodecContext and free all the data associated with it
 * (but not the AVCodecContext itself).
 *
 * Calling this function on an AVCodecContext that hasn't been opened will free
 * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
 * codec. Subsequent calls will do nothing.
 *
 * @note Do not use this function. Use avcodec_free_context() to destroy a
 * codec context (either open or closed). Opening and closing a codec context
 * multiple times is not supported anymore -- use multiple codec contexts
 * instead.
 */
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> libc::c_int;
}
extern "C" {
    /**
 * Free all allocated data in the given subtitle struct.
 *
 * @param sub AVSubtitle to free.
 */
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    /**
 * Allocate an AVPacket and set its fields to default values.  The resulting
 * struct must be freed using av_packet_free().
 *
 * @return An AVPacket filled with default values or NULL on failure.
 *
 * @note this only allocates the AVPacket itself, not the data buffers. Those
 * must be allocated through other means such as av_new_packet.
 *
 * @see av_new_packet
 */
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    /**
 * Create a new packet that references the same data as src.
 *
 * This is a shortcut for av_packet_alloc()+av_packet_ref().
 *
 * @return newly created AVPacket on success, NULL on error.
 *
 * @see av_packet_alloc
 * @see av_packet_ref
 */
    pub fn av_packet_clone(src: *const AVPacket) -> *mut AVPacket;
}
extern "C" {
    /**
 * Free the packet, if the packet is reference counted, it will be
 * unreferenced first.
 *
 * @param packet packet to be freed. The pointer will be set to NULL.
 * @note passing NULL is a no-op.
 */
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    /**
 * Initialize optional fields of a packet with default values.
 *
 * Note, this does not touch the data and size members, which have to be
 * initialized separately.
 *
 * @param pkt packet
 */
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    /**
 * Allocate the payload of a packet and initialize its fields with
 * default values.
 *
 * @param pkt packet
 * @param size wanted payload size
 * @return 0 if OK, AVERROR_xxx otherwise
 */
    pub fn av_new_packet(pkt: *mut AVPacket, size: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Reduce packet size, correctly zeroing padding
 *
 * @param pkt packet
 * @param size new size
 */
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: libc::c_int);
}
extern "C" {
    /**
 * Increase packet size, correctly zeroing padding
 *
 * @param pkt packet
 * @param grow_by number of bytes by which to increase the size of the packet
 */
    pub fn av_grow_packet(pkt: *mut AVPacket, grow_by: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Initialize a reference-counted packet from av_malloc()ed data.
 *
 * @param pkt packet to be initialized. This function will set the data, size,
 *        buf and destruct fields, all others are left untouched.
 * @param data Data allocated by av_malloc() to be used as packet data. If this
 *        function returns successfully, the data is owned by the underlying AVBuffer.
 *        The caller may not access the data through other means.
 * @param size size of data in bytes, without the padding. I.e. the full buffer
 *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
 *
 * @return 0 on success, a negative AVERROR on error
 */
    pub fn av_packet_from_data(pkt: *mut AVPacket, data: *mut u8,
                               size: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * @warning This is a hack - the packet memory allocation stuff is broken. The
 * packet is allocated if it was not really allocated.
 *
 * @deprecated Use av_packet_ref
 */
    pub fn av_dup_packet(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /**
 * Copy packet, including contents
 *
 * @return 0 on success, negative AVERROR on fail
 */
    pub fn av_copy_packet(dst: *mut AVPacket, src: *const AVPacket)
     -> libc::c_int;
}
extern "C" {
    /**
 * Copy packet side data
 *
 * @return 0 on success, negative AVERROR on fail
 */
    pub fn av_copy_packet_side_data(dst: *mut AVPacket, src: *const AVPacket)
     -> libc::c_int;
}
extern "C" {
    /**
 * Free a packet.
 *
 * @deprecated Use av_packet_unref
 *
 * @param pkt packet to free
 */
    pub fn av_free_packet(pkt: *mut AVPacket);
}
extern "C" {
    /**
 * Allocate new information of a packet.
 *
 * @param pkt packet
 * @param type side information type
 * @param size side information size
 * @return pointer to fresh allocated data or NULL otherwise
 */
    pub fn av_packet_new_side_data(pkt: *mut AVPacket,
                                   type_: AVPacketSideDataType,
                                   size: libc::c_int) -> *mut u8;
}
extern "C" {
    /**
 * Wrap an existing array as a packet side data.
 *
 * @param pkt packet
 * @param type side information type
 * @param data the side data array. It must be allocated with the av_malloc()
 *             family of functions. The ownership of the data is transferred to
 *             pkt.
 * @param size side information size
 * @return a non-negative number on success, a negative AVERROR code on
 *         failure. On failure, the packet is unchanged and the data remains
 *         owned by the caller.
 */
    pub fn av_packet_add_side_data(pkt: *mut AVPacket,
                                   type_: AVPacketSideDataType, data: *mut u8,
                                   size: usize) -> libc::c_int;
}
extern "C" {
    /**
 * Shrink the already allocated side data buffer
 *
 * @param pkt packet
 * @param type side information type
 * @param size new side information size
 * @return 0 on success, < 0 on failure
 */
    pub fn av_packet_shrink_side_data(pkt: *mut AVPacket,
                                      type_: AVPacketSideDataType,
                                      size: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Get side information from packet.
 *
 * @param pkt packet
 * @param type desired side information type
 * @param size pointer for side information size to store (optional)
 * @return pointer to data if present or NULL otherwise
 */
    pub fn av_packet_get_side_data(pkt: *const AVPacket,
                                   type_: AVPacketSideDataType,
                                   size: *mut libc::c_int) -> *mut u8;
}
extern "C" {
    pub fn av_packet_merge_side_data(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_packet_split_side_data(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType)
     -> *const libc::c_char;
}
extern "C" {
    /**
 * Pack a dictionary for use in side_data.
 *
 * @param dict The dictionary to pack.
 * @param size pointer to store the size of the returned data
 * @return pointer to data if successful, NULL otherwise
 */
    pub fn av_packet_pack_dictionary(dict: *mut AVDictionary,
                                     size: *mut libc::c_int) -> *mut u8;
}
extern "C" {
    /**
 * Unpack a dictionary from side_data.
 *
 * @param data data from side_data
 * @param size size of the data
 * @param dict the metadata storage dictionary
 * @return 0 on success, < 0 on failure
 */
    pub fn av_packet_unpack_dictionary(data: *const u8, size: libc::c_int,
                                       dict: *mut *mut AVDictionary)
     -> libc::c_int;
}
extern "C" {
    /**
 * Convenience function to free all the side data stored.
 * All the other fields stay untouched.
 *
 * @param pkt packet
 */
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    /**
 * Setup a new reference to the data described by a given packet
 *
 * If src is reference-counted, setup dst as a new reference to the
 * buffer in src. Otherwise allocate a new buffer in dst and copy the
 * data from src into it.
 *
 * All the other fields are copied from src.
 *
 * @see av_packet_unref
 *
 * @param dst Destination packet
 * @param src Source packet
 *
 * @return 0 on success, a negative AVERROR on error.
 */
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket)
     -> libc::c_int;
}
extern "C" {
    /**
 * Wipe the packet.
 *
 * Unreference the buffer referenced by the packet and reset the
 * remaining packet fields to their default values.
 *
 * @param pkt The packet to be unreferenced.
 */
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    /**
 * Move every field in src to dst and reset src.
 *
 * @see av_packet_unref
 *
 * @param src Source packet, will be reset
 * @param dst Destination packet
 */
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    /**
 * Copy only "properties" fields from src to dst.
 *
 * Properties for the purpose of this function are all the fields
 * beside those related to the packet data (buf, data, size)
 *
 * @param dst Destination packet
 * @param src Source packet
 *
 * @return 0 on success AVERROR on failure.
 */
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket)
     -> libc::c_int;
}
extern "C" {
    /**
 * Convert valid timing fields (timestamps / durations) in a packet from one
 * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
 * ignored.
 *
 * @param pkt packet on which the conversion will be performed
 * @param tb_src source timebase, in which the timing fields in pkt are
 *               expressed
 * @param tb_dst destination timebase, to which the timing fields will be
 *               converted
 */
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational,
                                tb_dst: AVRational);
}
extern "C" {
    /**
 * Find a registered decoder with a matching codec ID.
 *
 * @param id AVCodecID of the requested decoder
 * @return A decoder if one was found, NULL otherwise.
 */
    pub fn avcodec_find_decoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    /**
 * Find a registered decoder with the specified name.
 *
 * @param name name of the requested decoder
 * @return A decoder if one was found, NULL otherwise.
 */
    pub fn avcodec_find_decoder_by_name(name: *const libc::c_char)
     -> *mut AVCodec;
}
extern "C" {
    /**
 * The default callback for AVCodecContext.get_buffer2(). It is made public so
 * it can be called by custom get_buffer2() implementations for decoders without
 * AV_CODEC_CAP_DR1 set.
 */
    pub fn avcodec_default_get_buffer2(s: *mut AVCodecContext,
                                       frame: *mut AVFrame,
                                       flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Return the amount of padding in pixels which the get_buffer callback must
 * provide around the edge of the image for codecs which do not have the
 * CODEC_FLAG_EMU_EDGE flag.
 *
 * @return Required padding in pixels.
 *
 * @deprecated CODEC_FLAG_EMU_EDGE is deprecated, so this function is no longer
 * needed
 */
    pub fn avcodec_get_edge_width() -> libc::c_uint;
}
extern "C" {
    /**
 * Modify width and height values so that they will result in a memory
 * buffer that is acceptable for the codec if you do not use any horizontal
 * padding.
 *
 * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
 */
    pub fn avcodec_align_dimensions(s: *mut AVCodecContext,
                                    width: *mut libc::c_int,
                                    height: *mut libc::c_int);
}
extern "C" {
    /**
 * Modify width and height values so that they will result in a memory
 * buffer that is acceptable for the codec if you also ensure that all
 * line sizes are a multiple of the respective linesize_align[i].
 *
 * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
 */
    pub fn avcodec_align_dimensions2(s: *mut AVCodecContext,
                                     width: *mut libc::c_int,
                                     height: *mut libc::c_int,
                                     linesize_align: *mut libc::c_int);
}
extern "C" {
    /**
 * Converts AVChromaLocation to swscale x/y chroma position.
 *
 * The positions represent the chroma (0,0) position in a coordinates system
 * with luma (0,0) representing the origin and luma(1,1) representing 256,256
 *
 * @param xpos  horizontal chroma sample position
 * @param ypos  vertical   chroma sample position
 */
    pub fn avcodec_enum_to_chroma_pos(xpos: *mut libc::c_int,
                                      ypos: *mut libc::c_int,
                                      pos: AVChromaLocation) -> libc::c_int;
}
extern "C" {
    /**
 * Converts swscale x/y chroma position to AVChromaLocation.
 *
 * The positions represent the chroma (0,0) position in a coordinates system
 * with luma (0,0) representing the origin and luma(1,1) representing 256,256
 *
 * @param xpos  horizontal chroma sample position
 * @param ypos  vertical   chroma sample position
 */
    pub fn avcodec_chroma_pos_to_enum(xpos: libc::c_int, ypos: libc::c_int)
     -> AVChromaLocation;
}
extern "C" {
    /**
 * Decode the audio frame of size avpkt->size from avpkt->data into frame.
 *
 * Some decoders may support multiple frames in a single AVPacket. Such
 * decoders would then just decode the first frame and the return value would be
 * less than the packet size. In this case, avcodec_decode_audio4 has to be
 * called again with an AVPacket containing the remaining data in order to
 * decode the second frame, etc...  Even if no frames are returned, the packet
 * needs to be fed to the decoder with remaining data until it is completely
 * consumed or an error occurs.
 *
 * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
 * and output. This means that for some packets they will not immediately
 * produce decoded output and need to be flushed at the end of decoding to get
 * all the decoded data. Flushing is done by calling this function with packets
 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
 * returning samples. It is safe to flush even those decoders that are not
 * marked with AV_CODEC_CAP_DELAY, then no samples will be returned.
 *
 * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
 *          larger than the actual read bytes because some optimized bitstream
 *          readers read 32 or 64 bits at once and could read over the end.
 *
 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
 * before packets may be fed to the decoder.
 *
 * @param      avctx the codec context
 * @param[out] frame The AVFrame in which to store decoded audio samples.
 *                   The decoder will allocate a buffer for the decoded frame by
 *                   calling the AVCodecContext.get_buffer2() callback.
 *                   When AVCodecContext.refcounted_frames is set to 1, the frame is
 *                   reference counted and the returned reference belongs to the
 *                   caller. The caller must release the frame using av_frame_unref()
 *                   when the frame is no longer needed. The caller may safely write
 *                   to the frame if av_frame_is_writable() returns 1.
 *                   When AVCodecContext.refcounted_frames is set to 0, the returned
 *                   reference belongs to the decoder and is valid only until the
 *                   next call to this function or until closing or flushing the
 *                   decoder. The caller may not write to it.
 * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
 *                           non-zero. Note that this field being set to zero
 *                           does not mean that an error has occurred. For
 *                           decoders with AV_CODEC_CAP_DELAY set, no given decode
 *                           call is guaranteed to produce a frame.
 * @param[in]  avpkt The input AVPacket containing the input buffer.
 *                   At least avpkt->data and avpkt->size should be set. Some
 *                   decoders might also require additional fields to be set.
 * @return A negative error code is returned if an error occurred during
 *         decoding, otherwise the number of bytes consumed from the input
 *         AVPacket is returned.
 *
* @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
 */
    pub fn avcodec_decode_audio4(avctx: *mut AVCodecContext,
                                 frame: *mut AVFrame,
                                 got_frame_ptr: *mut libc::c_int,
                                 avpkt: *const AVPacket) -> libc::c_int;
}
extern "C" {
    /**
 * Decode the video frame of size avpkt->size from avpkt->data into picture.
 * Some decoders may support multiple frames in a single AVPacket, such
 * decoders would then just decode the first frame.
 *
 * @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than
 * the actual read bytes because some optimized bitstream readers read 32 or 64
 * bits at once and could read over the end.
 *
 * @warning The end of the input buffer buf should be set to 0 to ensure that
 * no overreading happens for damaged MPEG streams.
 *
 * @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay
 * between input and output, these need to be fed with avpkt->data=NULL,
 * avpkt->size=0 at the end to return the remaining frames.
 *
 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
 * before packets may be fed to the decoder.
 *
 * @param avctx the codec context
 * @param[out] picture The AVFrame in which the decoded video frame will be stored.
 *             Use av_frame_alloc() to get an AVFrame. The codec will
 *             allocate memory for the actual bitmap by calling the
 *             AVCodecContext.get_buffer2() callback.
 *             When AVCodecContext.refcounted_frames is set to 1, the frame is
 *             reference counted and the returned reference belongs to the
 *             caller. The caller must release the frame using av_frame_unref()
 *             when the frame is no longer needed. The caller may safely write
 *             to the frame if av_frame_is_writable() returns 1.
 *             When AVCodecContext.refcounted_frames is set to 0, the returned
 *             reference belongs to the decoder and is valid only until the
 *             next call to this function or until closing or flushing the
 *             decoder. The caller may not write to it.
 *
 * @param[in] avpkt The input AVPacket containing the input buffer.
 *            You can create such packet with av_init_packet() and by then setting
 *            data and size, some decoders might in addition need other fields like
 *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
 *            fields possible.
 * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
 * @return On error a negative value is returned, otherwise the number of bytes
 * used or zero if no frame could be decompressed.
 *
 * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
 */
    pub fn avcodec_decode_video2(avctx: *mut AVCodecContext,
                                 picture: *mut AVFrame,
                                 got_picture_ptr: *mut libc::c_int,
                                 avpkt: *const AVPacket) -> libc::c_int;
}
extern "C" {
    /**
 * Decode a subtitle message.
 * Return a negative value on error, otherwise return the number of bytes used.
 * If no subtitle could be decompressed, got_sub_ptr is zero.
 * Otherwise, the subtitle is stored in *sub.
 * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
 * simplicity, because the performance difference is expect to be negligible
 * and reusing a get_buffer written for video codecs would probably perform badly
 * due to a potentially very different allocation pattern.
 *
 * Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input
 * and output. This means that for some packets they will not immediately
 * produce decoded output and need to be flushed at the end of decoding to get
 * all the decoded data. Flushing is done by calling this function with packets
 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
 * returning subtitles. It is safe to flush even those decoders that are not
 * marked with CODEC_CAP_DELAY, then no subtitles will be returned.
 *
 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
 * before packets may be fed to the decoder.
 *
 * @param avctx the codec context
 * @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,
 *                 must be freed with avsubtitle_free if *got_sub_ptr is set.
 * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.
 * @param[in] avpkt The input AVPacket containing the input buffer.
 */
    pub fn avcodec_decode_subtitle2(avctx: *mut AVCodecContext,
                                    sub: *mut AVSubtitle,
                                    got_sub_ptr: *mut libc::c_int,
                                    avpkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /**
 * Supply raw packet data as input to a decoder.
 *
 * Internally, this call will copy relevant AVCodecContext fields, which can
 * influence decoding per-packet, and apply them when the packet is actually
 * decoded. (For example AVCodecContext.skip_frame, which might direct the
 * decoder to drop the frame contained by the packet sent with this function.)
 *
 * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
 *          larger than the actual read bytes because some optimized bitstream
 *          readers read 32 or 64 bits at once and could read over the end.
 *
 * @warning Do not mix this API with the legacy API (like avcodec_decode_video2())
 *          on the same AVCodecContext. It will return unexpected results now
 *          or in future libavcodec versions.
 *
 * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
 *       before packets may be fed to the decoder.
 *
 * @param avctx codec context
 * @param[in] avpkt The input AVPacket. Usually, this will be a single video
 *                  frame, or several complete audio frames.
 *                  Ownership of the packet remains with the caller, and the
 *                  decoder will not write to the packet. The decoder may create
 *                  a reference to the packet data (or copy it if the packet is
 *                  not reference-counted).
 *                  Unlike with older APIs, the packet is always fully consumed,
 *                  and if it contains multiple frames (e.g. some audio codecs),
 *                  will require you to call avcodec_receive_frame() multiple
 *                  times afterwards before you can send a new packet.
 *                  It can be NULL (or an AVPacket with data set to NULL and
 *                  size set to 0); in this case, it is considered a flush
 *                  packet, which signals the end of the stream. Sending the
 *                  first flush packet will return success. Subsequent ones are
 *                  unnecessary and will return AVERROR_EOF. If the decoder
 *                  still has frames buffered, it will return them after sending
 *                  a flush packet.
 *
 * @return 0 on success, otherwise negative error code:
 *      AVERROR(EAGAIN):   input is not accepted in the current state - user
 *                         must read output with avcodec_receive_frame() (once
 *                         all output is read, the packet should be resent, and
 *                         the call will not fail with EAGAIN).
 *      AVERROR_EOF:       the decoder has been flushed, and no new packets can
 *                         be sent to it (also returned if more than 1 flush
 *                         packet is sent)
 *      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush
 *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
 *      other errors: legitimate decoding errors
 */
    pub fn avcodec_send_packet(avctx: *mut AVCodecContext,
                               avpkt: *const AVPacket) -> libc::c_int;
}
extern "C" {
    /**
 * Return decoded output data from a decoder.
 *
 * @param avctx codec context
 * @param frame This will be set to a reference-counted video or audio
 *              frame (depending on the decoder type) allocated by the
 *              decoder. Note that the function will always call
 *              av_frame_unref(frame) before doing anything else.
 *
 * @return
 *      0:                 success, a frame was returned
 *      AVERROR(EAGAIN):   output is not available in this state - user must try
 *                         to send new input
 *      AVERROR_EOF:       the decoder has been fully flushed, and there will be
 *                         no more output frames
 *      AVERROR(EINVAL):   codec not opened, or it is an encoder
 *      other negative values: legitimate decoding errors
 */
    pub fn avcodec_receive_frame(avctx: *mut AVCodecContext,
                                 frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /**
 * Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
 * to retrieve buffered output packets.
 *
 * @param avctx     codec context
 * @param[in] frame AVFrame containing the raw audio or video frame to be encoded.
 *                  Ownership of the frame remains with the caller, and the
 *                  encoder will not write to the frame. The encoder may create
 *                  a reference to the frame data (or copy it if the frame is
 *                  not reference-counted).
 *                  It can be NULL, in which case it is considered a flush
 *                  packet.  This signals the end of the stream. If the encoder
 *                  still has packets buffered, it will return them after this
 *                  call. Once flushing mode has been entered, additional flush
 *                  packets are ignored, and sending frames will return
 *                  AVERROR_EOF.
 *
 *                  For audio:
 *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
 *                  can have any number of samples.
 *                  If it is not set, frame->nb_samples must be equal to
 *                  avctx->frame_size for all frames except the last.
 *                  The final frame may be smaller than avctx->frame_size.
 * @return 0 on success, otherwise negative error code:
 *      AVERROR(EAGAIN):   input is not accepted in the current state - user
 *                         must read output with avcodec_receive_packet() (once
 *                         all output is read, the packet should be resent, and
 *                         the call will not fail with EAGAIN).
 *      AVERROR_EOF:       the encoder has been flushed, and no new frames can
 *                         be sent to it
 *      AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a
 *                         decoder, or requires flush
 *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
 *      other errors: legitimate decoding errors
 */
    pub fn avcodec_send_frame(avctx: *mut AVCodecContext,
                              frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    /**
 * Read encoded data from the encoder.
 *
 * @param avctx codec context
 * @param avpkt This will be set to a reference-counted packet allocated by the
 *              encoder. Note that the function will always call
 *              av_frame_unref(frame) before doing anything else.
 * @return 0 on success, otherwise negative error code:
 *      AVERROR(EAGAIN):   output is not available in the current state - user
 *                         must try to send input
 *      AVERROR_EOF:       the encoder has been fully flushed, and there will be
 *                         no more output packets
 *      AVERROR(EINVAL):   codec not opened, or it is an encoder
 *      other errors: legitimate decoding errors
 */
    pub fn avcodec_receive_packet(avctx: *mut AVCodecContext,
                                  avpkt: *mut AVPacket) -> libc::c_int;
}
#[repr(u32)]
/**
 * @defgroup lavc_parsing Frame parsing
 * @{
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVPictureStructure {
    AV_PICTURE_STRUCTURE_UNKNOWN = 0,
    AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
    AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
    AV_PICTURE_STRUCTURE_FRAME = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVCodecParserContext {
    pub priv_data: *mut libc::c_void,
    pub parser: *mut AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: libc::c_int,
    /**
     * This field is used for proper frame duration computation in lavf.
     * It signals, how much longer the frame duration of the current frame
     * is compared to normal frame duration.
     *
     * frame_duration = (1 + repeat_pict) * time_base
     *
     * It is used by codecs like H.264 to display telecined material.
     */
    pub repeat_pict: libc::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: libc::c_int,
    pub cur_frame_start_index: libc::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: libc::c_int,
    ///< byte offset from starting packet start
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    /**
     * Set by parser to 1 for key frames and 0 for non-key frames.
     * It is initialized to -1, so if the parser doesn't set this flag,
     * old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
     * will be used.
     */
    pub key_frame: libc::c_int,
    /**
     * @deprecated unused
     */
    pub convergence_duration: i64,
    /**
     * Synchronization point for start of timestamp generation.
     *
     * Set to >0 for sync point, 0 for no sync point and <0 for undefined
     * (default).
     *
     * For example, this corresponds to presence of H.264 buffering period
     * SEI message.
     */
    pub dts_sync_point: libc::c_int,
    /**
     * Offset of the current timestamp against last timestamp sync point in
     * units of AVCodecContext.time_base.
     *
     * Set to INT_MIN when dts_sync_point unused. Otherwise, it must
     * contain a valid timestamp offset.
     *
     * Note that the timestamp of sync point has usually a nonzero
     * dts_ref_dts_delta, which refers to the previous sync point. Offset of
     * the next frame after timestamp sync point will be usually 1.
     *
     * For example, this corresponds to H.264 cpb_removal_delay.
     */
    pub dts_ref_dts_delta: libc::c_int,
    /**
     * Presentation delay of current frame in units of AVCodecContext.time_base.
     *
     * Set to INT_MIN when dts_sync_point unused. Otherwise, it must
     * contain valid non-negative timestamp delta (presentation time of a frame
     * must not lie in the past).
     *
     * This delay represents the difference between decoding and presentation
     * time of the frame.
     *
     * For example, this corresponds to H.264 dpb_output_delay.
     */
    pub pts_dts_delta: libc::c_int,
    /**
     * Position of the packet in file.
     *
     * Analogous to cur_frame_pts/dts
     */
    pub cur_frame_pos: [i64; 4usize],
    /**
     * Byte position of currently parsed frame in stream.
     */
    pub pos: i64,
    /**
     * Previous frame byte position.
     */
    pub last_pos: i64,
    /**
     * Duration of the current frame.
     * For audio, this is in units of 1 / AVCodecContext.sample_rate.
     * For all other types, this is in units of AVCodecContext.time_base.
     */
    pub duration: libc::c_int,
    pub field_order: AVFieldOrder,
    /**
     * Indicate whether a picture is coded as a frame, top field or bottom field.
     *
     * For example, H.264 field_pic_flag equal to 0 corresponds to
     * AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
     * equal to 1 and bottom_field_flag equal to 0 corresponds to
     * AV_PICTURE_STRUCTURE_TOP_FIELD.
     */
    pub picture_structure: AVPictureStructure,
    /**
     * Picture number incremented in presentation or output order.
     * This field may be reinitialized at the first picture of a new sequence.
     *
     * For example, this corresponds to H.264 PicOrderCnt.
     */
    pub output_picture_number: libc::c_int,
    /**
     * Dimensions of the decoded video intended for presentation.
     */
    pub width: libc::c_int,
    pub height: libc::c_int,
    /**
     * Dimensions of the coded video.
     */
    pub coded_width: libc::c_int,
    pub coded_height: libc::c_int,
    /**
     * The format of the coded data, corresponds to enum AVPixelFormat for video
     * and for enum AVSampleFormat for audio.
     *
     * Note that a decoder can have considerable freedom in how exactly it
     * decodes the data, so the format reported here might be different from the
     * one returned by a decoder.
     */
    pub format: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParserContext() {
    assert_eq!(::std::mem::size_of::<AVCodecParserContext>() , 352usize ,
               concat ! ( "Size of: " , stringify ! ( AVCodecParserContext )
               ));
    assert_eq! (::std::mem::align_of::<AVCodecParserContext>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AVCodecParserContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . priv_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( priv_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . parser as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( parser ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . frame_offset
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( frame_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . cur_offset as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( cur_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) .
                next_frame_offset as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( next_frame_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . pict_type as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( pict_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . repeat_pict as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( repeat_pict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . pts as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . dts as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . last_pts as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( last_pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . last_dts as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( last_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) .
                fetch_timestamp as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( fetch_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) .
                cur_frame_start_index as * const _ as usize } , 84usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( cur_frame_start_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) .
                cur_frame_offset as * const _ as usize } , 88usize , concat !
                (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( cur_frame_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_pts
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( cur_frame_pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_dts
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( cur_frame_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . flags as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . offset as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_end
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( cur_frame_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . key_frame as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( key_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) .
                convergence_duration as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( convergence_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . dts_sync_point
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( dts_sync_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) .
                dts_ref_dts_delta as * const _ as usize } , 252usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( dts_ref_dts_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . pts_dts_delta
                as * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( pts_dts_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . cur_frame_pos
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( cur_frame_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . pos as * const
                _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . last_pos as *
                const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( last_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . duration as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . field_order as
                * const _ as usize } , 316usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( field_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) .
                picture_structure as * const _ as usize } , 320usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( picture_structure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) .
                output_picture_number as * const _ as usize } , 324usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( output_picture_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . width as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . height as *
                const _ as usize } , 332usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . coded_width as
                * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( coded_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . coded_height
                as * const _ as usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( coded_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParserContext ) ) . format as *
                const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParserContext )
                , "::" , stringify ! ( format ) ));
}
impl Clone for AVCodecParserContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVCodecParser {
    pub codec_ids: [libc::c_int; 5usize],
    pub priv_data_size: libc::c_int,
    pub parser_init: ::std::option::Option<unsafe extern "C" fn(s:
                                                                    *mut AVCodecParserContext)
                                               -> libc::c_int>,
    pub parser_parse: ::std::option::Option<unsafe extern "C" fn(s:
                                                                     *mut AVCodecParserContext,
                                                                 avctx:
                                                                     *mut AVCodecContext,
                                                                 poutbuf:
                                                                     *mut *const u8,
                                                                 poutbuf_size:
                                                                     *mut libc::c_int,
                                                                 buf:
                                                                     *const u8,
                                                                 buf_size:
                                                                     libc::c_int)
                                                -> libc::c_int>,
    pub parser_close: ::std::option::Option<unsafe extern "C" fn(s:
                                                                     *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<unsafe extern "C" fn(avctx:
                                                              *mut AVCodecContext,
                                                          buf: *const u8,
                                                          buf_size:
                                                              libc::c_int)
                                         -> libc::c_int>,
    pub next: *mut AVCodecParser,
}
#[test]
fn bindgen_test_layout_AVCodecParser() {
    assert_eq!(::std::mem::size_of::<AVCodecParser>() , 64usize , concat ! (
               "Size of: " , stringify ! ( AVCodecParser ) ));
    assert_eq! (::std::mem::align_of::<AVCodecParser>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVCodecParser ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParser ) ) . codec_ids as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParser ) , "::"
                , stringify ! ( codec_ids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParser ) ) . priv_data_size as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParser ) , "::"
                , stringify ! ( priv_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParser ) ) . parser_init as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParser ) , "::"
                , stringify ! ( parser_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParser ) ) . parser_parse as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParser ) , "::"
                , stringify ! ( parser_parse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParser ) ) . parser_close as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParser ) , "::"
                , stringify ! ( parser_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParser ) ) . split as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParser ) , "::"
                , stringify ! ( split ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVCodecParser ) ) . next as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVCodecParser ) , "::"
                , stringify ! ( next ) ));
}
impl Clone for AVCodecParser {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn av_parser_next(c: *const AVCodecParser) -> *mut AVCodecParser;
}
extern "C" {
    pub fn av_register_codec_parser(parser: *mut AVCodecParser);
}
extern "C" {
    pub fn av_parser_init(codec_id: libc::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    /**
 * Parse a packet.
 *
 * @param s             parser context.
 * @param avctx         codec context.
 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
 * @param buf           input buffer.
 * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer
                        size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.
                        To signal EOF, this should be 0 (so that the last frame
                        can be output).
 * @param pts           input presentation timestamp.
 * @param dts           input decoding timestamp.
 * @param pos           input byte position in stream.
 * @return the number of bytes of the input bitstream used.
 *
 * Example:
 * @code
 *   while(in_len){
 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
 *                                        in_data, in_len,
 *                                        pts, dts, pos);
 *       in_data += len;
 *       in_len  -= len;
 *
 *       if(size)
 *          decode_frame(data, size);
 *   }
 * @endcode
 */
    pub fn av_parser_parse2(s: *mut AVCodecParserContext,
                            avctx: *mut AVCodecContext, poutbuf: *mut *mut u8,
                            poutbuf_size: *mut libc::c_int, buf: *const u8,
                            buf_size: libc::c_int, pts: i64, dts: i64,
                            pos: i64) -> libc::c_int;
}
extern "C" {
    /**
 * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed
 * @deprecated use AVBitStreamFilter
 */
    pub fn av_parser_change(s: *mut AVCodecParserContext,
                            avctx: *mut AVCodecContext, poutbuf: *mut *mut u8,
                            poutbuf_size: *mut libc::c_int, buf: *const u8,
                            buf_size: libc::c_int, keyframe: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    /**
 * Find a registered encoder with a matching codec ID.
 *
 * @param id AVCodecID of the requested encoder
 * @return An encoder if one was found, NULL otherwise.
 */
    pub fn avcodec_find_encoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    /**
 * Find a registered encoder with the specified name.
 *
 * @param name name of the requested encoder
 * @return An encoder if one was found, NULL otherwise.
 */
    pub fn avcodec_find_encoder_by_name(name: *const libc::c_char)
     -> *mut AVCodec;
}
extern "C" {
    /**
 * Encode a frame of audio.
 *
 * Takes input samples from frame and writes the next output packet, if
 * available, to avpkt. The output packet does not necessarily contain data for
 * the most recent frame, as encoders can delay, split, and combine input frames
 * internally as needed.
 *
 * @param avctx     codec context
 * @param avpkt     output AVPacket.
 *                  The user can supply an output buffer by setting
 *                  avpkt->data and avpkt->size prior to calling the
 *                  function, but if the size of the user-provided data is not
 *                  large enough, encoding will fail. If avpkt->data and
 *                  avpkt->size are set, avpkt->destruct must also be set. All
 *                  other AVPacket fields will be reset by the encoder using
 *                  av_init_packet(). If avpkt->data is NULL, the encoder will
 *                  allocate it. The encoder will set avpkt->size to the size
 *                  of the output packet.
 *
 *                  If this function fails or produces no output, avpkt will be
 *                  freed using av_packet_unref().
 * @param[in] frame AVFrame containing the raw audio data to be encoded.
 *                  May be NULL when flushing an encoder that has the
 *                  AV_CODEC_CAP_DELAY capability set.
 *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
 *                  can have any number of samples.
 *                  If it is not set, frame->nb_samples must be equal to
 *                  avctx->frame_size for all frames except the last.
 *                  The final frame may be smaller than avctx->frame_size.
 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
 *                            output packet is non-empty, and to 0 if it is
 *                            empty. If the function returns an error, the
 *                            packet can be assumed to be invalid, and the
 *                            value of got_packet_ptr is undefined and should
 *                            not be used.
 * @return          0 on success, negative error code on failure
 *
 * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
 */
    pub fn avcodec_encode_audio2(avctx: *mut AVCodecContext,
                                 avpkt: *mut AVPacket, frame: *const AVFrame,
                                 got_packet_ptr: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Encode a frame of video.
 *
 * Takes input raw video data from frame and writes the next output packet, if
 * available, to avpkt. The output packet does not necessarily contain data for
 * the most recent frame, as encoders can delay and reorder input frames
 * internally as needed.
 *
 * @param avctx     codec context
 * @param avpkt     output AVPacket.
 *                  The user can supply an output buffer by setting
 *                  avpkt->data and avpkt->size prior to calling the
 *                  function, but if the size of the user-provided data is not
 *                  large enough, encoding will fail. All other AVPacket fields
 *                  will be reset by the encoder using av_init_packet(). If
 *                  avpkt->data is NULL, the encoder will allocate it.
 *                  The encoder will set avpkt->size to the size of the
 *                  output packet. The returned data (if any) belongs to the
 *                  caller, he is responsible for freeing it.
 *
 *                  If this function fails or produces no output, avpkt will be
 *                  freed using av_packet_unref().
 * @param[in] frame AVFrame containing the raw video data to be encoded.
 *                  May be NULL when flushing an encoder that has the
 *                  AV_CODEC_CAP_DELAY capability set.
 * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
 *                            output packet is non-empty, and to 0 if it is
 *                            empty. If the function returns an error, the
 *                            packet can be assumed to be invalid, and the
 *                            value of got_packet_ptr is undefined and should
 *                            not be used.
 * @return          0 on success, negative error code on failure
 *
 * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
 */
    pub fn avcodec_encode_video2(avctx: *mut AVCodecContext,
                                 avpkt: *mut AVPacket, frame: *const AVFrame,
                                 got_packet_ptr: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn avcodec_encode_subtitle(avctx: *mut AVCodecContext, buf: *mut u8,
                                   buf_size: libc::c_int,
                                   sub: *const AVSubtitle) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReSampleContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVResampleContext {
    _unused: [u8; 0],
}
extern "C" {
    /**
 *  Initialize audio resampling context.
 *
 * @param output_channels  number of output channels
 * @param input_channels   number of input channels
 * @param output_rate      output sample rate
 * @param input_rate       input sample rate
 * @param sample_fmt_out   requested output sample format
 * @param sample_fmt_in    input sample format
 * @param filter_length    length of each FIR filter in the filterbank relative to the cutoff frequency
 * @param log2_phase_count log2 of the number of entries in the polyphase filterbank
 * @param linear           if 1 then the used FIR filter will be linearly interpolated
                           between the 2 closest, if 0 the closest will be used
 * @param cutoff           cutoff frequency, 1.0 corresponds to half the output sampling rate
 * @return allocated ReSampleContext, NULL if error occurred
 */
    pub fn av_audio_resample_init(output_channels: libc::c_int,
                                  input_channels: libc::c_int,
                                  output_rate: libc::c_int,
                                  input_rate: libc::c_int,
                                  sample_fmt_out: AVSampleFormat,
                                  sample_fmt_in: AVSampleFormat,
                                  filter_length: libc::c_int,
                                  log2_phase_count: libc::c_int,
                                  linear: libc::c_int, cutoff: f64)
     -> *mut ReSampleContext;
}
extern "C" {
    pub fn audio_resample(s: *mut ReSampleContext, output: *mut libc::c_short,
                          input: *mut libc::c_short, nb_samples: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Free resample context.
 *
 * @param s a non-NULL pointer to a resample context previously
 *          created with av_audio_resample_init()
 */
    pub fn audio_resample_close(s: *mut ReSampleContext);
}
extern "C" {
    /**
 * Initialize an audio resampler.
 * Note, if either rate is not an integer then simply scale both rates up so they are.
 * @param filter_length length of each FIR filter in the filterbank relative to the cutoff freq
 * @param log2_phase_count log2 of the number of entries in the polyphase filterbank
 * @param linear If 1 then the used FIR filter will be linearly interpolated
                 between the 2 closest, if 0 the closest will be used
 * @param cutoff cutoff frequency, 1.0 corresponds to half the output sampling rate
 */
    pub fn av_resample_init(out_rate: libc::c_int, in_rate: libc::c_int,
                            filter_length: libc::c_int,
                            log2_phase_count: libc::c_int,
                            linear: libc::c_int, cutoff: f64)
     -> *mut AVResampleContext;
}
extern "C" {
    /**
 * Resample an array of samples using a previously configured context.
 * @param src an array of unconsumed samples
 * @param consumed the number of samples of src which have been consumed are returned here
 * @param src_size the number of unconsumed samples available
 * @param dst_size the amount of space in samples available in dst
 * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.
 * @return the number of samples written in dst or -1 if an error occurred
 */
    pub fn av_resample(c: *mut AVResampleContext, dst: *mut libc::c_short,
                       src: *mut libc::c_short, consumed: *mut libc::c_int,
                       src_size: libc::c_int, dst_size: libc::c_int,
                       update_ctx: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Compensate samplerate/timestamp drift. The compensation is done by changing
 * the resampler parameters, so no audible clicks or similar distortions occur
 * @param compensation_distance distance in output samples over which the compensation should be performed
 * @param sample_delta number of output samples which should be output less
 *
 * example: av_resample_compensate(c, 10, 500)
 * here instead of 510 samples only 500 samples would be output
 *
 * note, due to rounding the actual compensation might be slightly different,
 * especially if the compensation_distance is large and the in_rate used during init is small
 */
    pub fn av_resample_compensate(c: *mut AVResampleContext,
                                  sample_delta: libc::c_int,
                                  compensation_distance: libc::c_int);
}
extern "C" {
    pub fn av_resample_close(c: *mut AVResampleContext);
}
extern "C" {
    /**
 * @deprecated unused
 */
    pub fn avpicture_alloc(picture: *mut AVPicture, pix_fmt: AVPixelFormat,
                           width: libc::c_int, height: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * @deprecated unused
 */
    pub fn avpicture_free(picture: *mut AVPicture);
}
extern "C" {
    /**
 * @deprecated use av_image_fill_arrays() instead.
 */
    pub fn avpicture_fill(picture: *mut AVPicture, ptr: *const u8,
                          pix_fmt: AVPixelFormat, width: libc::c_int,
                          height: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * @deprecated use av_image_copy_to_buffer() instead.
 */
    pub fn avpicture_layout(src: *const AVPicture, pix_fmt: AVPixelFormat,
                            width: libc::c_int, height: libc::c_int,
                            dest: *mut libc::c_uchar, dest_size: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * @deprecated use av_image_get_buffer_size() instead.
 */
    pub fn avpicture_get_size(pix_fmt: AVPixelFormat, width: libc::c_int,
                              height: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * @deprecated av_image_copy() instead.
 */
    pub fn av_picture_copy(dst: *mut AVPicture, src: *const AVPicture,
                           pix_fmt: AVPixelFormat, width: libc::c_int,
                           height: libc::c_int);
}
extern "C" {
    /**
 * @deprecated unused
 */
    pub fn av_picture_crop(dst: *mut AVPicture, src: *const AVPicture,
                           pix_fmt: AVPixelFormat, top_band: libc::c_int,
                           left_band: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * @deprecated unused
 */
    pub fn av_picture_pad(dst: *mut AVPicture, src: *const AVPicture,
                          height: libc::c_int, width: libc::c_int,
                          pix_fmt: AVPixelFormat, padtop: libc::c_int,
                          padbottom: libc::c_int, padleft: libc::c_int,
                          padright: libc::c_int, color: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Utility function to access log2_chroma_w log2_chroma_h from
 * the pixel format AVPixFmtDescriptor.
 *
 * This function asserts that pix_fmt is valid. See av_pix_fmt_get_chroma_sub_sample
 * for one that returns a failure code and continues in case of invalid
 * pix_fmts.
 *
 * @param[in]  pix_fmt the pixel format
 * @param[out] h_shift store log2_chroma_w
 * @param[out] v_shift store log2_chroma_h
 *
 * @see av_pix_fmt_get_chroma_sub_sample
 */
    pub fn avcodec_get_chroma_sub_sample(pix_fmt: AVPixelFormat,
                                         h_shift: *mut libc::c_int,
                                         v_shift: *mut libc::c_int);
}
extern "C" {
    /**
 * Return a value representing the fourCC code associated to the
 * pixel format pix_fmt, or 0 if no associated fourCC code can be
 * found.
 */
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat)
     -> libc::c_uint;
}
extern "C" {
    /**
 * @deprecated see av_get_pix_fmt_loss()
 */
    pub fn avcodec_get_pix_fmt_loss(dst_pix_fmt: AVPixelFormat,
                                    src_pix_fmt: AVPixelFormat,
                                    has_alpha: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Find the best pixel format to convert to given a certain source pixel
 * format.  When converting from one pixel format to another, information loss
 * may occur.  For example, when converting from RGB24 to GRAY, the color
 * information will be lost. Similarly, other losses occur when converting from
 * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
 * the given pixel formats should be used to suffer the least amount of loss.
 * The pixel formats from which it chooses one, are determined by the
 * pix_fmt_list parameter.
 *
 *
 * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from
 * @param[in] src_pix_fmt source pixel format
 * @param[in] has_alpha Whether the source pixel format alpha channel is used.
 * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
 * @return The best pixel format to convert to or -1 if none was found.
 */
    pub fn avcodec_find_best_pix_fmt_of_list(pix_fmt_list:
                                                 *const AVPixelFormat,
                                             src_pix_fmt: AVPixelFormat,
                                             has_alpha: libc::c_int,
                                             loss_ptr: *mut libc::c_int)
     -> AVPixelFormat;
}
extern "C" {
    /**
 * @deprecated see av_find_best_pix_fmt_of_2()
 */
    pub fn avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1: AVPixelFormat,
                                          dst_pix_fmt2: AVPixelFormat,
                                          src_pix_fmt: AVPixelFormat,
                                          has_alpha: libc::c_int,
                                          loss_ptr: *mut libc::c_int)
     -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_find_best_pix_fmt2(dst_pix_fmt1: AVPixelFormat,
                                      dst_pix_fmt2: AVPixelFormat,
                                      src_pix_fmt: AVPixelFormat,
                                      has_alpha: libc::c_int,
                                      loss_ptr: *mut libc::c_int)
     -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(s: *mut AVCodecContext,
                                      fmt: *const AVPixelFormat)
     -> AVPixelFormat;
}
extern "C" {
    /**
 * @deprecated this function is not supposed to be used from outside of lavc
 */
    pub fn avcodec_set_dimensions(s: *mut AVCodecContext, width: libc::c_int,
                                  height: libc::c_int);
}
extern "C" {
    /**
 * Put a string representing the codec tag codec_tag in buf.
 *
 * @param buf       buffer to place codec tag in
 * @param buf_size size in bytes of buf
 * @param codec_tag codec tag to assign
 * @return the length of the string that would have been generated if
 * enough space had been available, excluding the trailing null
 *
 * @deprecated see av_fourcc_make_string() and av_fourcc2str().
 */
    pub fn av_get_codec_tag_string(buf: *mut libc::c_char, buf_size: usize,
                                   codec_tag: libc::c_uint) -> usize;
}
extern "C" {
    pub fn avcodec_string(buf: *mut libc::c_char, buf_size: libc::c_int,
                          enc: *mut AVCodecContext, encode: libc::c_int);
}
extern "C" {
    /**
 * Return a name for the specified profile, if available.
 *
 * @param codec the codec that is searched for the given profile
 * @param profile the profile value for which a name is requested
 * @return A name for the profile if found, NULL otherwise.
 */
    pub fn av_get_profile_name(codec: *const AVCodec, profile: libc::c_int)
     -> *const libc::c_char;
}
extern "C" {
    /**
 * Return a name for the specified profile, if available.
 *
 * @param codec_id the ID of the codec to which the requested profile belongs
 * @param profile the profile value for which a name is requested
 * @return A name for the profile if found, NULL otherwise.
 *
 * @note unlike av_get_profile_name(), which searches a list of profiles
 *       supported by a specific decoder or encoder implementation, this
 *       function searches the list of profiles from the AVCodecDescriptor
 */
    pub fn avcodec_profile_name(codec_id: AVCodecID, profile: libc::c_int)
     -> *const libc::c_char;
}
extern "C" {
    pub fn avcodec_default_execute(c: *mut AVCodecContext,
                                   func:
                                       ::std::option::Option<unsafe extern "C" fn(c2:
                                                                                      *mut AVCodecContext,
                                                                                  arg2:
                                                                                      *mut libc::c_void)
                                                                 ->
                                                                     libc::c_int>,
                                   arg: *mut libc::c_void,
                                   ret: *mut libc::c_int, count: libc::c_int,
                                   size: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(c: *mut AVCodecContext,
                                    func:
                                        ::std::option::Option<unsafe extern "C" fn(c2:
                                                                                       *mut AVCodecContext,
                                                                                   arg2:
                                                                                       *mut libc::c_void,
                                                                                   arg1:
                                                                                       libc::c_int,
                                                                                   arg2:
                                                                                       libc::c_int)
                                                                  ->
                                                                      libc::c_int>,
                                    arg: *mut libc::c_void,
                                    ret: *mut libc::c_int, count: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Fill AVFrame audio data and linesize pointers.
 *
 * The buffer buf must be a preallocated buffer with a size big enough
 * to contain the specified samples amount. The filled AVFrame data
 * pointers will point to this buffer.
 *
 * AVFrame extended_data channel pointers are allocated if necessary for
 * planar audio.
 *
 * @param frame       the AVFrame
 *                    frame->nb_samples must be set prior to calling the
 *                    function. This function fills in frame->data,
 *                    frame->extended_data, frame->linesize[0].
 * @param nb_channels channel count
 * @param sample_fmt  sample format
 * @param buf         buffer to use for frame data
 * @param buf_size    size of buffer
 * @param align       plane size sample alignment (0 = default)
 * @return            >=0 on success, negative error code on failure
 * @todo return the size in bytes required to store the samples in
 * case of success, at the next libavutil bump
 */
    pub fn avcodec_fill_audio_frame(frame: *mut AVFrame,
                                    nb_channels: libc::c_int,
                                    sample_fmt: AVSampleFormat,
                                    buf: *const u8, buf_size: libc::c_int,
                                    align: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Reset the internal decoder state / flush internal buffers. Should be called
 * e.g. when seeking or when switching to a different stream.
 *
 * @note when refcounted frames are not used (i.e. avctx->refcounted_frames is 0),
 * this invalidates the frames previously returned from the decoder. When
 * refcounted frames are used, the decoder just releases any references it might
 * keep internally, but the caller's reference remains valid.
 */
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    /**
 * Return codec bits per sample.
 *
 * @param[in] codec_id the codec
 * @return Number of bits per sample or zero if unknown for the given codec.
 */
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> libc::c_int;
}
extern "C" {
    /**
 * Return the PCM codec associated with a sample format.
 * @param be  endianness, 0 for little, 1 for big,
 *            -1 (or anything else) for native
 * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
 */
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: libc::c_int)
     -> AVCodecID;
}
extern "C" {
    /**
 * Return codec bits per sample.
 * Only return non-zero if the bits per sample is exactly correct, not an
 * approximation.
 *
 * @param[in] codec_id the codec
 * @return Number of bits per sample or zero if unknown for the given codec.
 */
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> libc::c_int;
}
extern "C" {
    /**
 * Return audio frame duration.
 *
 * @param avctx        codec context
 * @param frame_bytes  size of the frame, or 0 if unknown
 * @return             frame duration, in samples, if known. 0 if not able to
 *                     determine.
 */
    pub fn av_get_audio_frame_duration(avctx: *mut AVCodecContext,
                                       frame_bytes: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * This function is the same as av_get_audio_frame_duration(), except it works
 * with AVCodecParameters instead of an AVCodecContext.
 */
    pub fn av_get_audio_frame_duration2(par: *mut AVCodecParameters,
                                        frame_bytes: libc::c_int)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVBitStreamFilterContext {
    pub priv_data: *mut libc::c_void,
    pub filter: *const AVBitStreamFilter,
    pub parser: *mut AVCodecParserContext,
    pub next: *mut AVBitStreamFilterContext,
    /**
     * Internal default arguments, used if NULL is passed to av_bitstream_filter_filter().
     * Not for access by library users.
     */
    pub args: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilterContext() {
    assert_eq!(::std::mem::size_of::<AVBitStreamFilterContext>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( AVBitStreamFilterContext ) ));
    assert_eq! (::std::mem::align_of::<AVBitStreamFilterContext>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AVBitStreamFilterContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilterContext ) ) . priv_data
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVBitStreamFilterContext ) , "::" , stringify ! ( priv_data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilterContext ) ) . filter as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVBitStreamFilterContext ) , "::" , stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilterContext ) ) . parser as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVBitStreamFilterContext ) , "::" , stringify ! ( parser ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilterContext ) ) . next as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVBitStreamFilterContext ) , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilterContext ) ) . args as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVBitStreamFilterContext ) , "::" , stringify ! ( args ) ));
}
impl Clone for AVBitStreamFilterContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFInternal {
    _unused: [u8; 0],
}
/**
 * The bitstream filter state.
 *
 * This struct must be allocated with av_bsf_alloc() and freed with
 * av_bsf_free().
 *
 * The fields in the struct will only be changed (by the caller or by the
 * filter) as described in their documentation, and are to be considered
 * immutable otherwise.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVBSFContext {
    /**
     * A class for logging and AVOptions
     */
    pub av_class: *const AVClass,
    /**
     * The bitstream filter this context is an instance of.
     */
    pub filter: *const AVBitStreamFilter,
    /**
     * Opaque libavcodec internal data. Must not be touched by the caller in any
     * way.
     */
    pub internal: *mut AVBSFInternal,
    /**
     * Opaque filter-specific private data. If filter->priv_class is non-NULL,
     * this is an AVOptions-enabled struct.
     */
    pub priv_data: *mut libc::c_void,
    /**
     * Parameters of the input stream. This field is allocated in
     * av_bsf_alloc(), it needs to be filled by the caller before
     * av_bsf_init().
     */
    pub par_in: *mut AVCodecParameters,
    /**
     * Parameters of the output stream. This field is allocated in
     * av_bsf_alloc(), it is set by the filter in av_bsf_init().
     */
    pub par_out: *mut AVCodecParameters,
    /**
     * The timebase used for the timestamps of the input packets. Set by the
     * caller before av_bsf_init().
     */
    pub time_base_in: AVRational,
    /**
     * The timebase used for the timestamps of the output packets. Set by the
     * filter in av_bsf_init().
     */
    pub time_base_out: AVRational,
}
#[test]
fn bindgen_test_layout_AVBSFContext() {
    assert_eq!(::std::mem::size_of::<AVBSFContext>() , 64usize , concat ! (
               "Size of: " , stringify ! ( AVBSFContext ) ));
    assert_eq! (::std::mem::align_of::<AVBSFContext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVBSFContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBSFContext ) ) . av_class as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" ,
                stringify ! ( av_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBSFContext ) ) . filter as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBSFContext ) ) . internal as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" ,
                stringify ! ( internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBSFContext ) ) . priv_data as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" ,
                stringify ! ( priv_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBSFContext ) ) . par_in as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" ,
                stringify ! ( par_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBSFContext ) ) . par_out as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" ,
                stringify ! ( par_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBSFContext ) ) . time_base_in as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" ,
                stringify ! ( time_base_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBSFContext ) ) . time_base_out as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBSFContext ) , "::" ,
                stringify ! ( time_base_out ) ));
}
impl Clone for AVBSFContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVBitStreamFilter {
    pub name: *const libc::c_char,
    /**
     * A list of codec ids supported by the filter, terminated by
     * AV_CODEC_ID_NONE.
     * May be NULL, in that case the bitstream filter works with any codec id.
     */
    pub codec_ids: *const AVCodecID,
    /**
     * A class for the private data, used to declare bitstream filter private
     * AVOptions. This field is NULL for bitstream filters that do not declare
     * any options.
     *
     * If this field is non-NULL, the first member of the filter private data
     * must be a pointer to AVClass, which will be set by libavcodec generic
     * code to this class.
     */
    pub priv_class: *const AVClass,
    /*****************************************************************
     * No fields below this line are part of the public API. They
     * may not be used outside of libavcodec and can be changed and
     * removed at will.
     * New public fields should be added right above.
     *****************************************************************
     */
    pub priv_data_size: libc::c_int,
    pub init: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                             *mut AVBSFContext)
                                        -> libc::c_int>,
    pub filter: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                               *mut AVBSFContext,
                                                           pkt: *mut AVPacket)
                                          -> libc::c_int>,
    pub close: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                              *mut AVBSFContext)>,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilter() {
    assert_eq!(::std::mem::size_of::<AVBitStreamFilter>() , 56usize , concat !
               ( "Size of: " , stringify ! ( AVBitStreamFilter ) ));
    assert_eq! (::std::mem::align_of::<AVBitStreamFilter>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AVBitStreamFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilter ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBitStreamFilter ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilter ) ) . codec_ids as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBitStreamFilter ) ,
                "::" , stringify ! ( codec_ids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilter ) ) . priv_class as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBitStreamFilter ) ,
                "::" , stringify ! ( priv_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilter ) ) . priv_data_size as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBitStreamFilter ) ,
                "::" , stringify ! ( priv_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilter ) ) . init as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBitStreamFilter ) ,
                "::" , stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilter ) ) . filter as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBitStreamFilter ) ,
                "::" , stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBitStreamFilter ) ) . close as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBitStreamFilter ) ,
                "::" , stringify ! ( close ) ));
}
impl Clone for AVBitStreamFilter {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Register a bitstream filter.
 *
 * The filter will be accessible to the application code through
 * av_bitstream_filter_next() or can be directly initialized with
 * av_bitstream_filter_init().
 *
 * @see avcodec_register_all()
 */
    pub fn av_register_bitstream_filter(bsf: *mut AVBitStreamFilter);
}
extern "C" {
    /**
 * Create and initialize a bitstream filter context given a bitstream
 * filter name.
 *
 * The returned context must be freed with av_bitstream_filter_close().
 *
 * @param name    the name of the bitstream filter
 * @return a bitstream filter context if a matching filter was found
 * and successfully initialized, NULL otherwise
 */
    pub fn av_bitstream_filter_init(name: *const libc::c_char)
     -> *mut AVBitStreamFilterContext;
}
extern "C" {
    /**
 * Filter bitstream.
 *
 * This function filters the buffer buf with size buf_size, and places the
 * filtered buffer in the buffer pointed to by poutbuf.
 *
 * The output buffer must be freed by the caller.
 *
 * @param bsfc            bitstream filter context created by av_bitstream_filter_init()
 * @param avctx           AVCodecContext accessed by the filter, may be NULL.
 *                        If specified, this must point to the encoder context of the
 *                        output stream the packet is sent to.
 * @param args            arguments which specify the filter configuration, may be NULL
 * @param poutbuf         pointer which is updated to point to the filtered buffer
 * @param poutbuf_size    pointer which is updated to the filtered buffer size in bytes
 * @param buf             buffer containing the data to filter
 * @param buf_size        size in bytes of buf
 * @param keyframe        set to non-zero if the buffer to filter corresponds to a key-frame packet data
 * @return >= 0 in case of success, or a negative error code in case of failure
 *
 * If the return value is positive, an output buffer is allocated and
 * is available in *poutbuf, and is distinct from the input buffer.
 *
 * If the return value is 0, the output buffer is not allocated and
 * should be considered identical to the input buffer, or in case
 * *poutbuf was set it points to the input buffer (not necessarily to
 * its starting address). A special case is if *poutbuf was set to NULL and
 * *poutbuf_size was set to 0, which indicates the packet should be dropped.
 */
    pub fn av_bitstream_filter_filter(bsfc: *mut AVBitStreamFilterContext,
                                      avctx: *mut AVCodecContext,
                                      args: *const libc::c_char,
                                      poutbuf: *mut *mut u8,
                                      poutbuf_size: *mut libc::c_int,
                                      buf: *const u8, buf_size: libc::c_int,
                                      keyframe: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Release bitstream filter context.
 *
 * @param bsf the bitstream filter context created with
 * av_bitstream_filter_init(), can be NULL
 */
    pub fn av_bitstream_filter_close(bsf: *mut AVBitStreamFilterContext);
}
extern "C" {
    /**
 * If f is NULL, return the first registered bitstream filter,
 * if f is non-NULL, return the next registered bitstream filter
 * after f, or NULL if f is the last one.
 *
 * This function can be used to iterate over all registered bitstream
 * filters.
 */
    pub fn av_bitstream_filter_next(f: *const AVBitStreamFilter)
     -> *mut AVBitStreamFilter;
}
extern "C" {
    /**
 * @return a bitstream filter with the specified name or NULL if no such
 *         bitstream filter exists.
 */
    pub fn av_bsf_get_by_name(name: *const libc::c_char)
     -> *const AVBitStreamFilter;
}
extern "C" {
    /**
 * Iterate over all registered bitstream filters.
 *
 * @param opaque a pointer where libavcodec will store the iteration state. Must
 *               point to NULL to start the iteration.
 *
 * @return the next registered bitstream filter or NULL when the iteration is
 *         finished
 */
    pub fn av_bsf_next(opaque: *mut *mut libc::c_void)
     -> *const AVBitStreamFilter;
}
extern "C" {
    /**
 * Allocate a context for a given bitstream filter. The caller must fill in the
 * context parameters as described in the documentation and then call
 * av_bsf_init() before sending any data to the filter.
 *
 * @param filter the filter for which to allocate an instance.
 * @param ctx a pointer into which the pointer to the newly-allocated context
 *            will be written. It must be freed with av_bsf_free() after the
 *            filtering is done.
 *
 * @return 0 on success, a negative AVERROR code on failure
 */
    pub fn av_bsf_alloc(filter: *const AVBitStreamFilter,
                        ctx: *mut *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    /**
 * Prepare the filter for use, after all the parameters and options have been
 * set.
 */
    pub fn av_bsf_init(ctx: *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    /**
 * Submit a packet for filtering.
 *
 * After sending each packet, the filter must be completely drained by calling
 * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
 * AVERROR_EOF.
 *
 * @param pkt the packet to filter. pkt must contain some payload (i.e data or
 * side data must be present in pkt). The bitstream filter will take ownership of
 * the packet and reset the contents of pkt. pkt is not touched if an error occurs.
 * This parameter may be NULL, which signals the end of the stream (i.e. no more
 * packets will be sent). That will cause the filter to output any packets it
 * may have buffered internally.
 *
 * @return 0 on success, a negative AVERROR on error.
 */
    pub fn av_bsf_send_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket)
     -> libc::c_int;
}
extern "C" {
    /**
 * Retrieve a filtered packet.
 *
 * @param[out] pkt this struct will be filled with the contents of the filtered
 *                 packet. It is owned by the caller and must be freed using
 *                 av_packet_unref() when it is no longer needed.
 *                 This parameter should be "clean" (i.e. freshly allocated
 *                 with av_packet_alloc() or unreffed with av_packet_unref())
 *                 when this function is called. If this function returns
 *                 successfully, the contents of pkt will be completely
 *                 overwritten by the returned data. On failure, pkt is not
 *                 touched.
 *
 * @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the
 * filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there
 * will be no further output from the filter. Another negative AVERROR value if
 * an error occurs.
 *
 * @note one input packet may result in several output packets, so after sending
 * a packet with av_bsf_send_packet(), this function needs to be called
 * repeatedly until it stops returning 0. It is also possible for a filter to
 * output fewer packets than were sent to it, so this function may return
 * AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
 */
    pub fn av_bsf_receive_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket)
     -> libc::c_int;
}
extern "C" {
    /**
 * Free a bitstream filter context and everything associated with it; write NULL
 * into the supplied pointer.
 */
    pub fn av_bsf_free(ctx: *mut *mut AVBSFContext);
}
extern "C" {
    /**
 * Get the AVClass for AVBSFContext. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
    pub fn av_bsf_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFList {
    _unused: [u8; 0],
}
extern "C" {
    /**
 * Allocate empty list of bitstream filters.
 * The list must be later freed by av_bsf_list_free()
 * or finalized by av_bsf_list_finalize().
 *
 * @return Pointer to @ref AVBSFList on success, NULL in case of failure
 */
    pub fn av_bsf_list_alloc() -> *mut AVBSFList;
}
extern "C" {
    /**
 * Free list of bitstream filters.
 *
 * @param lst Pointer to pointer returned by av_bsf_list_alloc()
 */
    pub fn av_bsf_list_free(lst: *mut *mut AVBSFList);
}
extern "C" {
    /**
 * Append bitstream filter to the list of bitstream filters.
 *
 * @param lst List to append to
 * @param bsf Filter context to be appended
 *
 * @return >=0 on success, negative AVERROR in case of failure
 */
    pub fn av_bsf_list_append(lst: *mut AVBSFList, bsf: *mut AVBSFContext)
     -> libc::c_int;
}
extern "C" {
    /**
 * Construct new bitstream filter context given it's name and options
 * and append it to the list of bitstream filters.
 *
 * @param lst      List to append to
 * @param bsf_name Name of the bitstream filter
 * @param options  Options for the bitstream filter, can be set to NULL
 *
 * @return >=0 on success, negative AVERROR in case of failure
 */
    pub fn av_bsf_list_append2(lst: *mut AVBSFList,
                               bsf_name: *const libc::c_char,
                               options: *mut *mut AVDictionary)
     -> libc::c_int;
}
extern "C" {
    /**
 * Finalize list of bitstream filters.
 *
 * This function will transform @ref AVBSFList to single @ref AVBSFContext,
 * so the whole chain of bitstream filters can be treated as single filter
 * freshly allocated by av_bsf_alloc().
 * If the call is successful, @ref AVBSFList structure is freed and lst
 * will be set to NULL. In case of failure, caller is responsible for
 * freeing the structure by av_bsf_list_free()
 *
 * @param      lst Filter list structure to be transformed
 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
 *                 representing the chain of bitstream filters
 *
 * @return >=0 on success, negative AVERROR in case of failure
 */
    pub fn av_bsf_list_finalize(lst: *mut *mut AVBSFList,
                                bsf: *mut *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    /**
 * Parse string describing list of bitstream filters and create single
 * @ref AVBSFContext describing the whole chain of bitstream filters.
 * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly
 * allocated by av_bsf_alloc().
 *
 * @param      str String describing chain of bitstream filters in format
 *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`
 * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
 *                 representing the chain of bitstream filters
 *
 * @return >=0 on success, negative AVERROR in case of failure
 */
    pub fn av_bsf_list_parse_str(str: *const libc::c_char,
                                 bsf: *mut *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    /**
 * Get null/pass-through bitstream filter.
 *
 * @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter
 *
 * @return
 */
    pub fn av_bsf_get_null_filter(bsf: *mut *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    /**
 * Same behaviour av_fast_malloc but the buffer has additional
 * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
 *
 * In addition the whole buffer will initially and after resizes
 * be 0-initialized so that no uninitialized data will ever appear.
 */
    pub fn av_fast_padded_malloc(ptr: *mut libc::c_void,
                                 size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    /**
 * Same behaviour av_fast_padded_malloc except that buffer will always
 * be 0-initialized after call.
 */
    pub fn av_fast_padded_mallocz(ptr: *mut libc::c_void,
                                  size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    /**
 * Encode extradata length to a buffer. Used by xiph codecs.
 *
 * @param s buffer to write to; must be at least (v/255+1) bytes long
 * @param v size of extradata in bytes
 * @return number of bytes written to the buffer.
 */
    pub fn av_xiphlacing(s: *mut libc::c_uchar, v: libc::c_uint)
     -> libc::c_uint;
}
extern "C" {
    /**
 * Log a generic warning message about a missing feature. This function is
 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)
 * only, and would normally not be used by applications.
 * @param[in] avc a pointer to an arbitrary struct of which the first field is
 * a pointer to an AVClass struct
 * @param[in] feature string containing the name of the missing feature
 * @param[in] want_sample indicates if samples are wanted which exhibit this feature.
 * If want_sample is non-zero, additional verbiage will be added to the log
 * message which tells the user how to report samples to the development
 * mailing list.
 * @deprecated Use avpriv_report_missing_feature() instead.
 */
    pub fn av_log_missing_feature(avc: *mut libc::c_void,
                                  feature: *const libc::c_char,
                                  want_sample: libc::c_int);
}
extern "C" {
    /**
 * Log a generic warning message asking for a sample. This function is
 * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)
 * only, and would normally not be used by applications.
 * @param[in] avc a pointer to an arbitrary struct of which the first field is
 * a pointer to an AVClass struct
 * @param[in] msg string containing an optional message, or NULL if no message
 * @deprecated Use avpriv_request_sample() instead.
 */
    pub fn av_log_ask_for_sample(avc: *mut libc::c_void,
                                 msg: *const libc::c_char, ...);
}
extern "C" {
    /**
 * Register the hardware accelerator hwaccel.
 */
    pub fn av_register_hwaccel(hwaccel: *mut AVHWAccel);
}
extern "C" {
    /**
 * If hwaccel is NULL, returns the first registered hardware accelerator,
 * if hwaccel is non-NULL, returns the next registered hardware accelerator
 * after hwaccel, or NULL if hwaccel is the last one.
 */
    pub fn av_hwaccel_next(hwaccel: *const AVHWAccel) -> *mut AVHWAccel;
}
#[repr(u32)]
/**
 * Lock operation used by lockmgr
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVLockOp {
    AV_LOCK_CREATE = 0,
    AV_LOCK_OBTAIN = 1,
    AV_LOCK_RELEASE = 2,
    AV_LOCK_DESTROY = 3,
}
extern "C" {
    /**
 * Register a user provided lock manager supporting the operations
 * specified by AVLockOp. The "mutex" argument to the function points
 * to a (void *) where the lockmgr should store/get a pointer to a user
 * allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the
 * value left by the last call for all other ops. If the lock manager is
 * unable to perform the op then it should leave the mutex in the same
 * state as when it was called and return a non-zero value. However,
 * when called with AV_LOCK_DESTROY the mutex will always be assumed to
 * have been successfully destroyed. If av_lockmgr_register succeeds
 * it will return a non-negative value, if it fails it will return a
 * negative value and destroy all mutex and unregister all callbacks.
 * av_lockmgr_register is not thread-safe, it must be called from a
 * single thread before any calls which make use of locking are used.
 *
 * @param cb User defined callback. av_lockmgr_register invokes calls
 *           to this callback and the previously registered callback.
 *           The callback will be used to create more than one mutex
 *           each of which must be backed by its own underlying locking
 *           mechanism (i.e. do not use a single static object to
 *           implement your lock manager). If cb is set to NULL the
 *           lockmgr will be unregistered.
 */
    pub fn av_lockmgr_register(cb:
                                   ::std::option::Option<unsafe extern "C" fn(mutex:
                                                                                  *mut *mut libc::c_void,
                                                                              op:
                                                                                  AVLockOp)
                                                             -> libc::c_int>)
     -> libc::c_int;
}
extern "C" {
    /**
 * Get the type of the given codec.
 */
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    /**
 * Get the name of a codec.
 * @return  a static string identifying the codec; never NULL
 */
    pub fn avcodec_get_name(id: AVCodecID) -> *const libc::c_char;
}
extern "C" {
    /**
 * @return a positive value if s is open (i.e. avcodec_open2() was called on it
 * with no corresponding avcodec_close()), 0 otherwise.
 */
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> libc::c_int;
}
extern "C" {
    /**
 * @return a non-zero number if codec is an encoder, zero otherwise
 */
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> libc::c_int;
}
extern "C" {
    /**
 * @return a non-zero number if codec is a decoder, zero otherwise
 */
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> libc::c_int;
}
extern "C" {
    /**
 * @return descriptor for given codec ID or NULL if no descriptor exists.
 */
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    /**
 * Iterate over all codec descriptors known to libavcodec.
 *
 * @param prev previous descriptor. NULL to get the first descriptor.
 *
 * @return next descriptor or NULL after the last descriptor
 */
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor)
     -> *const AVCodecDescriptor;
}
extern "C" {
    /**
 * @return codec descriptor with the given name or NULL if no such descriptor
 *         exists.
 */
    pub fn avcodec_descriptor_get_by_name(name: *const libc::c_char)
     -> *const AVCodecDescriptor;
}
extern "C" {
    /**
 * Allocate a CPB properties structure and initialize its fields to default
 * values.
 *
 * @param size if non-NULL, the size of the allocated struct will be written
 *             here. This is useful for embedding it in side data.
 *
 * @return the newly allocated struct or NULL on failure
 */
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut libc::c_char, __maxsize: usize,
                    __format: *const libc::c_char, __tp: *const tm) -> usize;
}
extern "C" {
    pub fn strftime_l(__s: *mut libc::c_char, __maxsize: usize,
                      __format: *const libc::c_char, __tp: *const tm,
                      __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: libc::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: libc::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: libc::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> libc::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t, __flags: libc::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> libc::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: libc::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: libc::c_int)
     -> libc::c_int;
}
/**
 * Callback for checking whether to abort blocking functions.
 * AVERROR_EXIT is returned in this case by the interrupted
 * function. During blocking operations, callback is called with
 * opaque as parameter. If the callback returns 1, the
 * blocking operation will be aborted.
 *
 * No members can be added to this struct without a major bump, if
 * new elements have been added after this struct in AVFormatContext
 * or AVIOContext.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVIOInterruptCB {
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut libc::c_void)
                                            -> libc::c_int>,
    pub opaque: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_AVIOInterruptCB() {
    assert_eq!(::std::mem::size_of::<AVIOInterruptCB>() , 16usize , concat ! (
               "Size of: " , stringify ! ( AVIOInterruptCB ) ));
    assert_eq! (::std::mem::align_of::<AVIOInterruptCB>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AVIOInterruptCB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOInterruptCB ) ) . callback as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOInterruptCB ) ,
                "::" , stringify ! ( callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOInterruptCB ) ) . opaque as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOInterruptCB ) ,
                "::" , stringify ! ( opaque ) ));
}
impl Clone for AVIOInterruptCB {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Directory entry types.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVIODirEntryType {
    AVIO_ENTRY_UNKNOWN = 0,
    AVIO_ENTRY_BLOCK_DEVICE = 1,
    AVIO_ENTRY_CHARACTER_DEVICE = 2,
    AVIO_ENTRY_DIRECTORY = 3,
    AVIO_ENTRY_NAMED_PIPE = 4,
    AVIO_ENTRY_SYMBOLIC_LINK = 5,
    AVIO_ENTRY_SOCKET = 6,
    AVIO_ENTRY_FILE = 7,
    AVIO_ENTRY_SERVER = 8,
    AVIO_ENTRY_SHARE = 9,
    AVIO_ENTRY_WORKGROUP = 10,
}
/**
 * Describes single entry of the directory.
 *
 * Only name and type fields are guaranteed be set.
 * Rest of fields are protocol or/and platform dependent and might be unknown.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVIODirEntry {
    /**< Filename */
    pub name: *mut libc::c_char,
    /**< Type of the entry */
    pub type_: libc::c_int,
    /**< Set to 1 when name is encoded with UTF-8, 0 otherwise.
                                               Name can be encoded with UTF-8 even though 0 is set. */
    pub utf8: libc::c_int,
    /**< File size in bytes, -1 if unknown. */
    pub size: i64,
    /**< Time of last modification in microseconds since unix
                                               epoch, -1 if unknown. */
    pub modification_timestamp: i64,
    /**< Time of last access in microseconds since unix epoch,
                                               -1 if unknown. */
    pub access_timestamp: i64,
    /**< Time of last status change in microseconds since unix
                                               epoch, -1 if unknown. */
    pub status_change_timestamp: i64,
    /**< User ID of owner, -1 if unknown. */
    pub user_id: i64,
    /**< Group ID of owner, -1 if unknown. */
    pub group_id: i64,
    /**< Unix file mode, -1 if unknown. */
    pub filemode: i64,
}
#[test]
fn bindgen_test_layout_AVIODirEntry() {
    assert_eq!(::std::mem::size_of::<AVIODirEntry>() , 72usize , concat ! (
               "Size of: " , stringify ! ( AVIODirEntry ) ));
    assert_eq! (::std::mem::align_of::<AVIODirEntry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVIODirEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . utf8 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( utf8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . modification_timestamp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( modification_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . access_timestamp as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( access_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) .
                status_change_timestamp as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( status_change_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . user_id as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( user_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . group_id as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( group_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirEntry ) ) . filemode as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirEntry ) , "::" ,
                stringify ! ( filemode ) ));
}
impl Clone for AVIODirEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVIODirContext {
    pub url_context: *mut URLContext,
}
#[test]
fn bindgen_test_layout_AVIODirContext() {
    assert_eq!(::std::mem::size_of::<AVIODirContext>() , 8usize , concat ! (
               "Size of: " , stringify ! ( AVIODirContext ) ));
    assert_eq! (::std::mem::align_of::<AVIODirContext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVIODirContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIODirContext ) ) . url_context as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIODirContext ) , "::"
                , stringify ! ( url_context ) ));
}
impl Clone for AVIODirContext {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Different data types that can be returned via the AVIO
 * write_data_type callback.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVIODataMarkerType {
    AVIO_DATA_MARKER_HEADER = 0,
    AVIO_DATA_MARKER_SYNC_POINT = 1,
    AVIO_DATA_MARKER_BOUNDARY_POINT = 2,
    AVIO_DATA_MARKER_UNKNOWN = 3,
    AVIO_DATA_MARKER_TRAILER = 4,
}
/**
 * Bytestream IO Context.
 * New fields can be added to the end with minor version bumps.
 * Removal, reordering and changes to existing fields require a major
 * version bump.
 * sizeof(AVIOContext) must not be used outside libav*.
 *
 * @note None of the function pointers in AVIOContext should be called
 *       directly, they should only be set by the client application
 *       when implementing custom I/O. Normally these are set to the
 *       function pointers specified in avio_alloc_context()
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVIOContext {
    /**
     * A class for private options.
     *
     * If this AVIOContext is created by avio_open2(), av_class is set and
     * passes the options down to protocols.
     *
     * If this AVIOContext is manually allocated, then av_class may be set by
     * the caller.
     *
     * warning -- this field can be NULL, be sure to not pass this AVIOContext
     * to any av_opt_* functions in that case.
     */
    pub av_class: *const AVClass,
    /**< Start of the buffer. */
    pub buffer: *mut libc::c_uchar,
    /**< Maximum buffer size */
    pub buffer_size: libc::c_int,
    /**< Current position in the buffer */
    pub buf_ptr: *mut libc::c_uchar,
    /**< End of the data, may be less than
                                 buffer+buffer_size if the read function returned
                                 less data than requested, e.g. for streams where
                                 no more data has been received yet. */
    pub buf_end: *mut libc::c_uchar,
    /**< A private pointer, passed to the read/write/seek/...
                                 functions. */
    pub opaque: *mut libc::c_void,
    pub read_packet: ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                    *mut libc::c_void,
                                                                buf: *mut u8,
                                                                buf_size:
                                                                    libc::c_int)
                                               -> libc::c_int>,
    pub write_packet: ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                     *mut libc::c_void,
                                                                 buf: *mut u8,
                                                                 buf_size:
                                                                     libc::c_int)
                                                -> libc::c_int>,
    pub seek: ::std::option::Option<unsafe extern "C" fn(opaque:
                                                             *mut libc::c_void,
                                                         offset: i64,
                                                         whence: libc::c_int)
                                        -> i64>,
    /**< position in the file of the current buffer */
    pub pos: i64,
    /**< true if the next seek should flush */
    pub must_flush: libc::c_int,
    /**< true if eof reached */
    pub eof_reached: libc::c_int,
    /**< true if open for writing */
    pub write_flag: libc::c_int,
    pub max_packet_size: libc::c_int,
    pub checksum: libc::c_ulong,
    pub checksum_ptr: *mut libc::c_uchar,
    pub update_checksum: ::std::option::Option<unsafe extern "C" fn(checksum:
                                                                        libc::c_ulong,
                                                                    buf:
                                                                        *const u8,
                                                                    size:
                                                                        libc::c_uint)
                                                   -> libc::c_ulong>,
    /**< contains the error code or 0 if no error happened */
    pub error: libc::c_int,
    /**
     * Pause or resume playback for network streaming protocols - e.g. MMS.
     */
    pub read_pause: ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                   *mut libc::c_void,
                                                               pause:
                                                                   libc::c_int)
                                              -> libc::c_int>,
    /**
     * Seek to a given timestamp in stream with the specified stream_index.
     * Needed for some network streaming protocols which don't support seeking
     * to byte position.
     */
    pub read_seek: ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                  *mut libc::c_void,
                                                              stream_index:
                                                                  libc::c_int,
                                                              timestamp: i64,
                                                              flags:
                                                                  libc::c_int)
                                             -> i64>,
    /**
     * A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
     */
    pub seekable: libc::c_int,
    /**
     * max filesize, used to limit allocations
     * This field is internal to libavformat and access from outside is not allowed.
     */
    pub maxsize: i64,
    /**
     * avio_read and avio_write should if possible be satisfied directly
     * instead of going through a buffer, and avio_seek will always
     * call the underlying seek function directly.
     */
    pub direct: libc::c_int,
    /**
     * Bytes read statistic
     * This field is internal to libavformat and access from outside is not allowed.
     */
    pub bytes_read: i64,
    /**
     * seek statistic
     * This field is internal to libavformat and access from outside is not allowed.
     */
    pub seek_count: libc::c_int,
    /**
     * writeout statistic
     * This field is internal to libavformat and access from outside is not allowed.
     */
    pub writeout_count: libc::c_int,
    /**
     * Original buffer size
     * used internally after probing and ensure seekback to reset the buffer size
     * This field is internal to libavformat and access from outside is not allowed.
     */
    pub orig_buffer_size: libc::c_int,
    /**
     * Threshold to favor readahead over seek.
     * This is current internal only, do not use from outside.
     */
    pub short_seek_threshold: libc::c_int,
    /**
     * ',' separated list of allowed protocols.
     */
    pub protocol_whitelist: *const libc::c_char,
    /**
     * ',' separated list of disallowed protocols.
     */
    pub protocol_blacklist: *const libc::c_char,
    /**
     * A callback that is used instead of write_packet.
     */
    pub write_data_type: ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                        *mut libc::c_void,
                                                                    buf:
                                                                        *mut u8,
                                                                    buf_size:
                                                                        libc::c_int,
                                                                    type_:
                                                                        AVIODataMarkerType,
                                                                    time: i64)
                                                   -> libc::c_int>,
    /**
     * If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,
     * but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly
     * small chunks of data returned from the callback).
     */
    pub ignore_boundary_point: libc::c_int,
    /**
     * Internal, not meant to be used from outside of AVIOContext.
     */
    pub current_type: AVIODataMarkerType,
    pub last_time: i64,
    /**
     * A callback that is used instead of short_seek_threshold.
     * This is current internal only, do not use from outside.
     */
    pub short_seek_get: ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                       *mut libc::c_void)
                                                  -> libc::c_int>,
}
#[test]
fn bindgen_test_layout_AVIOContext() {
    assert_eq!(::std::mem::size_of::<AVIOContext>() , 240usize , concat ! (
               "Size of: " , stringify ! ( AVIOContext ) ));
    assert_eq! (::std::mem::align_of::<AVIOContext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVIOContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . av_class as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( av_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . buffer as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . buffer_size as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( buffer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . buf_ptr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( buf_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . buf_end as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . opaque as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . read_packet as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( read_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . write_packet as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( write_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . seek as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . pos as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . must_flush as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( must_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . eof_reached as * const
                _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( eof_reached ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . write_flag as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( write_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . max_packet_size as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( max_packet_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . checksum as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . checksum_ptr as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( checksum_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . update_checksum as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( update_checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . error as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . read_pause as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( read_pause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . read_seek as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( read_seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . seekable as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( seekable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . maxsize as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . direct as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( direct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . bytes_read as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( bytes_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . seek_count as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( seek_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . writeout_count as *
                const _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( writeout_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . orig_buffer_size as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( orig_buffer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . short_seek_threshold as
                * const _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( short_seek_threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . protocol_whitelist as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( protocol_whitelist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . protocol_blacklist as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( protocol_blacklist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . write_data_type as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( write_data_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . ignore_boundary_point
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( ignore_boundary_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . current_type as * const
                _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( current_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . last_time as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( last_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIOContext ) ) . short_seek_get as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIOContext ) , "::" ,
                stringify ! ( short_seek_get ) ));
}
impl Clone for AVIOContext {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Return the name of the protocol that will handle the passed URL.
 *
 * NULL is returned if no protocol could be found for the given URL.
 *
 * @return Name of the protocol or NULL.
 */
    pub fn avio_find_protocol_name(url: *const libc::c_char)
     -> *const libc::c_char;
}
extern "C" {
    /**
 * Return AVIO_FLAG_* access flags corresponding to the access permissions
 * of the resource in url, or a negative value corresponding to an
 * AVERROR code in case of failure. The returned access flags are
 * masked by the value in flags.
 *
 * @note This function is intrinsically unsafe, in the sense that the
 * checked resource may change its existence or permission status from
 * one call to another. Thus you should not trust the returned value,
 * unless you are sure that no other processes are accessing the
 * checked resource.
 */
    pub fn avio_check(url: *const libc::c_char, flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Move or rename a resource.
 *
 * @note url_src and url_dst should share the same protocol and authority.
 *
 * @param url_src url to resource to be moved
 * @param url_dst new url to resource if the operation succeeded
 * @return >=0 on success or negative on error.
 */
    pub fn avpriv_io_move(url_src: *const libc::c_char,
                          url_dst: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /**
 * Delete a resource.
 *
 * @param url resource to be deleted.
 * @return >=0 on success or negative on error.
 */
    pub fn avpriv_io_delete(url: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /**
 * Open directory for reading.
 *
 * @param s       directory read context. Pointer to a NULL pointer must be passed.
 * @param url     directory to be listed.
 * @param options A dictionary filled with protocol-private options. On return
 *                this parameter will be destroyed and replaced with a dictionary
 *                containing options that were not found. May be NULL.
 * @return >=0 on success or negative on error.
 */
    pub fn avio_open_dir(s: *mut *mut AVIODirContext,
                         url: *const libc::c_char,
                         options: *mut *mut AVDictionary) -> libc::c_int;
}
extern "C" {
    /**
 * Get next directory entry.
 *
 * Returned entry must be freed with avio_free_directory_entry(). In particular
 * it may outlive AVIODirContext.
 *
 * @param s         directory read context.
 * @param[out] next next entry or NULL when no more entries.
 * @return >=0 on success or negative on error. End of list is not considered an
 *             error.
 */
    pub fn avio_read_dir(s: *mut AVIODirContext, next: *mut *mut AVIODirEntry)
     -> libc::c_int;
}
extern "C" {
    /**
 * Close directory.
 *
 * @note Entries created using avio_read_dir() are not deleted and must be
 * freeded with avio_free_directory_entry().
 *
 * @param s         directory read context.
 * @return >=0 on success or negative on error.
 */
    pub fn avio_close_dir(s: *mut *mut AVIODirContext) -> libc::c_int;
}
extern "C" {
    /**
 * Free entry allocated by avio_read_dir().
 *
 * @param entry entry to be freed.
 */
    pub fn avio_free_directory_entry(entry: *mut *mut AVIODirEntry);
}
extern "C" {
    /**
 * Allocate and initialize an AVIOContext for buffered I/O. It must be later
 * freed with av_free().
 *
 * @param buffer Memory block for input/output operations via AVIOContext.
 *        The buffer must be allocated with av_malloc() and friends.
 *        It may be freed and replaced with a new buffer by libavformat.
 *        AVIOContext.buffer holds the buffer currently in use,
 *        which must be later freed with av_free().
 * @param buffer_size The buffer size is very important for performance.
 *        For protocols with fixed blocksize it should be set to this blocksize.
 *        For others a typical size is a cache page, e.g. 4kb.
 * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.
 * @param opaque An opaque pointer to user-specific data.
 * @param read_packet  A function for refilling the buffer, may be NULL.
 * @param write_packet A function for writing the buffer contents, may be NULL.
 *        The function may not change the input buffers content.
 * @param seek A function for seeking to specified byte position, may be NULL.
 *
 * @return Allocated AVIOContext or NULL on failure.
 */
    pub fn avio_alloc_context(buffer: *mut libc::c_uchar,
                              buffer_size: libc::c_int,
                              write_flag: libc::c_int,
                              opaque: *mut libc::c_void,
                              read_packet:
                                  ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                                 *mut libc::c_void,
                                                                             buf:
                                                                                 *mut u8,
                                                                             buf_size:
                                                                                 libc::c_int)
                                                            -> libc::c_int>,
                              write_packet:
                                  ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                                 *mut libc::c_void,
                                                                             buf:
                                                                                 *mut u8,
                                                                             buf_size:
                                                                                 libc::c_int)
                                                            -> libc::c_int>,
                              seek:
                                  ::std::option::Option<unsafe extern "C" fn(opaque:
                                                                                 *mut libc::c_void,
                                                                             offset:
                                                                                 i64,
                                                                             whence:
                                                                                 libc::c_int)
                                                            -> i64>)
     -> *mut AVIOContext;
}
extern "C" {
    pub fn avio_w8(s: *mut AVIOContext, b: libc::c_int);
}
extern "C" {
    pub fn avio_write(s: *mut AVIOContext, buf: *const libc::c_uchar,
                      size: libc::c_int);
}
extern "C" {
    pub fn avio_wl64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wb64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wl32(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb32(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wl24(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb24(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wl16(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb16(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    /**
 * Write a NULL-terminated string.
 * @return number of bytes written.
 */
    pub fn avio_put_str(s: *mut AVIOContext, str: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    /**
 * Convert an UTF-8 string to UTF-16LE and write it.
 * @param s the AVIOContext
 * @param str NULL-terminated UTF-8 string
 *
 * @return number of bytes written.
 */
    pub fn avio_put_str16le(s: *mut AVIOContext, str: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    /**
 * Convert an UTF-8 string to UTF-16BE and write it.
 * @param s the AVIOContext
 * @param str NULL-terminated UTF-8 string
 *
 * @return number of bytes written.
 */
    pub fn avio_put_str16be(s: *mut AVIOContext, str: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    /**
 * Mark the written bytestream as a specific type.
 *
 * Zero-length ranges are omitted from the output.
 *
 * @param time the stream time the current bytestream pos corresponds to
 *             (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not
 *             applicable
 * @param type the kind of data written starting at the current pos
 */
    pub fn avio_write_marker(s: *mut AVIOContext, time: i64,
                             type_: AVIODataMarkerType);
}
extern "C" {
    /**
 * fseek() equivalent for AVIOContext.
 * @return new position or AVERROR.
 */
    pub fn avio_seek(s: *mut AVIOContext, offset: i64, whence: libc::c_int)
     -> i64;
}
extern "C" {
    /**
 * Skip given number of bytes forward
 * @return new position or AVERROR.
 */
    pub fn avio_skip(s: *mut AVIOContext, offset: i64) -> i64;
}
extern "C" {
    /**
 * Get the filesize.
 * @return filesize or AVERROR
 */
    pub fn avio_size(s: *mut AVIOContext) -> i64;
}
extern "C" {
    /**
 * feof() equivalent for AVIOContext.
 * @return non zero if and only if end of file
 */
    pub fn avio_feof(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /**
 * @deprecated use avio_feof()
 */
    pub fn url_feof(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /** @warning Writes up to 4 KiB per call */
    pub fn avio_printf(s: *mut AVIOContext, fmt: *const libc::c_char, ...)
     -> libc::c_int;
}
extern "C" {
    /**
 * Force flushing of buffered data.
 *
 * For write streams, force the buffered data to be immediately written to the output,
 * without to wait to fill the internal buffer.
 *
 * For read streams, discard all currently buffered data, and advance the
 * reported file position to that of the underlying stream. This does not
 * read new data, and does not perform any seeks.
 */
    pub fn avio_flush(s: *mut AVIOContext);
}
extern "C" {
    /**
 * Read size bytes from AVIOContext into buf.
 * @return number of bytes read or AVERROR
 */
    pub fn avio_read(s: *mut AVIOContext, buf: *mut libc::c_uchar,
                     size: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * @name Functions for reading from AVIOContext
 * @{
 *
 * @note return 0 if EOF, so you cannot use it if EOF handling is
 *       necessary
 */
    pub fn avio_r8(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_rl16(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl24(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl32(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_rb16(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb24(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb32(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    /**
 * Read a string from pb into buf. The reading will terminate when either
 * a NULL character was encountered, maxlen bytes have been read, or nothing
 * more can be read from pb. The result is guaranteed to be NULL-terminated, it
 * will be truncated if buf is too small.
 * Note that the string is not interpreted or validated in any way, it
 * might get truncated in the middle of a sequence for multi-byte encodings.
 *
 * @return number of bytes read (is always <= maxlen).
 * If reading ends on EOF or error, the return value will be one more than
 * bytes actually read.
 */
    pub fn avio_get_str(pb: *mut AVIOContext, maxlen: libc::c_int,
                        buf: *mut libc::c_char, buflen: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Read a UTF-16 string from pb and convert it to UTF-8.
 * The reading will terminate when either a null or invalid character was
 * encountered or maxlen bytes have been read.
 * @return number of bytes read (is always <= maxlen)
 */
    pub fn avio_get_str16le(pb: *mut AVIOContext, maxlen: libc::c_int,
                            buf: *mut libc::c_char, buflen: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn avio_get_str16be(pb: *mut AVIOContext, maxlen: libc::c_int,
                            buf: *mut libc::c_char, buflen: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Create and initialize a AVIOContext for accessing the
 * resource indicated by url.
 * @note When the resource indicated by url has been opened in
 * read+write mode, the AVIOContext can be used only for writing.
 *
 * @param s Used to return the pointer to the created AVIOContext.
 * In case of failure the pointed to value is set to NULL.
 * @param url resource to access
 * @param flags flags which control how the resource indicated by url
 * is to be opened
 * @return >= 0 in case of success, a negative value corresponding to an
 * AVERROR code in case of failure
 */
    pub fn avio_open(s: *mut *mut AVIOContext, url: *const libc::c_char,
                     flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Create and initialize a AVIOContext for accessing the
 * resource indicated by url.
 * @note When the resource indicated by url has been opened in
 * read+write mode, the AVIOContext can be used only for writing.
 *
 * @param s Used to return the pointer to the created AVIOContext.
 * In case of failure the pointed to value is set to NULL.
 * @param url resource to access
 * @param flags flags which control how the resource indicated by url
 * is to be opened
 * @param int_cb an interrupt callback to be used at the protocols level
 * @param options  A dictionary filled with protocol-private options. On return
 * this parameter will be destroyed and replaced with a dict containing options
 * that were not found. May be NULL.
 * @return >= 0 in case of success, a negative value corresponding to an
 * AVERROR code in case of failure
 */
    pub fn avio_open2(s: *mut *mut AVIOContext, url: *const libc::c_char,
                      flags: libc::c_int, int_cb: *const AVIOInterruptCB,
                      options: *mut *mut AVDictionary) -> libc::c_int;
}
extern "C" {
    /**
 * Close the resource accessed by the AVIOContext s and free it.
 * This function can only be used if s was opened by avio_open().
 *
 * The internal buffer is automatically flushed before closing the
 * resource.
 *
 * @return 0 on success, an AVERROR < 0 on error.
 * @see avio_closep
 */
    pub fn avio_close(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /**
 * Close the resource accessed by the AVIOContext *s, free it
 * and set the pointer pointing to it to NULL.
 * This function can only be used if s was opened by avio_open().
 *
 * The internal buffer is automatically flushed before closing the
 * resource.
 *
 * @return 0 on success, an AVERROR < 0 on error.
 * @see avio_close
 */
    pub fn avio_closep(s: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /**
 * Open a write only memory stream.
 *
 * @param s new IO context
 * @return zero if no error.
 */
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /**
 * Return the written size and a pointer to the buffer.
 * The AVIOContext stream is left intact.
 * The buffer must NOT be freed.
 * No padding is added to the buffer.
 *
 * @param s IO context
 * @param pbuffer pointer to a byte buffer
 * @return the length of the byte buffer
 */
    pub fn avio_get_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8)
     -> libc::c_int;
}
extern "C" {
    /**
 * Return the written size and a pointer to the buffer. The buffer
 * must be freed with av_free().
 * Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
 *
 * @param s IO context
 * @param pbuffer pointer to a byte buffer
 * @return the length of the byte buffer
 */
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8)
     -> libc::c_int;
}
extern "C" {
    /**
 * Iterate through names of available protocols.
 *
 * @param opaque A private pointer representing current protocol.
 *        It must be a pointer to NULL on first iteration and will
 *        be updated by successive calls to avio_enum_protocols.
 * @param output If set to 1, iterate over output protocols,
 *               otherwise over input protocols.
 *
 * @return A static string containing the name of current protocol or NULL
 */
    pub fn avio_enum_protocols(opaque: *mut *mut libc::c_void,
                               output: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    /**
 * Pause and resume playing - only meaningful if using a network streaming
 * protocol (e.g. MMS).
 *
 * @param h     IO context from which to call the read_pause function pointer
 * @param pause 1 for pause, 0 for resume
 */
    pub fn avio_pause(h: *mut AVIOContext, pause: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Seek to a given timestamp relative to some component stream.
 * Only meaningful if using a network streaming protocol (e.g. MMS.).
 *
 * @param h IO context from which to call the seek function pointers
 * @param stream_index The stream index that the timestamp is relative to.
 *        If stream_index is (-1) the timestamp should be in AV_TIME_BASE
 *        units from the beginning of the presentation.
 *        If a stream_index >= 0 is used and the protocol does not support
 *        seeking based on component streams, the call will fail.
 * @param timestamp timestamp in AVStream.time_base units
 *        or if there is no stream specified then in AV_TIME_BASE units.
 * @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
 *        and AVSEEK_FLAG_ANY. The protocol may silently ignore
 *        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
 *        fail if used and not supported.
 * @return >= 0 on success
 * @see AVInputFormat::read_seek
 */
    pub fn avio_seek_time(h: *mut AVIOContext, stream_index: libc::c_int,
                          timestamp: i64, flags: libc::c_int) -> i64;
}
extern "C" {
    /**
 * Read contents of h into print buffer, up to max_size bytes, or up to EOF.
 *
 * @return 0 for success (max_size bytes read or EOF reached), negative error
 * code otherwise
 */
    pub fn avio_read_to_bprint(h: *mut AVIOContext, pb: *mut AVBPrint,
                               max_size: usize) -> libc::c_int;
}
extern "C" {
    /**
 * Accept and allocate a client context on a server context.
 * @param  s the server context
 * @param  c the client context, must be unallocated
 * @return   >= 0 on success or a negative value corresponding
 *           to an AVERROR on failure
 */
    pub fn avio_accept(s: *mut AVIOContext, c: *mut *mut AVIOContext)
     -> libc::c_int;
}
extern "C" {
    /**
 * Perform one step of the protocol handshake to accept a new client.
 * This function must be called on a client returned by avio_accept() before
 * using it as a read/write context.
 * It is separate from avio_accept() because it may block.
 * A step of the handshake is defined by places where the application may
 * decide to change the proceedings.
 * For example, on a protocol with a request header and a reply header, each
 * one can constitute a step because the application may use the parameters
 * from the request to change parameters in the reply; or each individual
 * chunk of the request can constitute a step.
 * If the handshake is already finished, avio_handshake() does nothing and
 * returns 0 immediately.
 *
 * @param  c the client context to perform the handshake on
 * @return   0   on a complete and successful handshake
 *           > 0 if the handshake progressed, but is not complete
 *           < 0 for an AVERROR code
 */
    pub fn avio_handshake(c: *mut AVIOContext) -> libc::c_int;
}
/**
 * Format I/O context.
 * New fields can be added to the end with minor version bumps.
 * Removal, reordering and changes to existing fields require a major
 * version bump.
 * sizeof(AVFormatContext) must not be used outside libav*, use
 * avformat_alloc_context() to create an AVFormatContext.
 *
 * Fields can be accessed through AVOptions (av_opt*),
 * the name string used matches the associated command line parameter name and
 * can be found in libavformat/options_table.h.
 * The AVOption/command line parameter names differ in some cases from the C
 * structure field names for historic reasons or brevity.
 */
#[repr(C)]
pub struct AVFormatContext {
    /**
     * A class for logging and @ref avoptions. Set by avformat_alloc_context().
     * Exports (de)muxer private options if they exist.
     */
    pub av_class: *const AVClass,
    /**
     * The input container format.
     *
     * Demuxing only, set by avformat_open_input().
     */
    pub iformat: *mut AVInputFormat,
    /**
     * The output container format.
     *
     * Muxing only, must be set by the caller before avformat_write_header().
     */
    pub oformat: *mut AVOutputFormat,
    /**
     * Format private data. This is an AVOptions-enabled struct
     * if and only if iformat/oformat.priv_class is not NULL.
     *
     * - muxing: set by avformat_write_header()
     * - demuxing: set by avformat_open_input()
     */
    pub priv_data: *mut libc::c_void,
    /**
     * I/O context.
     *
     * - demuxing: either set by the user before avformat_open_input() (then
     *             the user must close it manually) or set by avformat_open_input().
     * - muxing: set by the user before avformat_write_header(). The caller must
     *           take care of closing / freeing the IO context.
     *
     * Do NOT set this field if AVFMT_NOFILE flag is set in
     * iformat/oformat.flags. In such a case, the (de)muxer will handle
     * I/O in some other way and this field will be NULL.
     */
    pub pb: *mut AVIOContext,
    /**
     * Flags signalling stream properties. A combination of AVFMTCTX_*.
     * Set by libavformat.
     */
    pub ctx_flags: libc::c_int,
    /**
     * Number of elements in AVFormatContext.streams.
     *
     * Set by avformat_new_stream(), must not be modified by any other code.
     */
    pub nb_streams: libc::c_uint,
    /**
     * A list of all streams in the file. New streams are created with
     * avformat_new_stream().
     *
     * - demuxing: streams are created by libavformat in avformat_open_input().
     *             If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also
     *             appear in av_read_frame().
     * - muxing: streams are created by the user before avformat_write_header().
     *
     * Freed by libavformat in avformat_free_context().
     */
    pub streams: *mut *mut AVStream,
    /**
     * input or output filename
     *
     * - demuxing: set by avformat_open_input()
     * - muxing: may be set by the caller before avformat_write_header()
     */
    pub filename: [libc::c_char; 1024usize],
    /**
     * Position of the first frame of the component, in
     * AV_TIME_BASE fractional seconds. NEVER set this value directly:
     * It is deduced from the AVStream values.
     *
     * Demuxing only, set by libavformat.
     */
    pub start_time: i64,
    /**
     * Duration of the stream, in AV_TIME_BASE fractional
     * seconds. Only set this value if you know none of the individual stream
     * durations and also do not set any of them. This is deduced from the
     * AVStream values if not set.
     *
     * Demuxing only, set by libavformat.
     */
    pub duration: i64,
    /**
     * Total stream bitrate in bit/s, 0 if not
     * available. Never set it directly if the file_size and the
     * duration are known as FFmpeg can compute it automatically.
     */
    pub bit_rate: i64,
    pub packet_size: libc::c_uint,
    pub max_delay: libc::c_int,
    /**
     * Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.
     * Set by the user before avformat_open_input() / avformat_write_header().
     */
    pub flags: libc::c_int,
    /**
     * Maximum size of the data read from input for determining
     * the input container format.
     * Demuxing only, set by the caller before avformat_open_input().
     */
    pub probesize: i64,
    /**
     * Maximum duration (in AV_TIME_BASE units) of the data read
     * from input in avformat_find_stream_info().
     * Demuxing only, set by the caller before avformat_find_stream_info().
     * Can be set to 0 to let avformat choose using a heuristic.
     */
    pub max_analyze_duration: i64,
    pub key: *const u8,
    pub keylen: libc::c_int,
    pub nb_programs: libc::c_uint,
    pub programs: *mut *mut AVProgram,
    /**
     * Forced video codec_id.
     * Demuxing: Set by user.
     */
    pub video_codec_id: AVCodecID,
    /**
     * Forced audio codec_id.
     * Demuxing: Set by user.
     */
    pub audio_codec_id: AVCodecID,
    /**
     * Forced subtitle codec_id.
     * Demuxing: Set by user.
     */
    pub subtitle_codec_id: AVCodecID,
    /**
     * Maximum amount of memory in bytes to use for the index of each stream.
     * If the index exceeds this size, entries will be discarded as
     * needed to maintain a smaller size. This can lead to slower or less
     * accurate seeking (depends on demuxer).
     * Demuxers for which a full in-memory index is mandatory will ignore
     * this.
     * - muxing: unused
     * - demuxing: set by user
     */
    pub max_index_size: libc::c_uint,
    /**
     * Maximum amount of memory in bytes to use for buffering frames
     * obtained from realtime capture devices.
     */
    pub max_picture_buffer: libc::c_uint,
    /**
     * Number of chapters in AVChapter array.
     * When muxing, chapters are normally written in the file header,
     * so nb_chapters should normally be initialized before write_header
     * is called. Some muxers (e.g. mov and mkv) can also write chapters
     * in the trailer.  To write chapters in the trailer, nb_chapters
     * must be zero when write_header is called and non-zero when
     * write_trailer is called.
     * - muxing: set by user
     * - demuxing: set by libavformat
     */
    pub nb_chapters: libc::c_uint,
    pub chapters: *mut *mut AVChapter,
    /**
     * Metadata that applies to the whole file.
     *
     * - demuxing: set by libavformat in avformat_open_input()
     * - muxing: may be set by the caller before avformat_write_header()
     *
     * Freed by libavformat in avformat_free_context().
     */
    pub metadata: *mut AVDictionary,
    /**
     * Start time of the stream in real world time, in microseconds
     * since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the
     * stream was captured at this real world time.
     * - muxing: Set by the caller before avformat_write_header(). If set to
     *           either 0 or AV_NOPTS_VALUE, then the current wall-time will
     *           be used.
     * - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that
     *             the value may become known after some number of frames
     *             have been received.
     */
    pub start_time_realtime: i64,
    /**
     * The number of frames used for determining the framerate in
     * avformat_find_stream_info().
     * Demuxing only, set by the caller before avformat_find_stream_info().
     */
    pub fps_probe_size: libc::c_int,
    /**
     * Error recognition; higher values will detect more errors but may
     * misdetect some more or less valid parts as errors.
     * Demuxing only, set by the caller before avformat_open_input().
     */
    pub error_recognition: libc::c_int,
    /**
     * Custom interrupt callbacks for the I/O layer.
     *
     * demuxing: set by the user before avformat_open_input().
     * muxing: set by the user before avformat_write_header()
     * (mainly useful for AVFMT_NOFILE formats). The callback
     * should also be passed to avio_open2() if it's used to
     * open the file.
     */
    pub interrupt_callback: AVIOInterruptCB,
    /**
     * Flags to enable debugging.
     */
    pub debug: libc::c_int,
    /**
     * Maximum buffering duration for interleaving.
     *
     * To ensure all the streams are interleaved correctly,
     * av_interleaved_write_frame() will wait until it has at least one packet
     * for each stream before actually writing any packets to the output file.
     * When some streams are "sparse" (i.e. there are large gaps between
     * successive packets), this can result in excessive buffering.
     *
     * This field specifies the maximum difference between the timestamps of the
     * first and the last packet in the muxing queue, above which libavformat
     * will output a packet regardless of whether it has queued a packet for all
     * the streams.
     *
     * Muxing only, set by the caller before avformat_write_header().
     */
    pub max_interleave_delta: i64,
    /**
     * Allow non-standard and experimental extension
     * @see AVCodecContext.strict_std_compliance
     */
    pub strict_std_compliance: libc::c_int,
    /**
     * Flags for the user to detect events happening on the file. Flags must
     * be cleared by the user once the event has been handled.
     * A combination of AVFMT_EVENT_FLAG_*.
     */
    pub event_flags: libc::c_int,
    /**
     * Maximum number of packets to read while waiting for the first timestamp.
     * Decoding only.
     */
    pub max_ts_probe: libc::c_int,
    /**
     * Avoid negative timestamps during muxing.
     * Any value of the AVFMT_AVOID_NEG_TS_* constants.
     * Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)
     * - muxing: Set by user
     * - demuxing: unused
     */
    pub avoid_negative_ts: libc::c_int,
    /**
     * Transport stream id.
     * This will be moved into demuxer private options. Thus no API/ABI compatibility
     */
    pub ts_id: libc::c_int,
    /**
     * Audio preload in microseconds.
     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.
     * - encoding: Set by user
     * - decoding: unused
     */
    pub audio_preload: libc::c_int,
    /**
     * Max chunk time in microseconds.
     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.
     * - encoding: Set by user
     * - decoding: unused
     */
    pub max_chunk_duration: libc::c_int,
    /**
     * Max chunk size in bytes
     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.
     * - encoding: Set by user
     * - decoding: unused
     */
    pub max_chunk_size: libc::c_int,
    /**
     * forces the use of wallclock timestamps as pts/dts of packets
     * This has undefined results in the presence of B frames.
     * - encoding: unused
     * - decoding: Set by user
     */
    pub use_wallclock_as_timestamps: libc::c_int,
    /**
     * avio flags, used to force AVIO_FLAG_DIRECT.
     * - encoding: unused
     * - decoding: Set by user
     */
    pub avio_flags: libc::c_int,
    /**
     * The duration field can be estimated through various ways, and this field can be used
     * to know how the duration was estimated.
     * - encoding: unused
     * - decoding: Read by user
     */
    pub duration_estimation_method: AVDurationEstimationMethod,
    /**
     * Skip initial bytes when opening stream
     * - encoding: unused
     * - decoding: Set by user
     */
    pub skip_initial_bytes: i64,
    /**
     * Correct single timestamp overflows
     * - encoding: unused
     * - decoding: Set by user
     */
    pub correct_ts_overflow: libc::c_uint,
    /**
     * Force seeking to any (also non key) frames.
     * - encoding: unused
     * - decoding: Set by user
     */
    pub seek2any: libc::c_int,
    /**
     * Flush the I/O context after each packet.
     * - encoding: Set by user
     * - decoding: unused
     */
    pub flush_packets: libc::c_int,
    /**
     * format probing score.
     * The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes
     * the format.
     * - encoding: unused
     * - decoding: set by avformat, read by user
     */
    pub probe_score: libc::c_int,
    /**
     * number of bytes to read maximally to identify format.
     * - encoding: unused
     * - decoding: set by user
     */
    pub format_probesize: libc::c_int,
    /**
     * ',' separated list of allowed decoders.
     * If NULL then all are allowed
     * - encoding: unused
     * - decoding: set by user
     */
    pub codec_whitelist: *mut libc::c_char,
    /**
     * ',' separated list of allowed demuxers.
     * If NULL then all are allowed
     * - encoding: unused
     * - decoding: set by user
     */
    pub format_whitelist: *mut libc::c_char,
    /**
     * An opaque field for libavformat internal usage.
     * Must not be accessed in any way by callers.
     */
    pub internal: *mut AVFormatInternal,
    /**
     * IO repositioned flag.
     * This is set by avformat when the underlaying IO context read pointer
     * is repositioned, for example when doing byte based seeking.
     * Demuxers can use the flag to detect such changes.
     */
    pub io_repositioned: libc::c_int,
    /**
     * Forced video codec.
     * This allows forcing a specific decoder, even when there are multiple with
     * the same codec_id.
     * Demuxing: Set by user
     */
    pub video_codec: *mut AVCodec,
    /**
     * Forced audio codec.
     * This allows forcing a specific decoder, even when there are multiple with
     * the same codec_id.
     * Demuxing: Set by user
     */
    pub audio_codec: *mut AVCodec,
    /**
     * Forced subtitle codec.
     * This allows forcing a specific decoder, even when there are multiple with
     * the same codec_id.
     * Demuxing: Set by user
     */
    pub subtitle_codec: *mut AVCodec,
    /**
     * Forced data codec.
     * This allows forcing a specific decoder, even when there are multiple with
     * the same codec_id.
     * Demuxing: Set by user
     */
    pub data_codec: *mut AVCodec,
    /**
     * Number of bytes to be written as padding in a metadata header.
     * Demuxing: Unused.
     * Muxing: Set by user via av_format_set_metadata_header_padding.
     */
    pub metadata_header_padding: libc::c_int,
    /**
     * User data.
     * This is a place for some private data of the user.
     */
    pub opaque: *mut libc::c_void,
    /**
     * Callback used by devices to communicate with application.
     */
    pub control_message_cb: av_format_control_message,
    /**
     * Output timestamp offset, in microseconds.
     * Muxing: set by user
     */
    pub output_ts_offset: i64,
    /**
     * dump format separator.
     * can be ", " or "\n      " or anything else
     * - muxing: Set by user.
     * - demuxing: Set by user.
     */
    pub dump_separator: *mut u8,
    /**
     * Forced Data codec_id.
     * Demuxing: Set by user.
     */
    pub data_codec_id: AVCodecID,
    /**
     * Called to open further IO contexts when needed for demuxing.
     *
     * This can be set by the user application to perform security checks on
     * the URLs before opening them.
     * The function should behave like avio_open2(), AVFormatContext is provided
     * as contextual information and to reach AVFormatContext.opaque.
     *
     * If NULL then some simple checks are used together with avio_open2().
     *
     * Must not be accessed directly from outside avformat.
     * @See av_format_set_open_cb()
     *
     * Demuxing: Set by user.
     *
     * @deprecated Use io_open and io_close.
     */
    pub open_cb: ::std::option::Option<unsafe extern "C" fn(s:
                                                                *mut AVFormatContext,
                                                            p:
                                                                *mut *mut AVIOContext,
                                                            url:
                                                                *const libc::c_char,
                                                            flags:
                                                                libc::c_int,
                                                            int_cb:
                                                                *const AVIOInterruptCB,
                                                            options:
                                                                *mut *mut AVDictionary)
                                           -> libc::c_int>,
    /**
     * ',' separated list of allowed protocols.
     * - encoding: unused
     * - decoding: set by user
     */
    pub protocol_whitelist: *mut libc::c_char,
    pub io_open: ::std::option::Option<unsafe extern "C" fn(s:
                                                                *mut AVFormatContext,
                                                            pb:
                                                                *mut *mut AVIOContext,
                                                            url:
                                                                *const libc::c_char,
                                                            flags:
                                                                libc::c_int,
                                                            options:
                                                                *mut *mut AVDictionary)
                                           -> libc::c_int>,
    /**
     * A callback for closing the streams opened with AVFormatContext.io_open().
     */
    pub io_close: ::std::option::Option<unsafe extern "C" fn(s:
                                                                 *mut AVFormatContext,
                                                             pb:
                                                                 *mut AVIOContext)>,
    /**
     * ',' separated list of disallowed protocols.
     * - encoding: unused
     * - decoding: set by user
     */
    pub protocol_blacklist: *mut libc::c_char,
    /**
     * The maximum number of streams.
     * - encoding: unused
     * - decoding: set by user
     */
    pub max_streams: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVFormatContext() {
    assert_eq!(::std::mem::size_of::<AVFormatContext>() , 1488usize , concat !
               ( "Size of: " , stringify ! ( AVFormatContext ) ));
    assert_eq! (::std::mem::align_of::<AVFormatContext>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AVFormatContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . av_class as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( av_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . iformat as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( iformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . oformat as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( oformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . priv_data as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( priv_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . pb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( pb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . ctx_flags as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( ctx_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . nb_streams as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( nb_streams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . streams as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( streams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . filename as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . start_time as *
                const _ as usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( start_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . duration as * const
                _ as usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . bit_rate as * const
                _ as usize } , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( bit_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . packet_size as *
                const _ as usize } , 1104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( packet_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . max_delay as *
                const _ as usize } , 1108usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . flags as * const _
                as usize } , 1112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . probesize as *
                const _ as usize } , 1120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( probesize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) .
                max_analyze_duration as * const _ as usize } , 1128usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_analyze_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . key as * const _ as
                usize } , 1136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . keylen as * const _
                as usize } , 1144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( keylen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . nb_programs as *
                const _ as usize } , 1148usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( nb_programs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . programs as * const
                _ as usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( programs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . video_codec_id as *
                const _ as usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( video_codec_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . audio_codec_id as *
                const _ as usize } , 1164usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( audio_codec_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . subtitle_codec_id
                as * const _ as usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( subtitle_codec_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . max_index_size as *
                const _ as usize } , 1172usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_index_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . max_picture_buffer
                as * const _ as usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_picture_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . nb_chapters as *
                const _ as usize } , 1180usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( nb_chapters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . chapters as * const
                _ as usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( chapters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . metadata as * const
                _ as usize } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( metadata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . start_time_realtime
                as * const _ as usize } , 1200usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( start_time_realtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . fps_probe_size as *
                const _ as usize } , 1208usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( fps_probe_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . error_recognition
                as * const _ as usize } , 1212usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( error_recognition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . interrupt_callback
                as * const _ as usize } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( interrupt_callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . debug as * const _
                as usize } , 1232usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( debug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) .
                max_interleave_delta as * const _ as usize } , 1240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_interleave_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) .
                strict_std_compliance as * const _ as usize } , 1248usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( strict_std_compliance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . event_flags as *
                const _ as usize } , 1252usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( event_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . max_ts_probe as *
                const _ as usize } , 1256usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_ts_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . avoid_negative_ts
                as * const _ as usize } , 1260usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( avoid_negative_ts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . ts_id as * const _
                as usize } , 1264usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( ts_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . audio_preload as *
                const _ as usize } , 1268usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( audio_preload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . max_chunk_duration
                as * const _ as usize } , 1272usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_chunk_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . max_chunk_size as *
                const _ as usize } , 1276usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_chunk_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) .
                use_wallclock_as_timestamps as * const _ as usize } ,
                1280usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( use_wallclock_as_timestamps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . avio_flags as *
                const _ as usize } , 1284usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( avio_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) .
                duration_estimation_method as * const _ as usize } , 1288usize
                , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( duration_estimation_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . skip_initial_bytes
                as * const _ as usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( skip_initial_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . correct_ts_overflow
                as * const _ as usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( correct_ts_overflow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . seek2any as * const
                _ as usize } , 1308usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( seek2any ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . flush_packets as *
                const _ as usize } , 1312usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( flush_packets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . probe_score as *
                const _ as usize } , 1316usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( probe_score ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . format_probesize as
                * const _ as usize } , 1320usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( format_probesize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . codec_whitelist as
                * const _ as usize } , 1328usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( codec_whitelist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . format_whitelist as
                * const _ as usize } , 1336usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( format_whitelist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . internal as * const
                _ as usize } , 1344usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . io_repositioned as
                * const _ as usize } , 1352usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( io_repositioned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . video_codec as *
                const _ as usize } , 1360usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( video_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . audio_codec as *
                const _ as usize } , 1368usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( audio_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . subtitle_codec as *
                const _ as usize } , 1376usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( subtitle_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . data_codec as *
                const _ as usize } , 1384usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( data_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) .
                metadata_header_padding as * const _ as usize } , 1392usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( metadata_header_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . opaque as * const _
                as usize } , 1400usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . control_message_cb
                as * const _ as usize } , 1408usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( control_message_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . output_ts_offset as
                * const _ as usize } , 1416usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( output_ts_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . dump_separator as *
                const _ as usize } , 1424usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( dump_separator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . data_codec_id as *
                const _ as usize } , 1432usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( data_codec_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . open_cb as * const
                _ as usize } , 1440usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( open_cb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . protocol_whitelist
                as * const _ as usize } , 1448usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( protocol_whitelist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . io_open as * const
                _ as usize } , 1456usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( io_open ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . io_close as * const
                _ as usize } , 1464usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( io_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . protocol_blacklist
                as * const _ as usize } , 1472usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( protocol_blacklist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFormatContext ) ) . max_streams as *
                const _ as usize } , 1480usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFormatContext ) ,
                "::" , stringify ! ( max_streams ) ));
}
/**
 * List of devices.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVDeviceInfoList {
    /**< list of autodetected devices */
    pub devices: *mut *mut AVDeviceInfo,
    /**< number of autodetected devices */
    pub nb_devices: libc::c_int,
    /**< index of default device or -1 if no default */
    pub default_device: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceInfoList() {
    assert_eq!(::std::mem::size_of::<AVDeviceInfoList>() , 16usize , concat !
               ( "Size of: " , stringify ! ( AVDeviceInfoList ) ));
    assert_eq! (::std::mem::align_of::<AVDeviceInfoList>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AVDeviceInfoList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceInfoList ) ) . devices as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceInfoList ) ,
                "::" , stringify ! ( devices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceInfoList ) ) . nb_devices as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceInfoList ) ,
                "::" , stringify ! ( nb_devices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceInfoList ) ) . default_device as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceInfoList ) ,
                "::" , stringify ! ( default_device ) ));
}
impl Clone for AVDeviceInfoList {
    fn clone(&self) -> Self { *self }
}
/**
 * Structure describes device capabilities.
 *
 * It is used by devices in conjunction with av_device_capabilities AVOption table
 * to implement capabilities probing API based on AVOption API. Should not be used directly.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVDeviceCapabilitiesQuery {
    pub av_class: *const AVClass,
    pub device_context: *mut AVFormatContext,
    pub codec: AVCodecID,
    pub sample_format: AVSampleFormat,
    pub pixel_format: AVPixelFormat,
    pub sample_rate: libc::c_int,
    pub channels: libc::c_int,
    pub channel_layout: i64,
    pub window_width: libc::c_int,
    pub window_height: libc::c_int,
    pub frame_width: libc::c_int,
    pub frame_height: libc::c_int,
    pub fps: AVRational,
}
#[test]
fn bindgen_test_layout_AVDeviceCapabilitiesQuery() {
    assert_eq!(::std::mem::size_of::<AVDeviceCapabilitiesQuery>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( AVDeviceCapabilitiesQuery ) ));
    assert_eq! (::std::mem::align_of::<AVDeviceCapabilitiesQuery>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AVDeviceCapabilitiesQuery )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) . av_class
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! ( av_class )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                device_context as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! (
                device_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) . codec as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! ( codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                sample_format as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! (
                sample_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                pixel_format as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! (
                pixel_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                sample_rate as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! ( sample_rate
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) . channels
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! ( channels )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                channel_layout as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! (
                channel_layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                window_width as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! (
                window_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                window_height as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! (
                window_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                frame_width as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! ( frame_width
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) .
                frame_height as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! (
                frame_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceCapabilitiesQuery ) ) . fps as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                AVDeviceCapabilitiesQuery ) , "::" , stringify ! ( fps ) ));
}
impl Clone for AVDeviceCapabilitiesQuery {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Allocate and read the payload of a packet and initialize its
 * fields with default values.
 *
 * @param s    associated IO context
 * @param pkt packet
 * @param size desired payload size
 * @return >0 (read size) if OK, AVERROR_xxx otherwise
 */
    pub fn av_get_packet(s: *mut AVIOContext, pkt: *mut AVPacket,
                         size: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Read data and append it to the current content of the AVPacket.
 * If pkt->size is 0 this is identical to av_get_packet.
 * Note that this uses av_grow_packet and thus involves a realloc
 * which is inefficient. Thus this function should only be used
 * when there is no reasonable way to know (an upper bound of)
 * the final size.
 *
 * @param s    associated IO context
 * @param pkt packet
 * @param size amount of data to read
 * @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data
 *         will not be lost even if an error occurs.
 */
    pub fn av_append_packet(s: *mut AVIOContext, pkt: *mut AVPacket,
                            size: libc::c_int) -> libc::c_int;
}
/**
 * The exact value of the fractional number is: 'val + num / den'.
 * num is assumed to be 0 <= num < den.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFrac {
    pub val: i64,
    pub num: i64,
    pub den: i64,
}
#[test]
fn bindgen_test_layout_AVFrac() {
    assert_eq!(::std::mem::size_of::<AVFrac>() , 24usize , concat ! (
               "Size of: " , stringify ! ( AVFrac ) ));
    assert_eq! (::std::mem::align_of::<AVFrac>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVFrac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrac ) ) . val as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrac ) , "::" ,
                stringify ! ( val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrac ) ) . num as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrac ) , "::" ,
                stringify ! ( num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFrac ) ) . den as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFrac ) , "::" ,
                stringify ! ( den ) ));
}
impl Clone for AVFrac {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecTag {
    _unused: [u8; 0],
}
/**
 * This structure contains the data a format has to probe a file.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVProbeData {
    pub filename: *const libc::c_char,
    /**< Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero. */
    pub buf: *mut libc::c_uchar,
    /**< Size of buf except extra allocated bytes */
    pub buf_size: libc::c_int,
    /**< mime_type, when known. */
    pub mime_type: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVProbeData() {
    assert_eq!(::std::mem::size_of::<AVProbeData>() , 32usize , concat ! (
               "Size of: " , stringify ! ( AVProbeData ) ));
    assert_eq! (::std::mem::align_of::<AVProbeData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVProbeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProbeData ) ) . filename as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProbeData ) , "::" ,
                stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProbeData ) ) . buf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProbeData ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProbeData ) ) . buf_size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProbeData ) , "::" ,
                stringify ! ( buf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProbeData ) ) . mime_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProbeData ) , "::" ,
                stringify ! ( mime_type ) ));
}
impl Clone for AVProbeData {
    fn clone(&self) -> Self { *self }
}
/**
 * @addtogroup lavf_encoding
 * @{
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVOutputFormat {
    pub name: *const libc::c_char,
    /**
     * Descriptive name for the format, meant to be more human-readable
     * than name. You should use the NULL_IF_CONFIG_SMALL() macro
     * to define it.
     */
    pub long_name: *const libc::c_char,
    pub mime_type: *const libc::c_char,
    /**< comma-separated filename extensions */
    pub extensions: *const libc::c_char,
    /**< default audio codec */
    pub audio_codec: AVCodecID,
    /**< default video codec */
    pub video_codec: AVCodecID,
    /**< default subtitle codec */
    pub subtitle_codec: AVCodecID,
    /**
     * can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,
     * AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
     * AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,
     * AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE
     */
    pub flags: libc::c_int,
    /**
     * List of supported codec_id-codec_tag pairs, ordered by "better
     * choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
     */
    pub codec_tag: *const *const AVCodecTag,
    ///< AVClass for the private context
    pub priv_class: *const AVClass,
    /*****************************************************************
     * No fields below this line are part of the public API. They
     * may not be used outside of libavformat and can be changed and
     * removed at will.
     * New public fields should be added right above.
     *****************************************************************
     */
    pub next: *mut AVOutputFormat,
    /**
     * size of private data so that it can be allocated in the wrapper
     */
    pub priv_data_size: libc::c_int,
    pub write_header: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut AVFormatContext)
                                                -> libc::c_int>,
    /**
     * Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,
     * pkt can be NULL in order to flush data buffered in the muxer.
     * When flushing, return 0 if there still is more data to flush,
     * or 1 if everything was flushed and there is no more buffered
     * data.
     */
    pub write_packet: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut AVFormatContext,
                                                                 pkt:
                                                                     *mut AVPacket)
                                                -> libc::c_int>,
    pub write_trailer: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut AVFormatContext)
                                                 -> libc::c_int>,
    /**
     * Currently only used to set pixel format if not YUV420P.
     */
    pub interleave_packet: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut AVFormatContext,
                                                                      out:
                                                                          *mut AVPacket,
                                                                      in_:
                                                                          *mut AVPacket,
                                                                      flush:
                                                                          libc::c_int)
                                                     -> libc::c_int>,
    /**
     * Test if the given codec can be stored in this container.
     *
     * @return 1 if the codec is supported, 0 if it is not.
     *         A negative number if unknown.
     *         MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC
     */
    pub query_codec: ::std::option::Option<unsafe extern "C" fn(id: AVCodecID,
                                                                std_compliance:
                                                                    libc::c_int)
                                               -> libc::c_int>,
    pub get_output_timestamp: ::std::option::Option<unsafe extern "C" fn(s:
                                                                             *mut AVFormatContext,
                                                                         stream:
                                                                             libc::c_int,
                                                                         dts:
                                                                             *mut i64,
                                                                         wall:
                                                                             *mut i64)>,
    /**
     * Allows sending messages from application to device.
     */
    pub control_message: ::std::option::Option<unsafe extern "C" fn(s:
                                                                        *mut AVFormatContext,
                                                                    type_:
                                                                        libc::c_int,
                                                                    data:
                                                                        *mut libc::c_void,
                                                                    data_size:
                                                                        usize)
                                                   -> libc::c_int>,
    /**
     * Write an uncoded AVFrame.
     *
     * See av_write_uncoded_frame() for details.
     *
     * The library will free *frame afterwards, but the muxer can prevent it
     * by setting the pointer to NULL.
     */
    pub write_uncoded_frame: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut AVFormatContext,
                                                                        stream_index:
                                                                            libc::c_int,
                                                                        frame:
                                                                            *mut *mut AVFrame,
                                                                        flags:
                                                                            libc::c_uint)
                                                       -> libc::c_int>,
    /**
     * Returns device list with it properties.
     * @see avdevice_list_devices() for more details.
     */
    pub get_device_list: ::std::option::Option<unsafe extern "C" fn(s:
                                                                        *mut AVFormatContext,
                                                                    device_list:
                                                                        *mut AVDeviceInfoList)
                                                   -> libc::c_int>,
    /**
     * Initialize device capabilities submodule.
     * @see avdevice_capabilities_create() for more details.
     */
    pub create_device_capabilities: ::std::option::Option<unsafe extern "C" fn(s:
                                                                                   *mut AVFormatContext,
                                                                               caps:
                                                                                   *mut AVDeviceCapabilitiesQuery)
                                                              -> libc::c_int>,
    /**
     * Free device capabilities submodule.
     * @see avdevice_capabilities_free() for more details.
     */
    pub free_device_capabilities: ::std::option::Option<unsafe extern "C" fn(s:
                                                                                 *mut AVFormatContext,
                                                                             caps:
                                                                                 *mut AVDeviceCapabilitiesQuery)
                                                            -> libc::c_int>,
    /**< default data codec */
    pub data_codec: AVCodecID,
    /**
     * Initialize format. May allocate data here, and set any AVFormatContext or
     * AVStream parameters that need to be set before packets are sent.
     * This method must not write output.
     *
     * Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure
     *
     * Any allocations made here must be freed in deinit().
     */
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             *mut AVFormatContext)
                                        -> libc::c_int>,
    /**
     * Deinitialize format. If present, this is called whenever the muxer is being
     * destroyed, regardless of whether or not the header has been written.
     *
     * If a trailer is being written, this is called after write_trailer().
     *
     * This is called if init() fails as well.
     */
    pub deinit: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut AVFormatContext)>,
    /**
     * Set up any necessary bitstream filtering and extract any extra data needed
     * for the global header.
     * Return 0 if more packets from this stream must be checked; 1 if not.
     */
    pub check_bitstream: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut AVFormatContext,
                                                                    pkt:
                                                                        *const AVPacket)
                                                   -> libc::c_int>,
}
#[test]
fn bindgen_test_layout_AVOutputFormat() {
    assert_eq!(::std::mem::size_of::<AVOutputFormat>() , 200usize , concat ! (
               "Size of: " , stringify ! ( AVOutputFormat ) ));
    assert_eq! (::std::mem::align_of::<AVOutputFormat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVOutputFormat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . long_name as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( long_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . mime_type as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( mime_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . extensions as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( extensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . audio_codec as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( audio_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . video_codec as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( video_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . subtitle_codec as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( subtitle_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . flags as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . codec_tag as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( codec_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . priv_class as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( priv_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . next as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . priv_data_size as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( priv_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . write_header as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( write_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . write_packet as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( write_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . write_trailer as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( write_trailer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . interleave_packet as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( interleave_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . query_codec as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( query_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . get_output_timestamp
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( get_output_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . control_message as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( control_message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . write_uncoded_frame
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( write_uncoded_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . get_device_list as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( get_device_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) .
                create_device_capabilities as * const _ as usize } , 152usize
                , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( create_device_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) .
                free_device_capabilities as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( free_device_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . data_codec as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( data_codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . init as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . deinit as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( deinit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOutputFormat ) ) . check_bitstream as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOutputFormat ) , "::"
                , stringify ! ( check_bitstream ) ));
}
impl Clone for AVOutputFormat {
    fn clone(&self) -> Self { *self }
}
/**
 * @addtogroup lavf_decoding
 * @{
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVInputFormat {
    /**
     * A comma separated list of short names for the format. New names
     * may be appended with a minor bump.
     */
    pub name: *const libc::c_char,
    /**
     * Descriptive name for the format, meant to be more human-readable
     * than name. You should use the NULL_IF_CONFIG_SMALL() macro
     * to define it.
     */
    pub long_name: *const libc::c_char,
    /**
     * Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
     * AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
     * AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
     */
    pub flags: libc::c_int,
    /**
     * If extensions are defined, then no probe is done. You should
     * usually not use extension format guessing because it is not
     * reliable enough
     */
    pub extensions: *const libc::c_char,
    pub codec_tag: *const *const AVCodecTag,
    ///< AVClass for the private context
    pub priv_class: *const AVClass,
    /**
     * Comma-separated list of mime types.
     * It is used check for matching mime types while probing.
     * @see av_probe_input_format2
     */
    pub mime_type: *const libc::c_char,
    /*****************************************************************
     * No fields below this line are part of the public API. They
     * may not be used outside of libavformat and can be changed and
     * removed at will.
     * New public fields should be added right above.
     *****************************************************************
     */
    pub next: *mut AVInputFormat,
    /**
     * Raw demuxers store their codec ID here.
     */
    pub raw_codec_id: libc::c_int,
    /**
     * Size of private data so that it can be allocated in the wrapper.
     */
    pub priv_data_size: libc::c_int,
    /**
     * Tell if a given file has a chance of being parsed as this format.
     * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
     * big so you do not have to check for that unless you need more.
     */
    pub read_probe: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut AVProbeData)
                                              -> libc::c_int>,
    /**
     * Read the format header and initialize the AVFormatContext
     * structure. Return 0 if OK. 'avformat_new_stream' should be
     * called to create new streams.
     */
    pub read_header: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut AVFormatContext)
                                               -> libc::c_int>,
    /**
     * Read one packet and put it in 'pkt'. pts and flags are also
     * set. 'avformat_new_stream' can be called only if the flag
     * AVFMTCTX_NOHEADER is used and only in the calling thread (not in a
     * background thread).
     * @return 0 on success, < 0 on error.
     *         When returning an error, pkt must not have been allocated
     *         or must be freed before returning
     */
    pub read_packet: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut AVFormatContext,
                                                                pkt:
                                                                    *mut AVPacket)
                                               -> libc::c_int>,
    /**
     * Close the stream. The AVFormatContext and AVStreams are not
     * freed by this function
     */
    pub read_close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut AVFormatContext)
                                              -> libc::c_int>,
    /**
     * Seek to a given timestamp relative to the frames in
     * stream component stream_index.
     * @param stream_index Must not be -1.
     * @param flags Selects which direction should be preferred if no exact
     *              match is available.
     * @return >= 0 on success (but not necessarily the new offset)
     */
    pub read_seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut AVFormatContext,
                                                              stream_index:
                                                                  libc::c_int,
                                                              timestamp: i64,
                                                              flags:
                                                                  libc::c_int)
                                             -> libc::c_int>,
    /**
     * Get the next timestamp in stream[stream_index].time_base units.
     * @return the timestamp or AV_NOPTS_VALUE if an error occurred
     */
    pub read_timestamp: ::std::option::Option<unsafe extern "C" fn(s:
                                                                       *mut AVFormatContext,
                                                                   stream_index:
                                                                       libc::c_int,
                                                                   pos:
                                                                       *mut i64,
                                                                   pos_limit:
                                                                       i64)
                                                  -> i64>,
    /**
     * Start/resume playing - only meaningful if using a network-based format
     * (RTSP).
     */
    pub read_play: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut AVFormatContext)
                                             -> libc::c_int>,
    /**
     * Pause playing - only meaningful if using a network-based format
     * (RTSP).
     */
    pub read_pause: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut AVFormatContext)
                                              -> libc::c_int>,
    /**
     * Seek to timestamp ts.
     * Seeking will be done so that the point from which all active streams
     * can be presented successfully will be closest to ts and within min/max_ts.
     * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
     */
    pub read_seek2: ::std::option::Option<unsafe extern "C" fn(s:
                                                                   *mut AVFormatContext,
                                                               stream_index:
                                                                   libc::c_int,
                                                               min_ts: i64,
                                                               ts: i64,
                                                               max_ts: i64,
                                                               flags:
                                                                   libc::c_int)
                                              -> libc::c_int>,
    /**
     * Returns device list with it properties.
     * @see avdevice_list_devices() for more details.
     */
    pub get_device_list: ::std::option::Option<unsafe extern "C" fn(s:
                                                                        *mut AVFormatContext,
                                                                    device_list:
                                                                        *mut AVDeviceInfoList)
                                                   -> libc::c_int>,
    /**
     * Initialize device capabilities submodule.
     * @see avdevice_capabilities_create() for more details.
     */
    pub create_device_capabilities: ::std::option::Option<unsafe extern "C" fn(s:
                                                                                   *mut AVFormatContext,
                                                                               caps:
                                                                                   *mut AVDeviceCapabilitiesQuery)
                                                              -> libc::c_int>,
    /**
     * Free device capabilities submodule.
     * @see avdevice_capabilities_free() for more details.
     */
    pub free_device_capabilities: ::std::option::Option<unsafe extern "C" fn(s:
                                                                                 *mut AVFormatContext,
                                                                             caps:
                                                                                 *mut AVDeviceCapabilitiesQuery)
                                                            -> libc::c_int>,
}
#[test]
fn bindgen_test_layout_AVInputFormat() {
    assert_eq!(::std::mem::size_of::<AVInputFormat>() , 168usize , concat ! (
               "Size of: " , stringify ! ( AVInputFormat ) ));
    assert_eq! (::std::mem::align_of::<AVInputFormat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVInputFormat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . long_name as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( long_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . extensions as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( extensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . codec_tag as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( codec_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . priv_class as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( priv_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . mime_type as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( mime_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . next as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . raw_codec_id as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( raw_codec_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . priv_data_size as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( priv_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_probe as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_header as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_packet as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_close as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_seek as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_timestamp as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_play as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_play ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_pause as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_pause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . read_seek2 as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( read_seek2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) . get_device_list as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( get_device_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) .
                create_device_capabilities as * const _ as usize } , 152usize
                , concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( create_device_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVInputFormat ) ) .
                free_device_capabilities as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVInputFormat ) , "::"
                , stringify ! ( free_device_capabilities ) ));
}
impl Clone for AVInputFormat {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * @}
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVStreamParseType {
    AVSTREAM_PARSE_NONE = 0,
    AVSTREAM_PARSE_FULL = 1,
    AVSTREAM_PARSE_HEADERS = 2,
    AVSTREAM_PARSE_TIMESTAMPS = 3,
    AVSTREAM_PARSE_FULL_ONCE = 4,
    AVSTREAM_PARSE_FULL_RAW = 1463898624,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVIndexEntry {
    pub pos: i64,
    /**<
                               * Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available
                               * when seeking to this entry. That means preferable PTS on keyframe based formats.
                               * But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better
                               * is known
                               */
    pub timestamp: i64,
    pub _bitfield_1: u32,
    /**< Minimum distance between this and the previous keyframe, used to avoid unneeded searching. */
    pub min_distance: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVIndexEntry() {
    assert_eq!(::std::mem::size_of::<AVIndexEntry>() , 24usize , concat ! (
               "Size of: " , stringify ! ( AVIndexEntry ) ));
    assert_eq! (::std::mem::align_of::<AVIndexEntry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVIndexEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIndexEntry ) ) . pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIndexEntry ) , "::" ,
                stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIndexEntry ) ) . timestamp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIndexEntry ) , "::" ,
                stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVIndexEntry ) ) . min_distance as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AVIndexEntry ) , "::" ,
                stringify ! ( min_distance ) ));
}
impl Clone for AVIndexEntry {
    fn clone(&self) -> Self { *self }
}
impl AVIndexEntry {
    #[inline]
    pub fn flags(&self) -> libc::c_int {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 3u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: libc::c_int) {
        let mask = 3u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn size(&self) -> libc::c_int {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967292u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: libc::c_int) {
        let mask = 4294967292u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(flags: libc::c_int, size: libc::c_int) -> u32 {
        ({ ({ 0 } | ((flags as u32 as u32) << 0usize) & (3u64 as u32)) } |
             ((size as u32 as u32) << 2usize) & (4294967292u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStreamInternal {
    _unused: [u8; 0],
}
/**
 * Stream structure.
 * New fields can be added to the end with minor version bumps.
 * Removal, reordering and changes to existing fields require a major
 * version bump.
 * sizeof(AVStream) must not be used outside libav*.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVStream {
    /**< stream index in AVFormatContext */
    pub index: libc::c_int,
    /**
     * Format-specific stream ID.
     * decoding: set by libavformat
     * encoding: set by the user, replaced by libavformat if left unset
     */
    pub id: libc::c_int,
    /**
     * @deprecated use the codecpar struct instead
     */
    pub codec: *mut AVCodecContext,
    pub priv_data: *mut libc::c_void,
    /**
     * @deprecated this field is unused
     */
    pub pts: AVFrac,
    /**
     * This is the fundamental unit of time (in seconds) in terms
     * of which frame timestamps are represented.
     *
     * decoding: set by libavformat
     * encoding: May be set by the caller before avformat_write_header() to
     *           provide a hint to the muxer about the desired timebase. In
     *           avformat_write_header(), the muxer will overwrite this field
     *           with the timebase that will actually be used for the timestamps
     *           written into the file (which may or may not be related to the
     *           user-provided one, depending on the format).
     */
    pub time_base: AVRational,
    /**
     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.
     * Only set this if you are absolutely 100% sure that the value you set
     * it to really is the pts of the first frame.
     * This may be undefined (AV_NOPTS_VALUE).
     * @note The ASF header does NOT contain a correct start_time the ASF
     * demuxer must NOT set this.
     */
    pub start_time: i64,
    /**
     * Decoding: duration of the stream, in stream time base.
     * If a source file does not specify a duration, but does specify
     * a bitrate, this value will be estimated from bitrate and file size.
     *
     * Encoding: May be set by the caller before avformat_write_header() to
     * provide a hint to the muxer about the estimated duration.
     */
    pub duration: i64,
    ///< number of frames in this stream if known or 0
    pub nb_frames: i64,
    /**< AV_DISPOSITION_* bit field */
    pub disposition: libc::c_int,
    ///< Selects which packets can be discarded at will and do not need to be demuxed.
    pub discard: AVDiscard,
    /**
     * sample aspect ratio (0 if unknown)
     * - encoding: Set by user.
     * - decoding: Set by libavformat.
     */
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    /**
     * Average framerate
     *
     * - demuxing: May be set by libavformat when creating the stream or in
     *             avformat_find_stream_info().
     * - muxing: May be set by the caller before avformat_write_header().
     */
    pub avg_frame_rate: AVRational,
    /**
     * For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet
     * will contain the attached picture.
     *
     * decoding: set by libavformat, must not be modified by the caller.
     * encoding: unused
     */
    pub attached_pic: AVPacket,
    /**
     * An array of side data that applies to the whole stream (i.e. the
     * container does not allow it to change between packets).
     *
     * There may be no overlap between the side data in this array and side data
     * in the packets. I.e. a given side data is either exported by the muxer
     * (demuxing) / set by the caller (muxing) in this array, then it never
     * appears in the packets, or the side data is exported / sent through
     * the packets (always in the first packet where the value becomes known or
     * changes), then it does not appear in this array.
     *
     * - demuxing: Set by libavformat when the stream is created.
     * - muxing: May be set by the caller before avformat_write_header().
     *
     * Freed by libavformat in avformat_free_context().
     *
     * @see av_format_inject_global_side_data()
     */
    pub side_data: *mut AVPacketSideData,
    /**
     * The number of elements in the AVStream.side_data array.
     */
    pub nb_side_data: libc::c_int,
    /**
     * Flags for the user to detect events happening on the stream. Flags must
     * be cleared by the user once the event has been handled.
     * A combination of AVSTREAM_EVENT_FLAG_*.
     */
    pub event_flags: libc::c_int,
    pub info: *mut AVStream__bindgen_ty_1,
    /**< number of bits in pts (used for wrapping control) */
    pub pts_wrap_bits: libc::c_int,
    /**
     * Timestamp corresponding to the last dts sync point.
     *
     * Initialized when AVCodecParserContext.dts_sync_point >= 0 and
     * a DTS is received from the underlying container. Otherwise set to
     * AV_NOPTS_VALUE by default.
     */
    pub first_dts: i64,
    pub cur_dts: i64,
    pub last_IP_pts: i64,
    pub last_IP_duration: libc::c_int,
    /**
     * Number of packets to buffer for codec probing
     */
    pub probe_packets: libc::c_int,
    /**
     * Number of frames that have been demuxed during avformat_find_stream_info()
     */
    pub codec_info_nb_frames: libc::c_int,
    pub need_parsing: AVStreamParseType,
    pub parser: *mut AVCodecParserContext,
    /**
     * last packet in packet_buffer for this stream when muxing.
     */
    pub last_in_packet_buffer: *mut AVPacketList,
    pub probe_data: AVProbeData,
    pub pts_buffer: [i64; 17usize],
    /**< Only used if the format does not
                                    support seeking natively. */
    pub index_entries: *mut AVIndexEntry,
    pub nb_index_entries: libc::c_int,
    pub index_entries_allocated_size: libc::c_uint,
    /**
     * Real base framerate of the stream.
     * This is the lowest framerate with which all timestamps can be
     * represented accurately (it is the least common multiple of all
     * framerates in the stream). Note, this value is just a guess!
     * For example, if the time base is 1/90000 and all frames have either
     * approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.
     *
     * Code outside avformat should access this field using:
     * av_stream_get/set_r_frame_rate(stream)
     */
    pub r_frame_rate: AVRational,
    /**
     * Stream Identifier
     * This is the MPEG-TS stream identifier +1
     * 0 means unknown
     */
    pub stream_identifier: libc::c_int,
    pub interleaver_chunk_size: i64,
    pub interleaver_chunk_duration: i64,
    /**
     * stream probing state
     * -1   -> probing finished
     *  0   -> no probing requested
     * rest -> perform probing with request_probe being the minimum score to accept.
     * NOT PART OF PUBLIC API
     */
    pub request_probe: libc::c_int,
    /**
     * Indicates that everything up to the next keyframe
     * should be discarded.
     */
    pub skip_to_keyframe: libc::c_int,
    /**
     * Number of samples to skip at the start of the frame decoded from the next packet.
     */
    pub skip_samples: libc::c_int,
    /**
     * If not 0, the number of samples that should be skipped from the start of
     * the stream (the samples are removed from packets with pts==0, which also
     * assumes negative timestamps do not happen).
     * Intended for use with formats such as mp3 with ad-hoc gapless audio
     * support.
     */
    pub start_skip_samples: i64,
    /**
     * If not 0, the first audio sample that should be discarded from the stream.
     * This is broken by design (needs global sample count), but can't be
     * avoided for broken by design formats such as mp3 with ad-hoc gapless
     * audio support.
     */
    pub first_discard_sample: i64,
    /**
     * The sample after last sample that is intended to be discarded after
     * first_discard_sample. Works on frame boundaries only. Used to prevent
     * early EOF if the gapless info is broken (considered concatenated mp3s).
     */
    pub last_discard_sample: i64,
    /**
     * Number of internally decoded frames, used internally in libavformat, do not access
     * its lifetime differs from info which is why it is not in that structure.
     */
    pub nb_decoded_frames: libc::c_int,
    /**
     * Timestamp offset added to timestamps before muxing
     * NOT PART OF PUBLIC API
     */
    pub mux_ts_offset: i64,
    /**
     * Internal data to check for wrapping of the time stamp
     */
    pub pts_wrap_reference: i64,
    /**
     * Options for behavior, when a wrap is detected.
     *
     * Defined by AV_PTS_WRAP_ values.
     *
     * If correction is enabled, there are two possibilities:
     * If the first time stamp is near the wrap point, the wrap offset
     * will be subtracted, which will create negative time stamps.
     * Otherwise the offset will be added.
     */
    pub pts_wrap_behavior: libc::c_int,
    /**
     * Internal data to prevent doing update_initial_durations() twice
     */
    pub update_initial_durations_done: libc::c_int,
    /**
     * Internal data to generate dts from pts
     */
    pub pts_reorder_error: [i64; 17usize],
    pub pts_reorder_error_count: [u8; 17usize],
    /**
     * Internal data to analyze DTS and detect faulty mpeg streams
     */
    pub last_dts_for_order_check: i64,
    pub dts_ordered: u8,
    pub dts_misordered: u8,
    /**
     * Internal data to inject global side data
     */
    pub inject_global_side_data: libc::c_int,
    /**
     * String containing paris of key and values describing recommended encoder configuration.
     * Paris are separated by ','.
     * Keys are separated from values by '='.
     */
    pub recommended_encoder_configuration: *mut libc::c_char,
    /**
     * display aspect ratio (0 if unknown)
     * - encoding: unused
     * - decoding: Set by libavformat to calculate sample_aspect_ratio internally
     */
    pub display_aspect_ratio: AVRational,
    pub priv_pts: *mut FFFrac,
    /**
     * An opaque field for libavformat internal usage.
     * Must not be accessed in any way by callers.
     */
    pub internal: *mut AVStreamInternal,
    pub codecpar: *mut AVCodecParameters,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVStream__bindgen_ty_1 {
    pub last_dts: i64,
    pub duration_gcd: i64,
    pub duration_count: libc::c_int,
    pub rfps_duration_sum: i64,
    pub duration_error: *mut [[f64; 399usize]; 2usize],
    pub codec_info_duration: i64,
    pub codec_info_duration_fields: i64,
    /**
         * 0  -> decoder has not been searched for yet.
         * >0 -> decoder found
         * <0 -> decoder with codec_id == -found_decoder has not been found
         */
    pub found_decoder: libc::c_int,
    pub last_duration: i64,
    /**
         * Those are used for average framerate estimation.
         */
    pub fps_first_dts: i64,
    pub fps_first_dts_idx: libc::c_int,
    pub fps_last_dts: i64,
    pub fps_last_dts_idx: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVStream__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<AVStream__bindgen_ty_1>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( AVStream__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<AVStream__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AVStream__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . last_dts as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( last_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . duration_gcd
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( duration_gcd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                duration_count as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( duration_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                rfps_duration_sum as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( rfps_duration_sum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                duration_error as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( duration_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                codec_info_duration as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( codec_info_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                codec_info_duration_fields as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( codec_info_duration_fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                found_decoder as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( found_decoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                last_duration as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( last_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                fps_first_dts as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( fps_first_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                fps_first_dts_idx as * const _ as usize } , 80usize , concat !
                (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( fps_first_dts_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) . fps_last_dts
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( fps_last_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream__bindgen_ty_1 ) ) .
                fps_last_dts_idx as * const _ as usize } , 96usize , concat !
                (
                "Alignment of field: " , stringify ! ( AVStream__bindgen_ty_1
                ) , "::" , stringify ! ( fps_last_dts_idx ) ));
}
impl Clone for AVStream__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_AVStream() {
    assert_eq!(::std::mem::size_of::<AVStream>() , 792usize , concat ! (
               "Size of: " , stringify ! ( AVStream ) ));
    assert_eq! (::std::mem::align_of::<AVStream>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVStream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . index as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . id as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . codec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( codec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . priv_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( priv_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . pts as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . time_base as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( time_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . start_time as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( start_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . duration as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . nb_frames as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( nb_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . disposition as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( disposition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . discard as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( discard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . sample_aspect_ratio as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( sample_aspect_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . metadata as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( metadata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . avg_frame_rate as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( avg_frame_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . attached_pic as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( attached_pic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . side_data as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( side_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . nb_side_data as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( nb_side_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . event_flags as * const _
                as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( event_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . info as * const _ as usize
                } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . pts_wrap_bits as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( pts_wrap_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . first_dts as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( first_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . cur_dts as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( cur_dts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . last_IP_pts as * const _
                as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( last_IP_pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . last_IP_duration as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( last_IP_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . probe_packets as * const _
                as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( probe_packets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . codec_info_nb_frames as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( codec_info_nb_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . need_parsing as * const _
                as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( need_parsing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . parser as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( parser ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . last_in_packet_buffer as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( last_in_packet_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . probe_data as * const _ as
                usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( probe_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . pts_buffer as * const _ as
                usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( pts_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . index_entries as * const _
                as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( index_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . nb_index_entries as *
                const _ as usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( nb_index_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) .
                index_entries_allocated_size as * const _ as usize } ,
                468usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( index_entries_allocated_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . r_frame_rate as * const _
                as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( r_frame_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . stream_identifier as *
                const _ as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( stream_identifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . interleaver_chunk_size as
                * const _ as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( interleaver_chunk_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . interleaver_chunk_duration
                as * const _ as usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( interleaver_chunk_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . request_probe as * const _
                as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( request_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . skip_to_keyframe as *
                const _ as usize } , 508usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( skip_to_keyframe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . skip_samples as * const _
                as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( skip_samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . start_skip_samples as *
                const _ as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( start_skip_samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . first_discard_sample as *
                const _ as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( first_discard_sample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . last_discard_sample as *
                const _ as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( last_discard_sample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . nb_decoded_frames as *
                const _ as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( nb_decoded_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . mux_ts_offset as * const _
                as usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( mux_ts_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . pts_wrap_reference as *
                const _ as usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( pts_wrap_reference ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . pts_wrap_behavior as *
                const _ as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( pts_wrap_behavior ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) .
                update_initial_durations_done as * const _ as usize } ,
                572usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( update_initial_durations_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . pts_reorder_error as *
                const _ as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( pts_reorder_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . pts_reorder_error_count as
                * const _ as usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( pts_reorder_error_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . last_dts_for_order_check
                as * const _ as usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( last_dts_for_order_check ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . dts_ordered as * const _
                as usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( dts_ordered ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . dts_misordered as * const
                _ as usize } , 745usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( dts_misordered ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . inject_global_side_data as
                * const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( inject_global_side_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) .
                recommended_encoder_configuration as * const _ as usize } ,
                752usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( recommended_encoder_configuration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . display_aspect_ratio as *
                const _ as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( display_aspect_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . priv_pts as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( priv_pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . internal as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVStream ) ) . codecpar as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( AVStream ) , "::" ,
                stringify ! ( codecpar ) ));
}
impl Clone for AVStream {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn av_stream_get_r_frame_rate(s: *const AVStream) -> AVRational;
}
extern "C" {
    pub fn av_stream_set_r_frame_rate(s: *mut AVStream, r: AVRational);
}
extern "C" {
    pub fn av_stream_get_parser(s: *const AVStream)
     -> *mut AVCodecParserContext;
}
extern "C" {
    pub fn av_stream_get_recommended_encoder_configuration(s: *const AVStream)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn av_stream_set_recommended_encoder_configuration(s: *mut AVStream,
                                                           configuration:
                                                               *mut libc::c_char);
}
extern "C" {
    /**
 * Returns the pts of the last muxed packet + its duration
 *
 * the retuned value is undefined when used with a demuxer.
 */
    pub fn av_stream_get_end_pts(st: *const AVStream) -> i64;
}
/**
 * New fields can be added to the end with minor version bumps.
 * Removal, reordering and changes to existing fields require a major
 * version bump.
 * sizeof(AVProgram) must not be used outside libav*.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVProgram {
    pub id: libc::c_int,
    pub flags: libc::c_int,
    ///< selects which program to discard and which to feed to the caller
    pub discard: AVDiscard,
    pub stream_index: *mut libc::c_uint,
    pub nb_stream_indexes: libc::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: libc::c_int,
    pub pmt_pid: libc::c_int,
    pub pcr_pid: libc::c_int,
    /*****************************************************************
     * All fields below this line are not part of the public API. They
     * may not be used outside of libavformat and can be changed and
     * removed at will.
     * New public fields should be added right above.
     *****************************************************************
     */
    pub start_time: i64,
    pub end_time: i64,
    ///< reference dts for wrap detection
    pub pts_wrap_reference: i64,
    ///< behavior on wrap detection
    pub pts_wrap_behavior: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVProgram() {
    assert_eq!(::std::mem::size_of::<AVProgram>() , 88usize , concat ! (
               "Size of: " , stringify ! ( AVProgram ) ));
    assert_eq! (::std::mem::align_of::<AVProgram>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVProgram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . id as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . flags as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . discard as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( discard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . stream_index as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( stream_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . nb_stream_indexes as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( nb_stream_indexes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . metadata as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( metadata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . program_num as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( program_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . pmt_pid as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( pmt_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . pcr_pid as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( pcr_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . start_time as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( start_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . end_time as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( end_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . pts_wrap_reference as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( pts_wrap_reference ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVProgram ) ) . pts_wrap_behavior as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVProgram ) , "::" ,
                stringify ! ( pts_wrap_behavior ) ));
}
impl Clone for AVProgram {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVChapter {
    ///< unique ID to identify the chapter
    pub id: libc::c_int,
    ///< time base in which the start/end timestamps are specified
    pub time_base: AVRational,
    ///< chapter start/end time in time_base units
    pub start: i64,
    ///< chapter start/end time in time_base units
    pub end: i64,
    pub metadata: *mut AVDictionary,
}
#[test]
fn bindgen_test_layout_AVChapter() {
    assert_eq!(::std::mem::size_of::<AVChapter>() , 40usize , concat ! (
               "Size of: " , stringify ! ( AVChapter ) ));
    assert_eq! (::std::mem::align_of::<AVChapter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVChapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVChapter ) ) . id as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVChapter ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVChapter ) ) . time_base as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVChapter ) , "::" ,
                stringify ! ( time_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVChapter ) ) . start as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVChapter ) , "::" ,
                stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVChapter ) ) . end as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVChapter ) , "::" ,
                stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVChapter ) ) . metadata as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVChapter ) , "::" ,
                stringify ! ( metadata ) ));
}
impl Clone for AVChapter {
    fn clone(&self) -> Self { *self }
}
/**
 * Callback used by devices to communicate with application.
 */
pub type av_format_control_message =
    ::std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext,
                                               type_: libc::c_int,
                                               data: *mut libc::c_void,
                                               data_size: usize)
                              -> libc::c_int>;
pub type AVOpenCallback =
    ::std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext,
                                               pb: *mut *mut AVIOContext,
                                               url: *const libc::c_char,
                                               flags: libc::c_int,
                                               int_cb: *const AVIOInterruptCB,
                                               options:
                                                   *mut *mut AVDictionary)
                              -> libc::c_int>;
#[repr(u32)]
/**
 * The duration of a video can be estimated through various ways, and this enum can be used
 * to know how the duration was estimated.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVDurationEstimationMethod {
    AVFMT_DURATION_FROM_PTS = 0,
    AVFMT_DURATION_FROM_STREAM = 1,
    AVFMT_DURATION_FROM_BITRATE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFormatInternal {
    _unused: [u8; 0],
}
extern "C" {
    /**
 * Accessors for some AVFormatContext fields. These used to be provided for ABI
 * compatibility, and do not need to be used anymore.
 */
    pub fn av_format_get_probe_score(s: *const AVFormatContext)
     -> libc::c_int;
}
extern "C" {
    pub fn av_format_get_video_codec(s: *const AVFormatContext)
     -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_video_codec(s: *mut AVFormatContext,
                                     c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_audio_codec(s: *const AVFormatContext)
     -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_audio_codec(s: *mut AVFormatContext,
                                     c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_subtitle_codec(s: *const AVFormatContext)
     -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_subtitle_codec(s: *mut AVFormatContext,
                                        c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_data_codec(s: *const AVFormatContext)
     -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_data_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_metadata_header_padding(s: *const AVFormatContext)
     -> libc::c_int;
}
extern "C" {
    pub fn av_format_set_metadata_header_padding(s: *mut AVFormatContext,
                                                 c: libc::c_int);
}
extern "C" {
    pub fn av_format_get_opaque(s: *const AVFormatContext)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn av_format_set_opaque(s: *mut AVFormatContext,
                                opaque: *mut libc::c_void);
}
extern "C" {
    pub fn av_format_get_control_message_cb(s: *const AVFormatContext)
     -> av_format_control_message;
}
extern "C" {
    pub fn av_format_set_control_message_cb(s: *mut AVFormatContext,
                                            callback:
                                                av_format_control_message);
}
extern "C" {
    pub fn av_format_get_open_cb(s: *const AVFormatContext) -> AVOpenCallback;
}
extern "C" {
    pub fn av_format_set_open_cb(s: *mut AVFormatContext,
                                 callback: AVOpenCallback);
}
extern "C" {
    /**
 * This function will cause global side data to be injected in the next packet
 * of each stream as well as after any subsequent seek.
 */
    pub fn av_format_inject_global_side_data(s: *mut AVFormatContext);
}
extern "C" {
    /**
 * Returns the method used to set ctx->duration.
 *
 * @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.
 */
    pub fn av_fmt_ctx_get_duration_estimation_method(ctx:
                                                         *const AVFormatContext)
     -> AVDurationEstimationMethod;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
#[test]
fn bindgen_test_layout_AVPacketList() {
    assert_eq!(::std::mem::size_of::<AVPacketList>() , 96usize , concat ! (
               "Size of: " , stringify ! ( AVPacketList ) ));
    assert_eq! (::std::mem::align_of::<AVPacketList>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVPacketList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacketList ) ) . pkt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacketList ) , "::" ,
                stringify ! ( pkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPacketList ) ) . next as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPacketList ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for AVPacketList {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Return the LIBAVFORMAT_VERSION_INT constant.
 */
    pub fn avformat_version() -> libc::c_uint;
}
extern "C" {
    /**
 * Return the libavformat build-time configuration.
 */
    pub fn avformat_configuration() -> *const libc::c_char;
}
extern "C" {
    /**
 * Return the libavformat license.
 */
    pub fn avformat_license() -> *const libc::c_char;
}
extern "C" {
    /**
 * Initialize libavformat and register all the muxers, demuxers and
 * protocols. If you do not call this function, then you can select
 * exactly which formats you want to support.
 *
 * @see av_register_input_format()
 * @see av_register_output_format()
 */
    pub fn av_register_all();
}
extern "C" {
    pub fn av_register_input_format(format: *mut AVInputFormat);
}
extern "C" {
    pub fn av_register_output_format(format: *mut AVOutputFormat);
}
extern "C" {
    /**
 * Do global initialization of network components. This is optional,
 * but recommended, since it avoids the overhead of implicitly
 * doing the setup for each session.
 *
 * Calling this function will become mandatory if using network
 * protocols at some major version bump.
 */
    pub fn avformat_network_init() -> libc::c_int;
}
extern "C" {
    /**
 * Undo the initialization done by avformat_network_init.
 */
    pub fn avformat_network_deinit() -> libc::c_int;
}
extern "C" {
    /**
 * If f is NULL, returns the first registered input format,
 * if f is non-NULL, returns the next registered input format after f
 * or NULL if f is the last one.
 */
    pub fn av_iformat_next(f: *const AVInputFormat) -> *mut AVInputFormat;
}
extern "C" {
    /**
 * If f is NULL, returns the first registered output format,
 * if f is non-NULL, returns the next registered output format after f
 * or NULL if f is the last one.
 */
    pub fn av_oformat_next(f: *const AVOutputFormat) -> *mut AVOutputFormat;
}
extern "C" {
    /**
 * Allocate an AVFormatContext.
 * avformat_free_context() can be used to free the context and everything
 * allocated by the framework within it.
 */
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
}
extern "C" {
    /**
 * Free an AVFormatContext and all its streams.
 * @param s context to free
 */
    pub fn avformat_free_context(s: *mut AVFormatContext);
}
extern "C" {
    /**
 * Get the AVClass for AVFormatContext. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
    pub fn avformat_get_class() -> *const AVClass;
}
extern "C" {
    /**
 * Add a new stream to a media file.
 *
 * When demuxing, it is called by the demuxer in read_header(). If the
 * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
 * be called in read_packet().
 *
 * When muxing, should be called by the user before avformat_write_header().
 *
 * User is required to call avcodec_close() and avformat_free_context() to
 * clean up the allocation by avformat_new_stream().
 *
 * @param s media file handle
 * @param c If non-NULL, the AVCodecContext corresponding to the new stream
 * will be initialized to use this codec. This is needed for e.g. codec-specific
 * defaults to be set, so codec should be provided if it is known.
 *
 * @return newly created stream or NULL on error.
 */
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *const AVCodec)
     -> *mut AVStream;
}
extern "C" {
    /**
 * Wrap an existing array as stream side data.
 *
 * @param st stream
 * @param type side information type
 * @param data the side data array. It must be allocated with the av_malloc()
 *             family of functions. The ownership of the data is transferred to
 *             st.
 * @param size side information size
 * @return zero on success, a negative AVERROR code on failure. On failure,
 *         the stream is unchanged and the data remains owned by the caller.
 */
    pub fn av_stream_add_side_data(st: *mut AVStream,
                                   type_: AVPacketSideDataType, data: *mut u8,
                                   size: usize) -> libc::c_int;
}
extern "C" {
    /**
 * Allocate new information from stream.
 *
 * @param stream stream
 * @param type desired side information type
 * @param size side information size
 * @return pointer to fresh allocated data or NULL otherwise
 */
    pub fn av_stream_new_side_data(stream: *mut AVStream,
                                   type_: AVPacketSideDataType,
                                   size: libc::c_int) -> *mut u8;
}
extern "C" {
    pub fn av_stream_get_side_data(stream: *mut AVStream,
                                   type_: AVPacketSideDataType,
                                   size: *mut libc::c_int) -> *mut u8;
}
extern "C" {
    pub fn av_new_program(s: *mut AVFormatContext, id: libc::c_int)
     -> *mut AVProgram;
}
extern "C" {
    /**
 * Allocate an AVFormatContext for an output format.
 * avformat_free_context() can be used to free the context and
 * everything allocated by the framework within it.
 *
 * @param *ctx is set to the created format context, or to NULL in
 * case of failure
 * @param oformat format to use for allocating the context, if NULL
 * format_name and filename are used instead
 * @param format_name the name of output format to use for allocating the
 * context, if NULL filename is used instead
 * @param filename the name of the filename to use for allocating the
 * context, may be NULL
 * @return >= 0 in case of success, a negative AVERROR code in case of
 * failure
 */
    pub fn avformat_alloc_output_context2(ctx: *mut *mut AVFormatContext,
                                          oformat: *mut AVOutputFormat,
                                          format_name: *const libc::c_char,
                                          filename: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    /**
 * Find AVInputFormat based on the short name of the input format.
 */
    pub fn av_find_input_format(short_name: *const libc::c_char)
     -> *mut AVInputFormat;
}
extern "C" {
    /**
 * Guess the file format.
 *
 * @param pd        data to be probed
 * @param is_opened Whether the file is already opened; determines whether
 *                  demuxers with or without AVFMT_NOFILE are probed.
 */
    pub fn av_probe_input_format(pd: *mut AVProbeData, is_opened: libc::c_int)
     -> *mut AVInputFormat;
}
extern "C" {
    /**
 * Guess the file format.
 *
 * @param pd        data to be probed
 * @param is_opened Whether the file is already opened; determines whether
 *                  demuxers with or without AVFMT_NOFILE are probed.
 * @param score_max A probe score larger that this is required to accept a
 *                  detection, the variable is set to the actual detection
 *                  score afterwards.
 *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
 *                  to retry with a larger probe buffer.
 */
    pub fn av_probe_input_format2(pd: *mut AVProbeData,
                                  is_opened: libc::c_int,
                                  score_max: *mut libc::c_int)
     -> *mut AVInputFormat;
}
extern "C" {
    /**
 * Guess the file format.
 *
 * @param is_opened Whether the file is already opened; determines whether
 *                  demuxers with or without AVFMT_NOFILE are probed.
 * @param score_ret The score of the best detection.
 */
    pub fn av_probe_input_format3(pd: *mut AVProbeData,
                                  is_opened: libc::c_int,
                                  score_ret: *mut libc::c_int)
     -> *mut AVInputFormat;
}
extern "C" {
    /**
 * Probe a bytestream to determine the input format. Each time a probe returns
 * with a score that is too low, the probe buffer size is increased and another
 * attempt is made. When the maximum probe size is reached, the input format
 * with the highest score is returned.
 *
 * @param pb the bytestream to probe
 * @param fmt the input format is put here
 * @param url the url of the stream
 * @param logctx the log context
 * @param offset the offset within the bytestream to probe from
 * @param max_probe_size the maximum probe buffer size (zero for default)
 * @return the score in case of success, a negative value corresponding to an
 *         the maximal score is AVPROBE_SCORE_MAX
 * AVERROR code otherwise
 */
    pub fn av_probe_input_buffer2(pb: *mut AVIOContext,
                                  fmt: *mut *mut AVInputFormat,
                                  url: *const libc::c_char,
                                  logctx: *mut libc::c_void,
                                  offset: libc::c_uint,
                                  max_probe_size: libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    /**
 * Like av_probe_input_buffer2() but returns 0 on success
 */
    pub fn av_probe_input_buffer(pb: *mut AVIOContext,
                                 fmt: *mut *mut AVInputFormat,
                                 url: *const libc::c_char,
                                 logctx: *mut libc::c_void,
                                 offset: libc::c_uint,
                                 max_probe_size: libc::c_uint) -> libc::c_int;
}
extern "C" {
    /**
 * Open an input stream and read the header. The codecs are not opened.
 * The stream must be closed with avformat_close_input().
 *
 * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).
 *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this
 *           function and written into ps.
 *           Note that a user-supplied AVFormatContext will be freed on failure.
 * @param url URL of the stream to open.
 * @param fmt If non-NULL, this parameter forces a specific input format.
 *            Otherwise the format is autodetected.
 * @param options  A dictionary filled with AVFormatContext and demuxer-private options.
 *                 On return this parameter will be destroyed and replaced with a dict containing
 *                 options that were not found. May be NULL.
 *
 * @return 0 on success, a negative AVERROR on failure.
 *
 * @note If you want to use custom IO, preallocate the format context and set its pb field.
 */
    pub fn avformat_open_input(ps: *mut *mut AVFormatContext,
                               url: *const libc::c_char,
                               fmt: *mut AVInputFormat,
                               options: *mut *mut AVDictionary)
     -> libc::c_int;
}
extern "C" {
    pub fn av_demuxer_open(ic: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /**
 * Read packets of a media file to get stream information. This
 * is useful for file formats with no headers such as MPEG. This
 * function also computes the real framerate in case of MPEG-2 repeat
 * frame mode.
 * The logical file position is not changed by this function;
 * examined packets may be buffered for later processing.
 *
 * @param ic media file handle
 * @param options  If non-NULL, an ic.nb_streams long array of pointers to
 *                 dictionaries, where i-th member contains options for
 *                 codec corresponding to i-th stream.
 *                 On return each dictionary will be filled with options that were not found.
 * @return >=0 if OK, AVERROR_xxx on error
 *
 * @note this function isn't guaranteed to open all the codecs, so
 *       options being non-empty at return is a perfectly normal behavior.
 *
 * @todo Let the user decide somehow what information is needed so that
 *       we do not waste time getting stuff the user does not need.
 */
    pub fn avformat_find_stream_info(ic: *mut AVFormatContext,
                                     options: *mut *mut AVDictionary)
     -> libc::c_int;
}
extern "C" {
    /**
 * Find the programs which belong to a given stream.
 *
 * @param ic    media file handle
 * @param last  the last found program, the search will start after this
 *              program, or from the beginning if it is NULL
 * @param s     stream index
 * @return the next program which belongs to s, NULL if no program is found or
 *         the last program is not among the programs of ic.
 */
    pub fn av_find_program_from_stream(ic: *mut AVFormatContext,
                                       last: *mut AVProgram, s: libc::c_int)
     -> *mut AVProgram;
}
extern "C" {
    pub fn av_program_add_stream_index(ac: *mut AVFormatContext,
                                       progid: libc::c_int,
                                       idx: libc::c_uint);
}
extern "C" {
    /**
 * Find the "best" stream in the file.
 * The best stream is determined according to various heuristics as the most
 * likely to be what the user expects.
 * If the decoder parameter is non-NULL, av_find_best_stream will find the
 * default decoder for the stream's codec; streams for which no decoder can
 * be found are ignored.
 *
 * @param ic                media file handle
 * @param type              stream type: video, audio, subtitles, etc.
 * @param wanted_stream_nb  user-requested stream number,
 *                          or -1 for automatic selection
 * @param related_stream    try to find a stream related (eg. in the same
 *                          program) to this one, or -1 if none
 * @param decoder_ret       if non-NULL, returns the decoder for the
 *                          selected stream
 * @param flags             flags; none are currently defined
 * @return  the non-negative stream number in case of success,
 *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type
 *          could be found,
 *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
 * @note  If av_find_best_stream returns successfully and decoder_ret is not
 *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
 */
    pub fn av_find_best_stream(ic: *mut AVFormatContext, type_: AVMediaType,
                               wanted_stream_nb: libc::c_int,
                               related_stream: libc::c_int,
                               decoder_ret: *mut *mut AVCodec,
                               flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Return the next frame of a stream.
 * This function returns what is stored in the file, and does not validate
 * that what is there are valid frames for the decoder. It will split what is
 * stored in the file into frames and return one for each call. It will not
 * omit invalid data between valid frames so as to give the decoder the maximum
 * information possible for decoding.
 *
 * If pkt->buf is NULL, then the packet is valid until the next
 * av_read_frame() or until avformat_close_input(). Otherwise the packet
 * is valid indefinitely. In both cases the packet must be freed with
 * av_packet_unref when it is no longer needed. For video, the packet contains
 * exactly one frame. For audio, it contains an integer number of frames if each
 * frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames
 * have a variable size (e.g. MPEG audio), then it contains one frame.
 *
 * pkt->pts, pkt->dts and pkt->duration are always set to correct
 * values in AVStream.time_base units (and guessed if the format cannot
 * provide them). pkt->pts can be AV_NOPTS_VALUE if the video format
 * has B-frames, so it is better to rely on pkt->dts if you do not
 * decompress the payload.
 *
 * @return 0 if OK, < 0 on error or end of file
 */
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket)
     -> libc::c_int;
}
extern "C" {
    /**
 * Seek to the keyframe at timestamp.
 * 'timestamp' in 'stream_index'.
 *
 * @param s media file handle
 * @param stream_index If stream_index is (-1), a default
 * stream is selected, and timestamp is automatically converted
 * from AV_TIME_BASE units to the stream specific time_base.
 * @param timestamp Timestamp in AVStream.time_base units
 *        or, if no stream is specified, in AV_TIME_BASE units.
 * @param flags flags which select direction and seeking mode
 * @return >= 0 on success
 */
    pub fn av_seek_frame(s: *mut AVFormatContext, stream_index: libc::c_int,
                         timestamp: i64, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Seek to timestamp ts.
 * Seeking will be done so that the point from which all active streams
 * can be presented successfully will be closest to ts and within min/max_ts.
 * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
 *
 * If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and
 * are the file position (this may not be supported by all demuxers).
 * If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames
 * in the stream with stream_index (this may not be supported by all demuxers).
 * Otherwise all timestamps are in units of the stream selected by stream_index
 * or if stream_index is -1, in AV_TIME_BASE units.
 * If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as
 * keyframes (this may not be supported by all demuxers).
 * If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.
 *
 * @param s media file handle
 * @param stream_index index of the stream which is used as time base reference
 * @param min_ts smallest acceptable timestamp
 * @param ts target timestamp
 * @param max_ts largest acceptable timestamp
 * @param flags flags
 * @return >=0 on success, error code otherwise
 *
 * @note This is part of the new seek API which is still under construction.
 *       Thus do not use this yet. It may change at any time, do not expect
 *       ABI compatibility yet!
 */
    pub fn avformat_seek_file(s: *mut AVFormatContext,
                              stream_index: libc::c_int, min_ts: i64, ts: i64,
                              max_ts: i64, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Discard all internally buffered data. This can be useful when dealing with
 * discontinuities in the byte stream. Generally works only with formats that
 * can resync. This includes headerless formats like MPEG-TS/TS but should also
 * work with NUT, Ogg and in a limited way AVI for example.
 *
 * The set of streams, the detected duration, stream parameters and codecs do
 * not change when calling this function. If you want a complete reset, it's
 * better to open a new AVFormatContext.
 *
 * This does not flush the AVIOContext (s->pb). If necessary, call
 * avio_flush(s->pb) before calling this function.
 *
 * @param s media file handle
 * @return >=0 on success, error code otherwise
 */
    pub fn avformat_flush(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /**
 * Start playing a network-based stream (e.g. RTSP stream) at the
 * current position.
 */
    pub fn av_read_play(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /**
 * Pause a network-based stream (e.g. RTSP stream).
 *
 * Use av_read_play() to resume it.
 */
    pub fn av_read_pause(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /**
 * Close an opened input AVFormatContext. Free it and all its contents
 * and set *s to NULL.
 */
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
}
extern "C" {
    /**
 * Allocate the stream private data and write the stream header to
 * an output media file.
 *
 * @param s Media file handle, must be allocated with avformat_alloc_context().
 *          Its oformat field must be set to the desired output format;
 *          Its pb field must be set to an already opened AVIOContext.
 * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
 *                 On return this parameter will be destroyed and replaced with a dict containing
 *                 options that were not found. May be NULL.
 *
 * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,
 *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,
 *         negative AVERROR on failure.
 *
 * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.
 */
    pub fn avformat_write_header(s: *mut AVFormatContext,
                                 options: *mut *mut AVDictionary)
     -> libc::c_int;
}
extern "C" {
    /**
 * Allocate the stream private data and initialize the codec, but do not write the header.
 * May optionally be used before avformat_write_header to initialize stream parameters
 * before actually writing the header.
 * If using this function, do not pass the same options to avformat_write_header.
 *
 * @param s Media file handle, must be allocated with avformat_alloc_context().
 *          Its oformat field must be set to the desired output format;
 *          Its pb field must be set to an already opened AVIOContext.
 * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
 *                 On return this parameter will be destroyed and replaced with a dict containing
 *                 options that were not found. May be NULL.
 *
 * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,
 *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,
 *         negative AVERROR on failure.
 *
 * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.
 */
    pub fn avformat_init_output(s: *mut AVFormatContext,
                                options: *mut *mut AVDictionary)
     -> libc::c_int;
}
extern "C" {
    /**
 * Write a packet to an output media file.
 *
 * This function passes the packet directly to the muxer, without any buffering
 * or reordering. The caller is responsible for correctly interleaving the
 * packets if the format requires it. Callers that want libavformat to handle
 * the interleaving should call av_interleaved_write_frame() instead of this
 * function.
 *
 * @param s media file handle
 * @param pkt The packet containing the data to be written. Note that unlike
 *            av_interleaved_write_frame(), this function does not take
 *            ownership of the packet passed to it (though some muxers may make
 *            an internal reference to the input packet).
 *            <br>
 *            This parameter can be NULL (at any time, not just at the end), in
 *            order to immediately flush data buffered within the muxer, for
 *            muxers that buffer up data internally before writing it to the
 *            output.
 *            <br>
 *            Packet's @ref AVPacket.stream_index "stream_index" field must be
 *            set to the index of the corresponding stream in @ref
 *            AVFormatContext.streams "s->streams".
 *            <br>
 *            The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
 *            must be set to correct values in the stream's timebase (unless the
 *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
 *            they can be set to AV_NOPTS_VALUE).
 *            The dts for subsequent packets passed to this function must be strictly
 *            increasing when compared in their respective timebases (unless the
 *            output format is flagged with the AVFMT_TS_NONSTRICT, then they
 *            merely have to be nondecreasing).  @ref AVPacket.duration
 *            "duration") should also be set if known.
 * @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush
 *
 * @see av_interleaved_write_frame()
 */
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket)
     -> libc::c_int;
}
extern "C" {
    /**
 * Write a packet to an output media file ensuring correct interleaving.
 *
 * This function will buffer the packets internally as needed to make sure the
 * packets in the output file are properly interleaved in the order of
 * increasing dts. Callers doing their own interleaving should call
 * av_write_frame() instead of this function.
 *
 * Using this function instead of av_write_frame() can give muxers advance
 * knowledge of future packets, improving e.g. the behaviour of the mp4
 * muxer for VFR content in fragmenting mode.
 *
 * @param s media file handle
 * @param pkt The packet containing the data to be written.
 *            <br>
 *            If the packet is reference-counted, this function will take
 *            ownership of this reference and unreference it later when it sees
 *            fit.
 *            The caller must not access the data through this reference after
 *            this function returns. If the packet is not reference-counted,
 *            libavformat will make a copy.
 *            <br>
 *            This parameter can be NULL (at any time, not just at the end), to
 *            flush the interleaving queues.
 *            <br>
 *            Packet's @ref AVPacket.stream_index "stream_index" field must be
 *            set to the index of the corresponding stream in @ref
 *            AVFormatContext.streams "s->streams".
 *            <br>
 *            The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
 *            must be set to correct values in the stream's timebase (unless the
 *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
 *            they can be set to AV_NOPTS_VALUE).
 *            The dts for subsequent packets in one stream must be strictly
 *            increasing (unless the output format is flagged with the
 *            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).
 *            @ref AVPacket.duration "duration") should also be set if known.
 *
 * @return 0 on success, a negative AVERROR on error. Libavformat will always
 *         take care of freeing the packet, even if this function fails.
 *
 * @see av_write_frame(), AVFormatContext.max_interleave_delta
 */
    pub fn av_interleaved_write_frame(s: *mut AVFormatContext,
                                      pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /**
 * Write an uncoded frame to an output media file.
 *
 * The frame must be correctly interleaved according to the container
 * specification; if not, then av_interleaved_write_frame() must be used.
 *
 * See av_interleaved_write_frame() for details.
 */
    pub fn av_write_uncoded_frame(s: *mut AVFormatContext,
                                  stream_index: libc::c_int,
                                  frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /**
 * Write an uncoded frame to an output media file.
 *
 * If the muxer supports it, this function makes it possible to write an AVFrame
 * structure directly, without encoding it into a packet.
 * It is mostly useful for devices and similar special muxers that use raw
 * video or PCM data and will not serialize it into a byte stream.
 *
 * To test whether it is possible to use it with a given muxer and stream,
 * use av_write_uncoded_frame_query().
 *
 * The caller gives up ownership of the frame and must not access it
 * afterwards.
 *
 * @return  >=0 for success, a negative code on error
 */
    pub fn av_interleaved_write_uncoded_frame(s: *mut AVFormatContext,
                                              stream_index: libc::c_int,
                                              frame: *mut AVFrame)
     -> libc::c_int;
}
extern "C" {
    /**
 * Test whether a muxer supports uncoded frame.
 *
 * @return  >=0 if an uncoded frame can be written to that muxer and stream,
 *          <0 if not
 */
    pub fn av_write_uncoded_frame_query(s: *mut AVFormatContext,
                                        stream_index: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Write the stream trailer to an output media file and free the
 * file private data.
 *
 * May only be called after a successful call to avformat_write_header.
 *
 * @param s media file handle
 * @return 0 if OK, AVERROR_xxx on error
 */
    pub fn av_write_trailer(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /**
 * Return the output format in the list of registered output formats
 * which best matches the provided parameters, or return NULL if
 * there is no match.
 *
 * @param short_name if non-NULL checks if short_name matches with the
 * names of the registered formats
 * @param filename if non-NULL checks if filename terminates with the
 * extensions of the registered formats
 * @param mime_type if non-NULL checks if mime_type matches with the
 * MIME type of the registered formats
 */
    pub fn av_guess_format(short_name: *const libc::c_char,
                           filename: *const libc::c_char,
                           mime_type: *const libc::c_char)
     -> *mut AVOutputFormat;
}
extern "C" {
    /**
 * Guess the codec ID based upon muxer and filename.
 */
    pub fn av_guess_codec(fmt: *mut AVOutputFormat,
                          short_name: *const libc::c_char,
                          filename: *const libc::c_char,
                          mime_type: *const libc::c_char, type_: AVMediaType)
     -> AVCodecID;
}
extern "C" {
    /**
 * Get timing information for the data currently output.
 * The exact meaning of "currently output" depends on the format.
 * It is mostly relevant for devices that have an internal buffer and/or
 * work in real time.
 * @param s          media file handle
 * @param stream     stream in the media file
 * @param[out] dts   DTS of the last packet output for the stream, in stream
 *                   time_base units
 * @param[out] wall  absolute time when that packet whas output,
 *                   in microsecond
 * @return  0 if OK, AVERROR(ENOSYS) if the format does not support it
 * Note: some formats or devices may not allow to measure dts and wall
 * atomically.
 */
    pub fn av_get_output_timestamp(s: *mut AVFormatContext,
                                   stream: libc::c_int, dts: *mut i64,
                                   wall: *mut i64) -> libc::c_int;
}
extern "C" {
    /**
 * Send a nice hexadecimal dump of a buffer to the specified file stream.
 *
 * @param f The file stream pointer where the dump should be sent to.
 * @param buf buffer
 * @param size buffer size
 *
 * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2
 */
    pub fn av_hex_dump(f: *mut FILE, buf: *const u8, size: libc::c_int);
}
extern "C" {
    /**
 * Send a nice hexadecimal dump of a buffer to the log.
 *
 * @param avcl A pointer to an arbitrary struct of which the first field is a
 * pointer to an AVClass struct.
 * @param level The importance level of the message, lower values signifying
 * higher importance.
 * @param buf buffer
 * @param size buffer size
 *
 * @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2
 */
    pub fn av_hex_dump_log(avcl: *mut libc::c_void, level: libc::c_int,
                           buf: *const u8, size: libc::c_int);
}
extern "C" {
    /**
 * Send a nice dump of a packet to the specified file stream.
 *
 * @param f The file stream pointer where the dump should be sent to.
 * @param pkt packet to dump
 * @param dump_payload True if the payload must be displayed, too.
 * @param st AVStream that the packet belongs to
 */
    pub fn av_pkt_dump2(f: *mut FILE, pkt: *const AVPacket,
                        dump_payload: libc::c_int, st: *const AVStream);
}
extern "C" {
    /**
 * Send a nice dump of a packet to the log.
 *
 * @param avcl A pointer to an arbitrary struct of which the first field is a
 * pointer to an AVClass struct.
 * @param level The importance level of the message, lower values signifying
 * higher importance.
 * @param pkt packet to dump
 * @param dump_payload True if the payload must be displayed, too.
 * @param st AVStream that the packet belongs to
 */
    pub fn av_pkt_dump_log2(avcl: *mut libc::c_void, level: libc::c_int,
                            pkt: *const AVPacket, dump_payload: libc::c_int,
                            st: *const AVStream);
}
extern "C" {
    /**
 * Get the AVCodecID for the given codec tag tag.
 * If no codec id is found returns AV_CODEC_ID_NONE.
 *
 * @param tags list of supported codec_id-codec_tag pairs, as stored
 * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
 * @param tag  codec tag to match to a codec ID
 */
    pub fn av_codec_get_id(tags: *const *const AVCodecTag, tag: libc::c_uint)
     -> AVCodecID;
}
extern "C" {
    /**
 * Get the codec tag for the given codec id id.
 * If no codec tag is found returns 0.
 *
 * @param tags list of supported codec_id-codec_tag pairs, as stored
 * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
 * @param id   codec ID to match to a codec tag
 */
    pub fn av_codec_get_tag(tags: *const *const AVCodecTag, id: AVCodecID)
     -> libc::c_uint;
}
extern "C" {
    /**
 * Get the codec tag for the given codec id.
 *
 * @param tags list of supported codec_id - codec_tag pairs, as stored
 * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
 * @param id codec id that should be searched for in the list
 * @param tag A pointer to the found tag
 * @return 0 if id was not found in tags, > 0 if it was found
 */
    pub fn av_codec_get_tag2(tags: *const *const AVCodecTag, id: AVCodecID,
                             tag: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn av_find_default_stream_index(s: *mut AVFormatContext)
     -> libc::c_int;
}
extern "C" {
    /**
 * Get the index for a specific timestamp.
 *
 * @param st        stream that the timestamp belongs to
 * @param timestamp timestamp to retrieve the index for
 * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond
 *                 to the timestamp which is <= the requested one, if backward
 *                 is 0, then it will be >=
 *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
 * @return < 0 if no such timestamp could be found
 */
    pub fn av_index_search_timestamp(st: *mut AVStream, timestamp: i64,
                                     flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Add an index entry into a sorted list. Update the entry if the list
 * already contains it.
 *
 * @param timestamp timestamp in the time base of the given stream
 */
    pub fn av_add_index_entry(st: *mut AVStream, pos: i64, timestamp: i64,
                              size: libc::c_int, distance: libc::c_int,
                              flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Split a URL string into components.
 *
 * The pointers to buffers for storing individual components may be null,
 * in order to ignore that component. Buffers for components not found are
 * set to empty strings. If the port is not found, it is set to a negative
 * value.
 *
 * @param proto the buffer for the protocol
 * @param proto_size the size of the proto buffer
 * @param authorization the buffer for the authorization
 * @param authorization_size the size of the authorization buffer
 * @param hostname the buffer for the host name
 * @param hostname_size the size of the hostname buffer
 * @param port_ptr a pointer to store the port number in
 * @param path the buffer for the path
 * @param path_size the size of the path buffer
 * @param url the URL to split
 */
    pub fn av_url_split(proto: *mut libc::c_char, proto_size: libc::c_int,
                        authorization: *mut libc::c_char,
                        authorization_size: libc::c_int,
                        hostname: *mut libc::c_char,
                        hostname_size: libc::c_int,
                        port_ptr: *mut libc::c_int, path: *mut libc::c_char,
                        path_size: libc::c_int, url: *const libc::c_char);
}
extern "C" {
    /**
 * Print detailed information about the input or output format, such as
 * duration, bitrate, streams, container, programs, metadata, side data,
 * codec and time base.
 *
 * @param ic        the context to analyze
 * @param index     index of the stream to dump information about
 * @param url       the URL to print, such as source or destination file
 * @param is_output Select whether the specified context is an input(0) or output(1)
 */
    pub fn av_dump_format(ic: *mut AVFormatContext, index: libc::c_int,
                          url: *const libc::c_char, is_output: libc::c_int);
}
extern "C" {
    /**
 * Return in 'buf' the path with '%d' replaced by a number.
 *
 * Also handles the '%0nd' format where 'n' is the total number
 * of digits and '%%'.
 *
 * @param buf destination buffer
 * @param buf_size destination buffer size
 * @param path numbered sequence string
 * @param number frame number
 * @param flags AV_FRAME_FILENAME_FLAGS_*
 * @return 0 if OK, -1 on format error
 */
    pub fn av_get_frame_filename2(buf: *mut libc::c_char,
                                  buf_size: libc::c_int,
                                  path: *const libc::c_char,
                                  number: libc::c_int, flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_get_frame_filename(buf: *mut libc::c_char,
                                 buf_size: libc::c_int,
                                 path: *const libc::c_char,
                                 number: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Check whether filename actually is a numbered sequence generator.
 *
 * @param filename possible numbered sequence string
 * @return 1 if a valid numbered sequence string, 0 otherwise
 */
    pub fn av_filename_number_test(filename: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    /**
 * Generate an SDP for an RTP session.
 *
 * Note, this overwrites the id values of AVStreams in the muxer contexts
 * for getting unique dynamic payload types.
 *
 * @param ac array of AVFormatContexts describing the RTP streams. If the
 *           array is composed by only one context, such context can contain
 *           multiple AVStreams (one AVStream per RTP stream). Otherwise,
 *           all the contexts in the array (an AVCodecContext per RTP stream)
 *           must contain only one AVStream.
 * @param n_files number of AVCodecContexts contained in ac
 * @param buf buffer where the SDP will be stored (must be allocated by
 *            the caller)
 * @param size the size of the buffer
 * @return 0 if OK, AVERROR_xxx on error
 */
    pub fn av_sdp_create(ac: *mut *mut AVFormatContext, n_files: libc::c_int,
                         buf: *mut libc::c_char, size: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Return a positive value if the given filename has one of the given
 * extensions, 0 otherwise.
 *
 * @param filename   file name to check against the given extensions
 * @param extensions a comma-separated list of filename extensions
 */
    pub fn av_match_ext(filename: *const libc::c_char,
                        extensions: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /**
 * Test if the given container can store a codec.
 *
 * @param ofmt           container to check for compatibility
 * @param codec_id       codec to potentially store in container
 * @param std_compliance standards compliance level, one of FF_COMPLIANCE_*
 *
 * @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.
 *         A negative number if this information is not available.
 */
    pub fn avformat_query_codec(ofmt: *const AVOutputFormat,
                                codec_id: AVCodecID,
                                std_compliance: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * @defgroup riff_fourcc RIFF FourCCs
 * @{
 * Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are
 * meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
 * following code:
 * @code
 * uint32_t tag = MKTAG('H', '2', '6', '4');
 * const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };
 * enum AVCodecID id = av_codec_get_id(table, tag);
 * @endcode
 */
/**
 * @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.
 */
    pub fn avformat_get_riff_video_tags() -> *const AVCodecTag;
}
extern "C" {
    /**
 * @return the table mapping RIFF FourCCs for audio to AVCodecID.
 */
    pub fn avformat_get_riff_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    /**
 * @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.
 */
    pub fn avformat_get_mov_video_tags() -> *const AVCodecTag;
}
extern "C" {
    /**
 * @return the table mapping MOV FourCCs for audio to AVCodecID.
 */
    pub fn avformat_get_mov_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    /**
 * Guess the sample aspect ratio of a frame, based on both the stream and the
 * frame aspect ratio.
 *
 * Since the frame aspect ratio is set by the codec but the stream aspect ratio
 * is set by the demuxer, these two may not be equal. This function tries to
 * return the value that you should use if you would like to display the frame.
 *
 * Basic logic is to use the stream aspect ratio if it is set to something sane
 * otherwise use the frame aspect ratio. This way a container setting, which is
 * usually easy to modify can override the coded value in the frames.
 *
 * @param format the format context which the stream is part of
 * @param stream the stream which the frame is part of
 * @param frame the frame with the aspect ratio to be determined
 * @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea
 */
    pub fn av_guess_sample_aspect_ratio(format: *mut AVFormatContext,
                                        stream: *mut AVStream,
                                        frame: *mut AVFrame) -> AVRational;
}
extern "C" {
    /**
 * Guess the frame rate, based on both the container and codec information.
 *
 * @param ctx the format context which the stream is part of
 * @param stream the stream which the frame is part of
 * @param frame the frame for which the frame rate should be determined, may be NULL
 * @return the guessed (valid) frame rate, 0/1 if no idea
 */
    pub fn av_guess_frame_rate(ctx: *mut AVFormatContext,
                               stream: *mut AVStream, frame: *mut AVFrame)
     -> AVRational;
}
extern "C" {
    /**
 * Check if the stream st contained in s is matched by the stream specifier
 * spec.
 *
 * See the "stream specifiers" chapter in the documentation for the syntax
 * of spec.
 *
 * @return  >0 if st is matched by spec;
 *          0  if st is not matched by spec;
 *          AVERROR code if spec is invalid
 *
 * @note  A stream specifier can match several streams in the format.
 */
    pub fn avformat_match_stream_specifier(s: *mut AVFormatContext,
                                           st: *mut AVStream,
                                           spec: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext)
     -> libc::c_int;
}
extern "C" {
    pub fn av_apply_bitstream_filters(codec: *mut AVCodecContext,
                                      pkt: *mut AVPacket,
                                      bsfc: *mut AVBitStreamFilterContext)
     -> libc::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVTimebaseSource {
    AVFMT_TBCF_AUTO = -1,
    AVFMT_TBCF_DECODER = 0,
    AVFMT_TBCF_DEMUXER = 1,
    AVFMT_TBCF_R_FRAMERATE = 2,
}
extern "C" {
    /**
 * Transfer internal timing information from one stream to another.
 *
 * This function is useful when doing stream copy.
 *
 * @param ofmt     target output format for ost
 * @param ost      output stream which needs timings copy and adjustments
 * @param ist      reference input stream to copy timings from
 * @param copy_tb  define from where the stream codec timebase needs to be imported
 */
    pub fn avformat_transfer_internal_stream_timing_info(ofmt:
                                                             *const AVOutputFormat,
                                                         ost: *mut AVStream,
                                                         ist: *const AVStream,
                                                         copy_tb:
                                                             AVTimebaseSource)
     -> libc::c_int;
}
extern "C" {
    /**
 * Get the internal codec timebase from a stream.
 *
 * @param st  input stream to extract the timebase from
 */
    pub fn av_stream_get_codec_timebase(st: *const AVStream) -> AVRational;
}
extern "C" {
    /**
 * Get the current time in microseconds.
 */
    pub fn av_gettime() -> i64;
}
extern "C" {
    /**
 * Get the current time in microseconds since some unspecified starting point.
 * On platforms that support it, the time comes from a monotonic clock
 * This property makes this time source ideal for measuring relative time.
 * The returned values may not be monotonic on platforms where a monotonic
 * clock is not available.
 */
    pub fn av_gettime_relative() -> i64;
}
extern "C" {
    /**
 * Indicates with a boolean result if the av_gettime_relative() time source
 * is monotonic.
 */
    pub fn av_gettime_relative_is_monotonic() -> libc::c_int;
}
extern "C" {
    /**
 * Sleep for a period of time.  Although the duration is expressed in
 * microseconds, the actual delay may be rounded to the precision of the
 * system timer.
 *
 * @param  usec Number of microseconds to sleep.
 * @return zero on success or (negative) error code.
 */
    pub fn av_usleep(usec: libc::c_uint) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVComponentDescriptor {
    /**
     * Which of the 4 planes contains the component.
     */
    pub plane: libc::c_int,
    /**
     * Number of elements between 2 horizontally consecutive pixels.
     * Elements are bits for bitstream formats, bytes otherwise.
     */
    pub step: libc::c_int,
    /**
     * Number of elements before the component of the first pixel.
     * Elements are bits for bitstream formats, bytes otherwise.
     */
    pub offset: libc::c_int,
    /**
     * Number of least significant bits that must be shifted away
     * to get the value.
     */
    pub shift: libc::c_int,
    /**
     * Number of bits in the component.
     */
    pub depth: libc::c_int,
    /** deprecated, use step instead */
    pub step_minus1: libc::c_int,
    /** deprecated, use depth instead */
    pub depth_minus1: libc::c_int,
    /** deprecated, use offset instead */
    pub offset_plus1: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVComponentDescriptor() {
    assert_eq!(::std::mem::size_of::<AVComponentDescriptor>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( AVComponentDescriptor )
               ));
    assert_eq! (::std::mem::align_of::<AVComponentDescriptor>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( AVComponentDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVComponentDescriptor ) ) . plane as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVComponentDescriptor )
                , "::" , stringify ! ( plane ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVComponentDescriptor ) ) . step as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVComponentDescriptor )
                , "::" , stringify ! ( step ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVComponentDescriptor ) ) . offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVComponentDescriptor )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVComponentDescriptor ) ) . shift as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVComponentDescriptor )
                , "::" , stringify ! ( shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVComponentDescriptor ) ) . depth as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVComponentDescriptor )
                , "::" , stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVComponentDescriptor ) ) . step_minus1
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AVComponentDescriptor )
                , "::" , stringify ! ( step_minus1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVComponentDescriptor ) ) . depth_minus1
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVComponentDescriptor )
                , "::" , stringify ! ( depth_minus1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVComponentDescriptor ) ) . offset_plus1
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( AVComponentDescriptor )
                , "::" , stringify ! ( offset_plus1 ) ));
}
impl Clone for AVComponentDescriptor {
    fn clone(&self) -> Self { *self }
}
/**
 * Descriptor that unambiguously describes how the bits of a pixel are
 * stored in the up to 4 data planes of an image. It also stores the
 * subsampling factors and number of components.
 *
 * @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV
 *       and all the YUV variants) AVPixFmtDescriptor just stores how values
 *       are stored not what these values represent.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVPixFmtDescriptor {
    pub name: *const libc::c_char,
    ///< The number of components each pixel has, (1-4)
    pub nb_components: u8,
    /**
     * Amount to shift the luma width right to find the chroma width.
     * For YV12 this is 1 for example.
     * chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)
     * The note above is needed to ensure rounding up.
     * This value only refers to the chroma components.
     */
    pub log2_chroma_w: u8,
    /**
     * Amount to shift the luma height right to find the chroma height.
     * For YV12 this is 1 for example.
     * chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)
     * The note above is needed to ensure rounding up.
     * This value only refers to the chroma components.
     */
    pub log2_chroma_h: u8,
    /**
     * Combination of AV_PIX_FMT_FLAG_... flags.
     */
    pub flags: u64,
    /**
     * Parameters that describe how pixels are packed.
     * If the format has 1 or 2 components, then luma is 0.
     * If the format has 3 or 4 components:
     *   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;
     *   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.
     *
     * If present, the Alpha channel is always the last component.
     */
    pub comp: [AVComponentDescriptor; 4usize],
    /**
     * Alternative comma-separated names.
     */
    pub alias: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVPixFmtDescriptor() {
    assert_eq!(::std::mem::size_of::<AVPixFmtDescriptor>() , 160usize , concat
               ! ( "Size of: " , stringify ! ( AVPixFmtDescriptor ) ));
    assert_eq! (::std::mem::align_of::<AVPixFmtDescriptor>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AVPixFmtDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPixFmtDescriptor ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPixFmtDescriptor ) ) . nb_components as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) ,
                "::" , stringify ! ( nb_components ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPixFmtDescriptor ) ) . log2_chroma_w as
                * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) ,
                "::" , stringify ! ( log2_chroma_w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPixFmtDescriptor ) ) . log2_chroma_h as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) ,
                "::" , stringify ! ( log2_chroma_h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPixFmtDescriptor ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPixFmtDescriptor ) ) . comp as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) ,
                "::" , stringify ! ( comp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVPixFmtDescriptor ) ) . alias as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVPixFmtDescriptor ) ,
                "::" , stringify ! ( alias ) ));
}
impl Clone for AVPixFmtDescriptor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Return the number of bits per pixel used by the pixel format
 * described by pixdesc. Note that this is not the same as the number
 * of bits per sample.
 *
 * The returned number of bits refers to the number of bits actually
 * used for storing the pixel information, that is padding bits are
 * not counted.
 */
    pub fn av_get_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor)
     -> libc::c_int;
}
extern "C" {
    /**
 * Return the number of bits per pixel for the pixel format
 * described by pixdesc, including any padding or unused bits.
 */
    pub fn av_get_padded_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor)
     -> libc::c_int;
}
extern "C" {
    /**
 * @return a pixel format descriptor for provided pixel format or NULL if
 * this pixel format is unknown.
 */
    pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat)
     -> *const AVPixFmtDescriptor;
}
extern "C" {
    /**
 * Iterate over all pixel format descriptors known to libavutil.
 *
 * @param prev previous descriptor. NULL to get the first descriptor.
 *
 * @return next descriptor or NULL after the last descriptor
 */
    pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor)
     -> *const AVPixFmtDescriptor;
}
extern "C" {
    /**
 * @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc
 * is not a valid pointer to a pixel format descriptor.
 */
    pub fn av_pix_fmt_desc_get_id(desc: *const AVPixFmtDescriptor)
     -> AVPixelFormat;
}
extern "C" {
    /**
 * Utility function to access log2_chroma_w log2_chroma_h from
 * the pixel format AVPixFmtDescriptor.
 *
 * See av_get_chroma_sub_sample() for a function that asserts a
 * valid pixel format instead of returning an error code.
 * Its recommended that you use avcodec_get_chroma_sub_sample unless
 * you do check the return code!
 *
 * @param[in]  pix_fmt the pixel format
 * @param[out] h_shift store log2_chroma_w (horizontal/width shift)
 * @param[out] v_shift store log2_chroma_h (vertical/height shift)
 *
 * @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format
 */
    pub fn av_pix_fmt_get_chroma_sub_sample(pix_fmt: AVPixelFormat,
                                            h_shift: *mut libc::c_int,
                                            v_shift: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a
 * valid pixel format.
 */
    pub fn av_pix_fmt_count_planes(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    /**
 * @return the name for provided color range or NULL if unknown.
 */
    pub fn av_color_range_name(range: AVColorRange) -> *const libc::c_char;
}
extern "C" {
    /**
 * @return the name for provided color primaries or NULL if unknown.
 */
    pub fn av_color_primaries_name(primaries: AVColorPrimaries)
     -> *const libc::c_char;
}
extern "C" {
    /**
 * @return the name for provided color transfer or NULL if unknown.
 */
    pub fn av_color_transfer_name(transfer: AVColorTransferCharacteristic)
     -> *const libc::c_char;
}
extern "C" {
    /**
 * @return the name for provided color space or NULL if unknown.
 */
    pub fn av_color_space_name(space: AVColorSpace) -> *const libc::c_char;
}
extern "C" {
    /**
 * @return the name for provided chroma location or NULL if unknown.
 */
    pub fn av_chroma_location_name(location: AVChromaLocation)
     -> *const libc::c_char;
}
extern "C" {
    /**
 * Return the pixel format corresponding to name.
 *
 * If there is no pixel format with name name, then looks for a
 * pixel format with the name corresponding to the native endian
 * format of name.
 * For example in a little-endian system, first looks for "gray16",
 * then for "gray16le".
 *
 * Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.
 */
    pub fn av_get_pix_fmt(name: *const libc::c_char) -> AVPixelFormat;
}
extern "C" {
    /**
 * Return the short name for a pixel format, NULL in case pix_fmt is
 * unknown.
 *
 * @see av_get_pix_fmt(), av_get_pix_fmt_string()
 */
    pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const libc::c_char;
}
extern "C" {
    /**
 * Print in buf the string corresponding to the pixel format with
 * number pix_fmt, or a header if pix_fmt is negative.
 *
 * @param buf the buffer where to write the string
 * @param buf_size the size of buf
 * @param pix_fmt the number of the pixel format to print the
 * corresponding info string, or a negative value to print the
 * corresponding header.
 */
    pub fn av_get_pix_fmt_string(buf: *mut libc::c_char,
                                 buf_size: libc::c_int,
                                 pix_fmt: AVPixelFormat) -> *mut libc::c_char;
}
extern "C" {
    /**
 * Read a line from an image, and write the values of the
 * pixel format component c to dst.
 *
 * @param data the array containing the pointers to the planes of the image
 * @param linesize the array containing the linesizes of the image
 * @param desc the pixel format descriptor for the image
 * @param x the horizontal coordinate of the first pixel to read
 * @param y the vertical coordinate of the first pixel to read
 * @param w the width of the line to read, that is the number of
 * values to write to dst
 * @param read_pal_component if not zero and the format is a paletted
 * format writes the values corresponding to the palette
 * component c in data[1] to dst, rather than the palette indexes in
 * data[0]. The behavior is undefined if the format is not paletted.
 */
    pub fn av_read_image_line(dst: *mut u16, data: *mut *const u8,
                              linesize: *const libc::c_int,
                              desc: *const AVPixFmtDescriptor, x: libc::c_int,
                              y: libc::c_int, c: libc::c_int, w: libc::c_int,
                              read_pal_component: libc::c_int);
}
extern "C" {
    /**
 * Write the values from src to the pixel format component c of an
 * image line.
 *
 * @param src array containing the values to write
 * @param data the array containing the pointers to the planes of the
 * image to write into. It is supposed to be zeroed.
 * @param linesize the array containing the linesizes of the image
 * @param desc the pixel format descriptor for the image
 * @param x the horizontal coordinate of the first pixel to write
 * @param y the vertical coordinate of the first pixel to write
 * @param w the width of the line to write, that is the number of
 * values to write to the image line
 */
    pub fn av_write_image_line(src: *const u16, data: *mut *mut u8,
                               linesize: *const libc::c_int,
                               desc: *const AVPixFmtDescriptor,
                               x: libc::c_int, y: libc::c_int, c: libc::c_int,
                               w: libc::c_int);
}
extern "C" {
    /**
 * Utility function to swap the endianness of a pixel format.
 *
 * @param[in]  pix_fmt the pixel format
 *
 * @return pixel format with swapped endianness if it exists,
 * otherwise AV_PIX_FMT_NONE
 */
    pub fn av_pix_fmt_swap_endianness(pix_fmt: AVPixelFormat)
     -> AVPixelFormat;
}
extern "C" {
    /**
 * Compute what kind of losses will occur when converting from one specific
 * pixel format to another.
 * When converting from one pixel format to another, information loss may occur.
 * For example, when converting from RGB24 to GRAY, the color information will
 * be lost. Similarly, other losses occur when converting from some formats to
 * other formats. These losses can involve loss of chroma, but also loss of
 * resolution, loss of color depth, loss due to the color space conversion, loss
 * of the alpha bits or loss due to color quantization.
 * av_get_fix_fmt_loss() informs you about the various types of losses
 * which will occur when converting from one pixel format to another.
 *
 * @param[in] dst_pix_fmt destination pixel format
 * @param[in] src_pix_fmt source pixel format
 * @param[in] has_alpha Whether the source pixel format alpha channel is used.
 * @return Combination of flags informing you what kind of losses will occur
 * (maximum loss for an invalid dst_pix_fmt).
 */
    pub fn av_get_pix_fmt_loss(dst_pix_fmt: AVPixelFormat,
                               src_pix_fmt: AVPixelFormat,
                               has_alpha: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Compute what kind of losses will occur when converting from one specific
 * pixel format to another.
 * When converting from one pixel format to another, information loss may occur.
 * For example, when converting from RGB24 to GRAY, the color information will
 * be lost. Similarly, other losses occur when converting from some formats to
 * other formats. These losses can involve loss of chroma, but also loss of
 * resolution, loss of color depth, loss due to the color space conversion, loss
 * of the alpha bits or loss due to color quantization.
 * av_get_fix_fmt_loss() informs you about the various types of losses
 * which will occur when converting from one pixel format to another.
 *
 * @param[in] dst_pix_fmt destination pixel format
 * @param[in] src_pix_fmt source pixel format
 * @param[in] has_alpha Whether the source pixel format alpha channel is used.
 * @return Combination of flags informing you what kind of losses will occur
 * (maximum loss for an invalid dst_pix_fmt).
 */
    pub fn av_find_best_pix_fmt_of_2(dst_pix_fmt1: AVPixelFormat,
                                     dst_pix_fmt2: AVPixelFormat,
                                     src_pix_fmt: AVPixelFormat,
                                     has_alpha: libc::c_int,
                                     loss_ptr: *mut libc::c_int)
     -> AVPixelFormat;
}
extern "C" {
    /**
 * Return the LIBAVFILTER_VERSION_INT constant.
 */
    pub fn avfilter_version() -> libc::c_uint;
}
extern "C" {
    /**
 * Return the libavfilter build-time configuration.
 */
    pub fn avfilter_configuration() -> *const libc::c_char;
}
extern "C" {
    /**
 * Return the libavfilter license.
 */
    pub fn avfilter_license() -> *const libc::c_char;
}
/** An instance of a filter */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFilterContext {
    ///< needed for av_log() and filters common options
    pub av_class: *const AVClass,
    ///< the AVFilter of which this is an instance
    pub filter: *const AVFilter,
    ///< name of this filter instance
    pub name: *mut libc::c_char,
    ///< array of input pads
    pub input_pads: *mut AVFilterPad,
    ///< array of pointers to input links
    pub inputs: *mut *mut AVFilterLink,
    ///< number of input pads
    pub nb_inputs: libc::c_uint,
    ///< array of output pads
    pub output_pads: *mut AVFilterPad,
    ///< array of pointers to output links
    pub outputs: *mut *mut AVFilterLink,
    ///< number of output pads
    pub nb_outputs: libc::c_uint,
    ///< private data for use by the filter
    pub priv_: *mut libc::c_void,
    ///< filtergraph this filter belongs to
    pub graph: *mut AVFilterGraph,
    /**
     * Type of multithreading being allowed/used. A combination of
     * AVFILTER_THREAD_* flags.
     *
     * May be set by the caller before initializing the filter to forbid some
     * or all kinds of multithreading for this filter. The default is allowing
     * everything.
     *
     * When the filter is initialized, this field is combined using bit AND with
     * AVFilterGraph.thread_type to get the final mask used for determining
     * allowed threading types. I.e. a threading type needs to be set in both
     * to be allowed.
     *
     * After the filter is initialized, libavfilter sets this field to the
     * threading type that is actually used (0 for no multithreading).
     */
    pub thread_type: libc::c_int,
    /**
     * An opaque struct for libavfilter internal use.
     */
    pub internal: *mut AVFilterInternal,
    pub command_queue: *mut AVFilterCommand,
    ///< enable expression string
    pub enable_str: *mut libc::c_char,
    ///< parsed expression (AVExpr*)
    pub enable: *mut libc::c_void,
    ///< variable values for the enable expression
    pub var_values: *mut f64,
    ///< the enabled state from the last expression evaluation
    pub is_disabled: libc::c_int,
    /**
     * For filters which will create hardware frames, sets the device the
     * filter should create them in.  All other filters will ignore this field:
     * in particular, a filter which consumes or processes hardware frames will
     * instead use the hw_frames_ctx field in AVFilterLink to carry the
     * hardware context information.
     */
    pub hw_device_ctx: *mut AVBufferRef,
    /**
     * Max number of threads allowed in this filter instance.
     * If <= 0, its value is ignored.
     * Overrides global number of threads set per filter graph.
     */
    pub nb_threads: libc::c_int,
    /**
     * Ready status of the filter.
     * A non-0 value means that the filter needs activating;
     * a higher value suggests a more urgent activation.
     */
    pub ready: libc::c_uint,
}
#[test]
fn bindgen_test_layout_AVFilterContext() {
    assert_eq!(::std::mem::size_of::<AVFilterContext>() , 160usize , concat !
               ( "Size of: " , stringify ! ( AVFilterContext ) ));
    assert_eq! (::std::mem::align_of::<AVFilterContext>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( AVFilterContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . av_class as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( av_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . filter as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . name as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . input_pads as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( input_pads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . inputs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( inputs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . nb_inputs as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( nb_inputs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . output_pads as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( output_pads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . outputs as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( outputs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . nb_outputs as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( nb_outputs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . priv_ as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . graph as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( graph ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . thread_type as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( thread_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . internal as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . command_queue as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( command_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . enable_str as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( enable_str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . enable as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . var_values as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( var_values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . is_disabled as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( is_disabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . hw_device_ctx as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( hw_device_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . nb_threads as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( nb_threads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterContext ) ) . ready as * const _
                as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterContext ) ,
                "::" , stringify ! ( ready ) ));
}
impl Clone for AVFilterContext {
    fn clone(&self) -> Self { *self }
}
/**
 * A link between two filters. This contains pointers to the source and
 * destination filters between which this link exists, and the indexes of
 * the pads involved. In addition, this link also contains the parameters
 * which have been negotiated and agreed upon between the filter, such as
 * image dimensions, format, etc.
 *
 * Applications must not normally access the link structure directly.
 * Use the buffersrc and buffersink API instead.
 * In the future, access to the header may be reserved for filters
 * implementation.
 */
#[repr(C)]
pub struct AVFilterLink {
    ///< source filter
    pub src: *mut AVFilterContext,
    ///< output pad on the source filter
    pub srcpad: *mut AVFilterPad,
    ///< dest filter
    pub dst: *mut AVFilterContext,
    ///< input pad on the dest filter
    pub dstpad: *mut AVFilterPad,
    ///< filter media type
    pub type_: AVMediaType,
    ///< agreed upon image width
    pub w: libc::c_int,
    ///< agreed upon image height
    pub h: libc::c_int,
    ///< agreed upon sample aspect ratio
    pub sample_aspect_ratio: AVRational,
    ///< channel layout of current buffer (see libavutil/channel_layout.h)
    pub channel_layout: u64,
    ///< samples per second
    pub sample_rate: libc::c_int,
    ///< agreed upon media format
    pub format: libc::c_int,
    /**
     * Define the time base used by the PTS of the frames/samples
     * which will pass through this link.
     * During the configuration stage, each filter is supposed to
     * change only the output timebase, while the timebase of the
     * input link is assumed to be an unchangeable property.
     */
    pub time_base: AVRational,
    /*****************************************************************
     * All fields below this line are not part of the public API. They
     * may not be used outside of libavfilter and can be changed and
     * removed at will.
     * New public fields should be added right above.
     *****************************************************************
     */
    /**
     * Lists of formats and channel layouts supported by the input and output
     * filters respectively. These lists are used for negotiating the format
     * to actually be used, which will be loaded into the format and
     * channel_layout members, above, when chosen.
     *
     */
    pub in_formats: *mut AVFilterFormats,
    pub out_formats: *mut AVFilterFormats,
    /**
     * Lists of channel layouts and sample rates used for automatic
     * negotiation.
     */
    pub in_samplerates: *mut AVFilterFormats,
    pub out_samplerates: *mut AVFilterFormats,
    pub in_channel_layouts: *mut AVFilterChannelLayouts,
    pub out_channel_layouts: *mut AVFilterChannelLayouts,
    /**
     * Audio only, the destination filter sets this to a non-zero value to
     * request that buffers with the given number of samples should be sent to
     * it. AVFilterPad.needs_fifo must also be set on the corresponding input
     * pad.
     * Last buffer before EOF will be padded with silence.
     */
    pub request_samples: libc::c_int,
    pub init_state: AVFilterLink__bindgen_ty_1,
    /**
     * Graph the filter belongs to.
     */
    pub graph: *mut AVFilterGraph,
    /**
     * Current timestamp of the link, as defined by the most recent
     * frame(s), in link time_base units.
     */
    pub current_pts: i64,
    /**
     * Current timestamp of the link, as defined by the most recent
     * frame(s), in AV_TIME_BASE units.
     */
    pub current_pts_us: i64,
    /**
     * Index in the age array.
     */
    pub age_index: libc::c_int,
    /**
     * Frame rate of the stream on the link, or 1/0 if unknown or variable;
     * if left to 0/0, will be automatically copied from the first input
     * of the source filter if it exists.
     *
     * Sources should set it to the best estimation of the real frame rate.
     * If the source frame rate is unknown or variable, set this to 1/0.
     * Filters should update it if necessary depending on their function.
     * Sinks can use it to set a default output frame rate.
     * It is similar to the r_frame_rate field in AVStream.
     */
    pub frame_rate: AVRational,
    /**
     * Buffer partially filled with samples to achieve a fixed/minimum size.
     */
    pub partial_buf: *mut AVFrame,
    /**
     * Size of the partial buffer to allocate.
     * Must be between min_samples and max_samples.
     */
    pub partial_buf_size: libc::c_int,
    /**
     * Minimum number of samples to filter at once. If filter_frame() is
     * called with fewer samples, it will accumulate them in partial_buf.
     * This field and the related ones must not be changed after filtering
     * has started.
     * If 0, all related fields are ignored.
     */
    pub min_samples: libc::c_int,
    /**
     * Maximum number of samples to filter at once. If filter_frame() is
     * called with more samples, it will split them.
     */
    pub max_samples: libc::c_int,
    /**
     * Number of channels.
     */
    pub channels: libc::c_int,
    /**
     * Link processing flags.
     */
    pub flags: libc::c_uint,
    /**
     * Number of past frames sent through the link.
     */
    pub frame_count_in: i64,
    /**
     * Number of past frames sent through the link.
     */
    pub frame_count_out: i64,
    /**
     * A pointer to a FFFramePool struct.
     */
    pub frame_pool: *mut libc::c_void,
    /**
     * True if a frame is currently wanted on the output of this filter.
     * Set when ff_request_frame() is called by the output,
     * cleared when a frame is filtered.
     */
    pub frame_wanted_out: libc::c_int,
    /**
     * For hwaccel pixel formats, this should be a reference to the
     * AVHWFramesContext describing the frames.
     */
    pub hw_frames_ctx: *mut AVBufferRef,
    /**
     * Internal structure members.
     * The fields below this limit are internal for libavfilter's use
     * and must in no way be accessed by applications.
     */
    pub reserved: [libc::c_char; 61440usize],
}
pub const AVFilterLink_AVLINK_UNINIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_UNINIT;
pub const AVFilterLink_AVLINK_STARTINIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_STARTINIT;
pub const AVFilterLink_AVLINK_INIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_INIT;
#[repr(u32)]
/** stage of the initialization of the link properties (dimensions, etc) */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVFilterLink__bindgen_ty_1 {
    AVLINK_UNINIT = 0,
    AVLINK_STARTINIT = 1,
    AVLINK_INIT = 2,
}
#[test]
fn bindgen_test_layout_AVFilterLink() {
    assert_eq!(::std::mem::size_of::<AVFilterLink>() , 61688usize , concat ! (
               "Size of: " , stringify ! ( AVFilterLink ) ));
    assert_eq! (::std::mem::align_of::<AVFilterLink>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVFilterLink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . src as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( src ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . srcpad as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( srcpad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . dst as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . dstpad as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( dstpad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . type_ as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . w as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . h as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . sample_aspect_ratio as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( sample_aspect_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . channel_layout as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( channel_layout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . sample_rate as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( sample_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . format as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . time_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( time_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . in_formats as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( in_formats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . out_formats as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( out_formats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . in_samplerates as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( in_samplerates ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . out_samplerates as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( out_samplerates ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . in_channel_layouts as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( in_channel_layouts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . out_channel_layouts as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( out_channel_layouts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . request_samples as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( request_samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . init_state as * const
                _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( init_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . graph as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( graph ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . current_pts as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( current_pts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . current_pts_us as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( current_pts_us ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . age_index as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( age_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . frame_rate as * const
                _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( frame_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . partial_buf as * const
                _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( partial_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . partial_buf_size as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( partial_buf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . min_samples as * const
                _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( min_samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . max_samples as * const
                _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( max_samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . channels as * const _
                as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . flags as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . frame_count_in as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( frame_count_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . frame_count_out as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( frame_count_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . frame_pool as * const
                _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( frame_pool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . frame_wanted_out as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( frame_wanted_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . hw_frames_ctx as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( hw_frames_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterLink ) ) . reserved as * const _
                as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterLink ) , "::" ,
                stringify ! ( reserved ) ));
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterPad {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterFormats {
    _unused: [u8; 0],
}
extern "C" {
    /**
 * Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.
 * AVFilter.inputs/outputs).
 */
    pub fn avfilter_pad_count(pads: *const AVFilterPad) -> libc::c_int;
}
extern "C" {
    /**
 * Get the name of an AVFilterPad.
 *
 * @param pads an array of AVFilterPads
 * @param pad_idx index of the pad in the array it; is the caller's
 *                responsibility to ensure the index is valid
 *
 * @return name of the pad_idx'th pad in pads
 */
    pub fn avfilter_pad_get_name(pads: *const AVFilterPad,
                                 pad_idx: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    /**
 * Get the type of an AVFilterPad.
 *
 * @param pads an array of AVFilterPads
 * @param pad_idx index of the pad in the array; it is the caller's
 *                responsibility to ensure the index is valid
 *
 * @return type of the pad_idx'th pad in pads
 */
    pub fn avfilter_pad_get_type(pads: *const AVFilterPad,
                                 pad_idx: libc::c_int) -> AVMediaType;
}
/**
 * Filter definition. This defines the pads a filter contains, and all the
 * callback functions used to interact with the filter.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFilter {
    /**
     * Filter name. Must be non-NULL and unique among filters.
     */
    pub name: *const libc::c_char,
    /**
     * A description of the filter. May be NULL.
     *
     * You should use the NULL_IF_CONFIG_SMALL() macro to define it.
     */
    pub description: *const libc::c_char,
    /**
     * List of inputs, terminated by a zeroed element.
     *
     * NULL if there are no (static) inputs. Instances of filters with
     * AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in
     * this list.
     */
    pub inputs: *const AVFilterPad,
    /**
     * List of outputs, terminated by a zeroed element.
     *
     * NULL if there are no (static) outputs. Instances of filters with
     * AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in
     * this list.
     */
    pub outputs: *const AVFilterPad,
    /**
     * A class for the private data, used to declare filter private AVOptions.
     * This field is NULL for filters that do not declare any options.
     *
     * If this field is non-NULL, the first member of the filter private data
     * must be a pointer to AVClass, which will be set by libavfilter generic
     * code to this class.
     */
    pub priv_class: *const AVClass,
    /**
     * A combination of AVFILTER_FLAG_*
     */
    pub flags: libc::c_int,
    /**
     * Filter initialization function.
     *
     * This callback will be called only once during the filter lifetime, after
     * all the options have been set, but before links between filters are
     * established and format negotiation is done.
     *
     * Basic filter initialization should be done here. Filters with dynamic
     * inputs and/or outputs should create those inputs/outputs here based on
     * provided options. No more changes to this filter's inputs/outputs can be
     * done after this callback.
     *
     * This callback must not assume that the filter links exist or frame
     * parameters are known.
     *
     * @ref AVFilter.uninit "uninit" is guaranteed to be called even if
     * initialization fails, so this callback does not have to clean up on
     * failure.
     *
     * @return 0 on success, a negative AVERROR on failure
     */
    pub init: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                             *mut AVFilterContext)
                                        -> libc::c_int>,
    /**
     * Should be set instead of @ref AVFilter.init "init" by the filters that
     * want to pass a dictionary of AVOptions to nested contexts that are
     * allocated during init.
     *
     * On return, the options dict should be freed and replaced with one that
     * contains all the options which could not be processed by this filter (or
     * with NULL if all the options were processed).
     *
     * Otherwise the semantics is the same as for @ref AVFilter.init "init".
     */
    pub init_dict: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                                  *mut AVFilterContext,
                                                              options:
                                                                  *mut *mut AVDictionary)
                                             -> libc::c_int>,
    /**
     * Filter uninitialization function.
     *
     * Called only once right before the filter is freed. Should deallocate any
     * memory held by the filter, release any buffer references, etc. It does
     * not need to deallocate the AVFilterContext.priv memory itself.
     *
     * This callback may be called even if @ref AVFilter.init "init" was not
     * called or failed, so it must be prepared to handle such a situation.
     */
    pub uninit: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                               *mut AVFilterContext)>,
    /**
     * Query formats supported by the filter on its inputs and outputs.
     *
     * This callback is called after the filter is initialized (so the inputs
     * and outputs are fixed), shortly before the format negotiation. This
     * callback may be called more than once.
     *
     * This callback must set AVFilterLink.out_formats on every input link and
     * AVFilterLink.in_formats on every output link to a list of pixel/sample
     * formats that the filter supports on that link. For audio links, this
     * filter must also set @ref AVFilterLink.in_samplerates "in_samplerates" /
     * @ref AVFilterLink.out_samplerates "out_samplerates" and
     * @ref AVFilterLink.in_channel_layouts "in_channel_layouts" /
     * @ref AVFilterLink.out_channel_layouts "out_channel_layouts" analogously.
     *
     * This callback may be NULL for filters with one input, in which case
     * libavfilter assumes that it supports all input formats and preserves
     * them on output.
     *
     * @return zero on success, a negative value corresponding to an
     * AVERROR code otherwise
     */
    pub query_formats: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut AVFilterContext)
                                                 -> libc::c_int>,
    ///< size of private data to allocate for the filter
    pub priv_size: libc::c_int,
    ///< Additional flags for avfilter internal use only.
    pub flags_internal: libc::c_int,
    /**
     * Used by the filter registration system. Must not be touched by any other
     * code.
     */
    pub next: *mut AVFilter,
    /**
     * Make the filter instance process a command.
     *
     * @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only
     * @param arg    the argument for the command
     * @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported.
     * @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be
     *               time consuming then a filter should treat it like an unsupported command
     *
     * @returns >=0 on success otherwise an error code.
     *          AVERROR(ENOSYS) on unsupported commands
     */
    pub process_command: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut AVFilterContext,
                                                                    cmd:
                                                                        *const libc::c_char,
                                                                    arg:
                                                                        *const libc::c_char,
                                                                    res:
                                                                        *mut libc::c_char,
                                                                    res_len:
                                                                        libc::c_int,
                                                                    flags:
                                                                        libc::c_int)
                                                   -> libc::c_int>,
    /**
     * Filter initialization function, alternative to the init()
     * callback. Args contains the user-supplied parameters, opaque is
     * used for providing binary data.
     */
    pub init_opaque: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                                    *mut AVFilterContext,
                                                                opaque:
                                                                    *mut libc::c_void)
                                               -> libc::c_int>,
    /**
     * Filter activation function.
     *
     * Called when any processing is needed from the filter, instead of any
     * filter_frame and request_frame on pads.
     *
     * The function must examine inlinks and outlinks and perform a single
     * step of processing. If there is nothing to do, the function must do
     * nothing and not return an error. If more steps are or may be
     * possible, it must use ff_filter_set_ready() to schedule another
     * activation.
     */
    pub activate: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                                 *mut AVFilterContext)
                                            -> libc::c_int>,
}
#[test]
fn bindgen_test_layout_AVFilter() {
    assert_eq!(::std::mem::size_of::<AVFilter>() , 120usize , concat ! (
               "Size of: " , stringify ! ( AVFilter ) ));
    assert_eq! (::std::mem::align_of::<AVFilter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . name as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . description as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . inputs as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( inputs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . outputs as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( outputs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . priv_class as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( priv_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . flags as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . init as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . init_dict as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( init_dict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . uninit as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( uninit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . query_formats as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( query_formats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . priv_size as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( priv_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . flags_internal as * const
                _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( flags_internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . next as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . process_command as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( process_command ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . init_opaque as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( init_opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilter ) ) . activate as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilter ) , "::" ,
                stringify ! ( activate ) ));
}
impl Clone for AVFilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterInternal {
    _unused: [u8; 0],
}
extern "C" {
    /**
 * Link two filters together.
 *
 * @param src    the source filter
 * @param srcpad index of the output pad on the source filter
 * @param dst    the destination filter
 * @param dstpad index of the input pad on the destination filter
 * @return       zero on success
 */
    pub fn avfilter_link(src: *mut AVFilterContext, srcpad: libc::c_uint,
                         dst: *mut AVFilterContext, dstpad: libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    /**
 * Free the link in *link, and set its pointer to NULL.
 */
    pub fn avfilter_link_free(link: *mut *mut AVFilterLink);
}
extern "C" {
    /**
 * Get the number of channels of a link.
 */
    pub fn avfilter_link_get_channels(link: *mut AVFilterLink) -> libc::c_int;
}
extern "C" {
    /**
 * Set the closed field of a link.
 * @deprecated applications are not supposed to mess with links, they should
 * close the sinks.
 */
    pub fn avfilter_link_set_closed(link: *mut AVFilterLink,
                                    closed: libc::c_int);
}
extern "C" {
    /**
 * Negotiate the media format, dimensions, etc of all inputs to a filter.
 *
 * @param filter the filter to negotiate the properties for its inputs
 * @return       zero on successful negotiation
 */
    pub fn avfilter_config_links(filter: *mut AVFilterContext) -> libc::c_int;
}
extern "C" {
    /**
 * Make the filter instance process a command.
 * It is recommended to use avfilter_graph_send_command().
 */
    pub fn avfilter_process_command(filter: *mut AVFilterContext,
                                    cmd: *const libc::c_char,
                                    arg: *const libc::c_char,
                                    res: *mut libc::c_char,
                                    res_len: libc::c_int, flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /** Initialize the filter system. Register all builtin filters. */
    pub fn avfilter_register_all();
}
extern "C" {
    /** Uninitialize the filter system. Unregister all filters. */
    pub fn avfilter_uninit();
}
extern "C" {
    /**
 * Register a filter. This is only needed if you plan to use
 * avfilter_get_by_name later to lookup the AVFilter structure by name. A
 * filter can still by instantiated with avfilter_graph_alloc_filter even if it
 * is not registered.
 *
 * @param filter the filter to register
 * @return 0 if the registration was successful, a negative value
 * otherwise
 */
    pub fn avfilter_register(filter: *mut AVFilter) -> libc::c_int;
}
extern "C" {
    pub fn avfilter_get_by_name(name: *const libc::c_char) -> *mut AVFilter;
}
extern "C" {
    /**
 * Iterate over all registered filters.
 * @return If prev is non-NULL, next registered filter after prev or NULL if
 * prev is the last filter. If prev is NULL, return the first registered filter.
 */
    pub fn avfilter_next(prev: *const AVFilter) -> *const AVFilter;
}
extern "C" {
    /**
 * If filter is NULL, returns a pointer to the first registered filter pointer,
 * if filter is non-NULL, returns the next pointer after filter.
 * If the returned pointer points to NULL, the last registered filter
 * was already reached.
 * @deprecated use avfilter_next()
 */
    pub fn av_filter_next(filter: *mut *mut AVFilter) -> *mut *mut AVFilter;
}
extern "C" {
    /**
 * Create a filter instance.
 *
 * @param filter_ctx put here a pointer to the created filter context
 * on success, NULL on failure
 * @param filter    the filter to create an instance of
 * @param inst_name Name to give to the new instance. Can be NULL for none.
 * @return >= 0 in case of success, a negative error code otherwise
 * @deprecated use avfilter_graph_alloc_filter() instead
 */
    pub fn avfilter_open(filter_ctx: *mut *mut AVFilterContext,
                         filter: *mut AVFilter,
                         inst_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /**
 * Initialize a filter.
 *
 * @param filter the filter to initialize
 * @param args   A string of parameters to use when initializing the filter.
 *               The format and meaning of this string varies by filter.
 * @param opaque Any extra non-string data needed by the filter. The meaning
 *               of this parameter varies by filter.
 * @return       zero on success
 */
    pub fn avfilter_init_filter(filter: *mut AVFilterContext,
                                args: *const libc::c_char,
                                opaque: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    /**
 * Initialize a filter with the supplied parameters.
 *
 * @param ctx  uninitialized filter context to initialize
 * @param args Options to initialize the filter with. This must be a
 *             ':'-separated list of options in the 'key=value' form.
 *             May be NULL if the options have been set directly using the
 *             AVOptions API or there are no options that need to be set.
 * @return 0 on success, a negative AVERROR on failure
 */
    pub fn avfilter_init_str(ctx: *mut AVFilterContext,
                             args: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /**
 * Initialize a filter with the supplied dictionary of options.
 *
 * @param ctx     uninitialized filter context to initialize
 * @param options An AVDictionary filled with options for this filter. On
 *                return this parameter will be destroyed and replaced with
 *                a dict containing options that were not found. This dictionary
 *                must be freed by the caller.
 *                May be NULL, then this function is equivalent to
 *                avfilter_init_str() with the second parameter set to NULL.
 * @return 0 on success, a negative AVERROR on failure
 *
 * @note This function and avfilter_init_str() do essentially the same thing,
 * the difference is in manner in which the options are passed. It is up to the
 * calling code to choose whichever is more preferable. The two functions also
 * behave differently when some of the provided options are not declared as
 * supported by the filter. In such a case, avfilter_init_str() will fail, but
 * this function will leave those extra options in the options AVDictionary and
 * continue as usual.
 */
    pub fn avfilter_init_dict(ctx: *mut AVFilterContext,
                              options: *mut *mut AVDictionary) -> libc::c_int;
}
extern "C" {
    /**
 * Free a filter context. This will also remove the filter from its
 * filtergraph's list of filters.
 *
 * @param filter the filter to free
 */
    pub fn avfilter_free(filter: *mut AVFilterContext);
}
extern "C" {
    /**
 * Insert a filter in the middle of an existing link.
 *
 * @param link the link into which the filter should be inserted
 * @param filt the filter to be inserted
 * @param filt_srcpad_idx the input pad on the filter to connect
 * @param filt_dstpad_idx the output pad on the filter to connect
 * @return     zero on success
 */
    pub fn avfilter_insert_filter(link: *mut AVFilterLink,
                                  filt: *mut AVFilterContext,
                                  filt_srcpad_idx: libc::c_uint,
                                  filt_dstpad_idx: libc::c_uint)
     -> libc::c_int;
}
extern "C" {
    /**
 * @return AVClass for AVFilterContext.
 *
 * @see av_opt_find().
 */
    pub fn avfilter_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterGraphInternal {
    _unused: [u8; 0],
}
/**
 * A function pointer passed to the @ref AVFilterGraph.execute callback to be
 * executed multiple times, possibly in parallel.
 *
 * @param ctx the filter context the job belongs to
 * @param arg an opaque parameter passed through from @ref
 *            AVFilterGraph.execute
 * @param jobnr the index of the job being executed
 * @param nb_jobs the total number of jobs
 *
 * @return 0 on success, a negative AVERROR on error
 */
pub type avfilter_action_func =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext,
                                               arg: *mut libc::c_void,
                                               jobnr: libc::c_int,
                                               nb_jobs: libc::c_int)
                              -> libc::c_int>;
/**
 * A function executing multiple jobs, possibly in parallel.
 *
 * @param ctx the filter context to which the jobs belong
 * @param func the function to be called multiple times
 * @param arg the argument to be passed to func
 * @param ret a nb_jobs-sized array to be filled with return values from each
 *            invocation of func
 * @param nb_jobs the number of jobs to execute
 *
 * @return 0 on success, a negative AVERROR on error
 */
pub type avfilter_execute_func =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext,
                                               func: avfilter_action_func,
                                               arg: *mut libc::c_void,
                                               ret: *mut libc::c_int,
                                               nb_jobs: libc::c_int)
                              -> libc::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFilterGraph {
    pub av_class: *const AVClass,
    pub filters: *mut *mut AVFilterContext,
    pub nb_filters: libc::c_uint,
    ///< sws options to use for the auto-inserted scale filters
    pub scale_sws_opts: *mut libc::c_char,
    ///< libavresample options to use for the auto-inserted resample filters
    pub resample_lavr_opts: *mut libc::c_char,
    /**
     * Type of multithreading allowed for filters in this graph. A combination
     * of AVFILTER_THREAD_* flags.
     *
     * May be set by the caller at any point, the setting will apply to all
     * filters initialized after that. The default is allowing everything.
     *
     * When a filter in this graph is initialized, this field is combined using
     * bit AND with AVFilterContext.thread_type to get the final mask used for
     * determining allowed threading types. I.e. a threading type needs to be
     * set in both to be allowed.
     */
    pub thread_type: libc::c_int,
    /**
     * Maximum number of threads used by filters in this graph. May be set by
     * the caller before adding any filters to the filtergraph. Zero (the
     * default) means that the number of threads is determined automatically.
     */
    pub nb_threads: libc::c_int,
    /**
     * Opaque object for libavfilter internal use.
     */
    pub internal: *mut AVFilterGraphInternal,
    /**
     * Opaque user data. May be set by the caller to an arbitrary value, e.g. to
     * be used from callbacks like @ref AVFilterGraph.execute.
     * Libavfilter will not touch this field in any way.
     */
    pub opaque: *mut libc::c_void,
    /**
     * This callback may be set by the caller immediately after allocating the
     * graph and before adding any filters to it, to provide a custom
     * multithreading implementation.
     *
     * If set, filters with slice threading capability will call this callback
     * to execute multiple jobs in parallel.
     *
     * If this field is left unset, libavfilter will use its internal
     * implementation, which may or may not be multithreaded depending on the
     * platform and build options.
     */
    pub execute: avfilter_execute_func,
    ///< swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions
    pub aresample_swr_opts: *mut libc::c_char,
    /**
     * Private fields
     *
     * The following fields are for internal use only.
     * Their type, offset, number and semantic can change without notice.
     */
    pub sink_links: *mut *mut AVFilterLink,
    pub sink_links_count: libc::c_int,
    pub disable_auto_convert: libc::c_uint,
}
#[test]
fn bindgen_test_layout_AVFilterGraph() {
    assert_eq!(::std::mem::size_of::<AVFilterGraph>() , 96usize , concat ! (
               "Size of: " , stringify ! ( AVFilterGraph ) ));
    assert_eq! (::std::mem::align_of::<AVFilterGraph>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVFilterGraph ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . av_class as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( av_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . filters as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( filters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . nb_filters as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( nb_filters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . scale_sws_opts as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( scale_sws_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . resample_lavr_opts as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( resample_lavr_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . thread_type as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( thread_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . nb_threads as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( nb_threads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . internal as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . opaque as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( opaque ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . execute as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( execute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . aresample_swr_opts as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( aresample_swr_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . sink_links as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( sink_links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . sink_links_count as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( sink_links_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterGraph ) ) . disable_auto_convert
                as * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterGraph ) , "::"
                , stringify ! ( disable_auto_convert ) ));
}
impl Clone for AVFilterGraph {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Allocate a filter graph.
 *
 * @return the allocated filter graph on success or NULL.
 */
    pub fn avfilter_graph_alloc() -> *mut AVFilterGraph;
}
extern "C" {
    /**
 * Create a new filter instance in a filter graph.
 *
 * @param graph graph in which the new filter will be used
 * @param filter the filter to create an instance of
 * @param name Name to give to the new instance (will be copied to
 *             AVFilterContext.name). This may be used by the caller to identify
 *             different filters, libavfilter itself assigns no semantics to
 *             this parameter. May be NULL.
 *
 * @return the context of the newly created filter instance (note that it is
 *         also retrievable directly through AVFilterGraph.filters or with
 *         avfilter_graph_get_filter()) on success or NULL on failure.
 */
    pub fn avfilter_graph_alloc_filter(graph: *mut AVFilterGraph,
                                       filter: *const AVFilter,
                                       name: *const libc::c_char)
     -> *mut AVFilterContext;
}
extern "C" {
    /**
 * Get a filter instance identified by instance name from graph.
 *
 * @param graph filter graph to search through.
 * @param name filter instance name (should be unique in the graph).
 * @return the pointer to the found filter instance or NULL if it
 * cannot be found.
 */
    pub fn avfilter_graph_get_filter(graph: *mut AVFilterGraph,
                                     name: *const libc::c_char)
     -> *mut AVFilterContext;
}
extern "C" {
    /**
 * Add an existing filter instance to a filter graph.
 *
 * @param graphctx  the filter graph
 * @param filter the filter to be added
 *
 * @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a
 * filter graph
 */
    pub fn avfilter_graph_add_filter(graphctx: *mut AVFilterGraph,
                                     filter: *mut AVFilterContext)
     -> libc::c_int;
}
extern "C" {
    /**
 * Create and add a filter instance into an existing graph.
 * The filter instance is created from the filter filt and inited
 * with the parameters args and opaque.
 *
 * In case of success put in *filt_ctx the pointer to the created
 * filter instance, otherwise set *filt_ctx to NULL.
 *
 * @param name the instance name to give to the created filter instance
 * @param graph_ctx the filter graph
 * @return a negative AVERROR error code in case of failure, a non
 * negative value otherwise
 */
    pub fn avfilter_graph_create_filter(filt_ctx: *mut *mut AVFilterContext,
                                        filt: *const AVFilter,
                                        name: *const libc::c_char,
                                        args: *const libc::c_char,
                                        opaque: *mut libc::c_void,
                                        graph_ctx: *mut AVFilterGraph)
     -> libc::c_int;
}
extern "C" {
    /**
 * Enable or disable automatic format conversion inside the graph.
 *
 * Note that format conversion can still happen inside explicitly inserted
 * scale and aresample filters.
 *
 * @param flags  any of the AVFILTER_AUTO_CONVERT_* constants
 */
    pub fn avfilter_graph_set_auto_convert(graph: *mut AVFilterGraph,
                                           flags: libc::c_uint);
}
pub const AVFILTER_AUTO_CONVERT_ALL: _bindgen_ty_2 =
    _bindgen_ty_2::AVFILTER_AUTO_CONVERT_ALL;
pub const AVFILTER_AUTO_CONVERT_NONE: _bindgen_ty_2 =
    _bindgen_ty_2::AVFILTER_AUTO_CONVERT_NONE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    AVFILTER_AUTO_CONVERT_ALL = 0,
    AVFILTER_AUTO_CONVERT_NONE = -1,
}
extern "C" {
    /**
 * Check validity and configure all the links and formats in the graph.
 *
 * @param graphctx the filter graph
 * @param log_ctx context used for logging
 * @return >= 0 in case of success, a negative AVERROR code otherwise
 */
    pub fn avfilter_graph_config(graphctx: *mut AVFilterGraph,
                                 log_ctx: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    /**
 * Free a graph, destroy its links, and set *graph to NULL.
 * If *graph is NULL, do nothing.
 */
    pub fn avfilter_graph_free(graph: *mut *mut AVFilterGraph);
}
/**
 * A linked-list of the inputs/outputs of the filter chain.
 *
 * This is mainly useful for avfilter_graph_parse() / avfilter_graph_parse2(),
 * where it is used to communicate open (unlinked) inputs and outputs from and
 * to the caller.
 * This struct specifies, per each not connected pad contained in the graph, the
 * filter context and the pad index required for establishing a link.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFilterInOut {
    /** unique name for this input/output in the list */
    pub name: *mut libc::c_char,
    /** filter context associated to this input/output */
    pub filter_ctx: *mut AVFilterContext,
    /** index of the filt_ctx pad to use for linking */
    pub pad_idx: libc::c_int,
    /** next input/input in the list, NULL if this is the last */
    pub next: *mut AVFilterInOut,
}
#[test]
fn bindgen_test_layout_AVFilterInOut() {
    assert_eq!(::std::mem::size_of::<AVFilterInOut>() , 32usize , concat ! (
               "Size of: " , stringify ! ( AVFilterInOut ) ));
    assert_eq! (::std::mem::align_of::<AVFilterInOut>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVFilterInOut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterInOut ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterInOut ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterInOut ) ) . filter_ctx as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterInOut ) , "::"
                , stringify ! ( filter_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterInOut ) ) . pad_idx as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterInOut ) , "::"
                , stringify ! ( pad_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVFilterInOut ) ) . next as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVFilterInOut ) , "::"
                , stringify ! ( next ) ));
}
impl Clone for AVFilterInOut {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Allocate a single AVFilterInOut entry.
 * Must be freed with avfilter_inout_free().
 * @return allocated AVFilterInOut on success, NULL on failure.
 */
    pub fn avfilter_inout_alloc() -> *mut AVFilterInOut;
}
extern "C" {
    /**
 * Free the supplied list of AVFilterInOut and set *inout to NULL.
 * If *inout is NULL, do nothing.
 */
    pub fn avfilter_inout_free(inout: *mut *mut AVFilterInOut);
}
extern "C" {
    /**
 * Add a graph described by a string to a graph.
 *
 * @note The caller must provide the lists of inputs and outputs,
 * which therefore must be known before calling the function.
 *
 * @note The inputs parameter describes inputs of the already existing
 * part of the graph; i.e. from the point of view of the newly created
 * part, they are outputs. Similarly the outputs parameter describes
 * outputs of the already existing filters, which are provided as
 * inputs to the parsed filters.
 *
 * @param graph   the filter graph where to link the parsed graph context
 * @param filters string to be parsed
 * @param inputs  linked list to the inputs of the graph
 * @param outputs linked list to the outputs of the graph
 * @return zero on success, a negative AVERROR code on error
 */
    pub fn avfilter_graph_parse(graph: *mut AVFilterGraph,
                                filters: *const libc::c_char,
                                inputs: *mut AVFilterInOut,
                                outputs: *mut AVFilterInOut,
                                log_ctx: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    /**
 * Add a graph described by a string to a graph.
 *
 * In the graph filters description, if the input label of the first
 * filter is not specified, "in" is assumed; if the output label of
 * the last filter is not specified, "out" is assumed.
 *
 * @param graph   the filter graph where to link the parsed graph context
 * @param filters string to be parsed
 * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.
 *                If non-NULL, *inputs is updated to contain the list of open inputs
 *                after the parsing, should be freed with avfilter_inout_free().
 * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.
 *                If non-NULL, *outputs is updated to contain the list of open outputs
 *                after the parsing, should be freed with avfilter_inout_free().
 * @return non negative on success, a negative AVERROR code on error
 */
    pub fn avfilter_graph_parse_ptr(graph: *mut AVFilterGraph,
                                    filters: *const libc::c_char,
                                    inputs: *mut *mut AVFilterInOut,
                                    outputs: *mut *mut AVFilterInOut,
                                    log_ctx: *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    /**
 * Add a graph described by a string to a graph.
 *
 * @param[in]  graph   the filter graph where to link the parsed graph context
 * @param[in]  filters string to be parsed
 * @param[out] inputs  a linked list of all free (unlinked) inputs of the
 *                     parsed graph will be returned here. It is to be freed
 *                     by the caller using avfilter_inout_free().
 * @param[out] outputs a linked list of all free (unlinked) outputs of the
 *                     parsed graph will be returned here. It is to be freed by the
 *                     caller using avfilter_inout_free().
 * @return zero on success, a negative AVERROR code on error
 *
 * @note This function returns the inputs and outputs that are left
 * unlinked after parsing the graph and the caller then deals with
 * them.
 * @note This function makes no reference whatsoever to already
 * existing parts of the graph and the inputs parameter will on return
 * contain inputs of the newly parsed part of the graph.  Analogously
 * the outputs parameter will contain outputs of the newly created
 * filters.
 */
    pub fn avfilter_graph_parse2(graph: *mut AVFilterGraph,
                                 filters: *const libc::c_char,
                                 inputs: *mut *mut AVFilterInOut,
                                 outputs: *mut *mut AVFilterInOut)
     -> libc::c_int;
}
extern "C" {
    /**
 * Send a command to one or more filter instances.
 *
 * @param graph  the filter graph
 * @param target the filter(s) to which the command should be sent
 *               "all" sends to all filters
 *               otherwise it can be a filter or filter instance name
 *               which will send the command to all matching filters.
 * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only
 * @param arg    the argument for the command
 * @param res    a buffer with size res_size where the filter(s) can return a response.
 *
 * @returns >=0 on success otherwise an error code.
 *              AVERROR(ENOSYS) on unsupported commands
 */
    pub fn avfilter_graph_send_command(graph: *mut AVFilterGraph,
                                       target: *const libc::c_char,
                                       cmd: *const libc::c_char,
                                       arg: *const libc::c_char,
                                       res: *mut libc::c_char,
                                       res_len: libc::c_int,
                                       flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Queue a command for one or more filter instances.
 *
 * @param graph  the filter graph
 * @param target the filter(s) to which the command should be sent
 *               "all" sends to all filters
 *               otherwise it can be a filter or filter instance name
 *               which will send the command to all matching filters.
 * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only
 * @param arg    the argument for the command
 * @param ts     time at which the command should be sent to the filter
 *
 * @note As this executes commands after this function returns, no return code
 *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.
 */
    pub fn avfilter_graph_queue_command(graph: *mut AVFilterGraph,
                                        target: *const libc::c_char,
                                        cmd: *const libc::c_char,
                                        arg: *const libc::c_char,
                                        flags: libc::c_int, ts: f64)
     -> libc::c_int;
}
extern "C" {
    /**
 * Dump a graph into a human-readable string representation.
 *
 * @param graph    the graph to dump
 * @param options  formatting options; currently ignored
 * @return  a string, or NULL in case of memory allocation failure;
 *          the string must be freed using av_free
 */
    pub fn avfilter_graph_dump(graph: *mut AVFilterGraph,
                               options: *const libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    /**
 * Request a frame on the oldest sink link.
 *
 * If the request returns AVERROR_EOF, try the next.
 *
 * Note that this function is not meant to be the sole scheduling mechanism
 * of a filtergraph, only a convenience function to help drain a filtergraph
 * in a balanced way under normal circumstances.
 *
 * Also note that AVERROR_EOF does not mean that frames did not arrive on
 * some of the sinks during the process.
 * When there are multiple sink links, in case the requested link
 * returns an EOF, this may cause a filter to flush pending frames
 * which are sent to another sink link, although unrequested.
 *
 * @return  the return value of ff_request_frame(),
 *          or AVERROR_EOF if all links returned AVERROR_EOF
 */
    pub fn avfilter_graph_request_oldest(graph: *mut AVFilterGraph)
     -> libc::c_int;
}
pub const AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT: _bindgen_ty_3 =
    _bindgen_ty_3::AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT;
pub const AV_BUFFERSRC_FLAG_PUSH: _bindgen_ty_3 =
    _bindgen_ty_3::AV_BUFFERSRC_FLAG_PUSH;
pub const AV_BUFFERSRC_FLAG_KEEP_REF: _bindgen_ty_3 =
    _bindgen_ty_3::AV_BUFFERSRC_FLAG_KEEP_REF;
#[repr(u32)]
/**
 * @defgroup lavfi_buffersrc Buffer source API
 * @ingroup lavfi
 * @{
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1,
    AV_BUFFERSRC_FLAG_PUSH = 4,
    AV_BUFFERSRC_FLAG_KEEP_REF = 8,
}
extern "C" {
    /**
 * Get the number of failed requests.
 *
 * A failed request is when the request_frame method is called while no
 * frame is present in the buffer.
 * The number is reset when a frame is added.
 */
    pub fn av_buffersrc_get_nb_failed_requests(buffer_src:
                                                   *mut AVFilterContext)
     -> libc::c_uint;
}
/**
 * This structure contains the parameters describing the frames that will be
 * passed to this filter.
 *
 * It should be allocated with av_buffersrc_parameters_alloc() and freed with
 * av_free(). All the allocated fields in it remain owned by the caller.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVBufferSrcParameters {
    /**
     * video: the pixel format, value corresponds to enum AVPixelFormat
     * audio: the sample format, value corresponds to enum AVSampleFormat
     */
    pub format: libc::c_int,
    /**
     * The timebase to be used for the timestamps on the input frames.
     */
    pub time_base: AVRational,
    /**
     * Video only, the display dimensions of the input frames.
     */
    pub width: libc::c_int,
    /**
     * Video only, the display dimensions of the input frames.
     */
    pub height: libc::c_int,
    /**
     * Video only, the sample (pixel) aspect ratio.
     */
    pub sample_aspect_ratio: AVRational,
    /**
     * Video only, the frame rate of the input video. This field must only be
     * set to a non-zero value if input stream has a known constant framerate
     * and should be left at its initial value if the framerate is variable or
     * unknown.
     */
    pub frame_rate: AVRational,
    /**
     * Video with a hwaccel pixel format only. This should be a reference to an
     * AVHWFramesContext instance describing the input frames.
     */
    pub hw_frames_ctx: *mut AVBufferRef,
    /**
     * Audio only, the audio sampling rate in samples per secon.
     */
    pub sample_rate: libc::c_int,
    /**
     * Audio only, the audio channel layout
     */
    pub channel_layout: u64,
}
#[test]
fn bindgen_test_layout_AVBufferSrcParameters() {
    assert_eq!(::std::mem::size_of::<AVBufferSrcParameters>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( AVBufferSrcParameters )
               ));
    assert_eq! (::std::mem::align_of::<AVBufferSrcParameters>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AVBufferSrcParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) . format as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) . time_base as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( time_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) . width as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) . height as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) .
                sample_aspect_ratio as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( sample_aspect_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) . frame_rate as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( frame_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) . hw_frames_ctx
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( hw_frames_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) . sample_rate
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( sample_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSrcParameters ) ) .
                channel_layout as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSrcParameters )
                , "::" , stringify ! ( channel_layout ) ));
}
impl Clone for AVBufferSrcParameters {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Allocate a new AVBufferSrcParameters instance. It should be freed by the
 * caller with av_free().
 */
    pub fn av_buffersrc_parameters_alloc() -> *mut AVBufferSrcParameters;
}
extern "C" {
    /**
 * Initialize the buffersrc or abuffersrc filter with the provided parameters.
 * This function may be called multiple times, the later calls override the
 * previous ones. Some of the parameters may also be set through AVOptions, then
 * whatever method is used last takes precedence.
 *
 * @param ctx an instance of the buffersrc or abuffersrc filter
 * @param param the stream parameters. The frames later passed to this filter
 *              must conform to those parameters. All the allocated fields in
 *              param remain owned by the caller, libavfilter will make internal
 *              copies or references when necessary.
 * @return 0 on success, a negative AVERROR code on failure.
 */
    pub fn av_buffersrc_parameters_set(ctx: *mut AVFilterContext,
                                       param: *mut AVBufferSrcParameters)
     -> libc::c_int;
}
extern "C" {
    /**
 * Add a frame to the buffer source.
 *
 * @param ctx   an instance of the buffersrc filter
 * @param frame frame to be added. If the frame is reference counted, this
 * function will make a new reference to it. Otherwise the frame data will be
 * copied.
 *
 * @return 0 on success, a negative AVERROR on error
 *
 * This function is equivalent to av_buffersrc_add_frame_flags() with the
 * AV_BUFFERSRC_FLAG_KEEP_REF flag.
 */
    pub fn av_buffersrc_write_frame(ctx: *mut AVFilterContext,
                                    frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    /**
 * Add a frame to the buffer source.
 *
 * @param ctx   an instance of the buffersrc filter
 * @param frame frame to be added. If the frame is reference counted, this
 * function will take ownership of the reference(s) and reset the frame.
 * Otherwise the frame data will be copied. If this function returns an error,
 * the input frame is not touched.
 *
 * @return 0 on success, a negative AVERROR on error.
 *
 * @note the difference between this function and av_buffersrc_write_frame() is
 * that av_buffersrc_write_frame() creates a new reference to the input frame,
 * while this function takes ownership of the reference passed to it.
 *
 * This function is equivalent to av_buffersrc_add_frame_flags() without the
 * AV_BUFFERSRC_FLAG_KEEP_REF flag.
 */
    pub fn av_buffersrc_add_frame(ctx: *mut AVFilterContext,
                                  frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /**
 * Add a frame to the buffer source.
 *
 * By default, if the frame is reference-counted, this function will take
 * ownership of the reference(s) and reset the frame. This can be controlled
 * using the flags.
 *
 * If this function returns an error, the input frame is not touched.
 *
 * @param buffer_src  pointer to a buffer source context
 * @param frame       a frame, or NULL to mark EOF
 * @param flags       a combination of AV_BUFFERSRC_FLAG_*
 * @return            >= 0 in case of success, a negative AVERROR code
 *                    in case of failure
 */
    pub fn av_buffersrc_add_frame_flags(buffer_src: *mut AVFilterContext,
                                        frame: *mut AVFrame,
                                        flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Get a frame with filtered data from sink and put it in frame.
 *
 * @param ctx    pointer to a buffersink or abuffersink filter context.
 * @param frame  pointer to an allocated frame that will be filled with data.
 *               The data must be freed using av_frame_unref() / av_frame_free()
 * @param flags  a combination of AV_BUFFERSINK_FLAG_* flags
 *
 * @return  >= 0 in for success, a negative AVERROR code for failure.
 */
    pub fn av_buffersink_get_frame_flags(ctx: *mut AVFilterContext,
                                         frame: *mut AVFrame,
                                         flags: libc::c_int) -> libc::c_int;
}
/**
 * Struct to use for initializing a buffersink context.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVBufferSinkParams {
    ///< list of allowed pixel formats, terminated by AV_PIX_FMT_NONE
    pub pixel_fmts: *const AVPixelFormat,
}
#[test]
fn bindgen_test_layout_AVBufferSinkParams() {
    assert_eq!(::std::mem::size_of::<AVBufferSinkParams>() , 8usize , concat !
               ( "Size of: " , stringify ! ( AVBufferSinkParams ) ));
    assert_eq! (::std::mem::align_of::<AVBufferSinkParams>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AVBufferSinkParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVBufferSinkParams ) ) . pixel_fmts as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVBufferSinkParams ) ,
                "::" , stringify ! ( pixel_fmts ) ));
}
impl Clone for AVBufferSinkParams {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Create an AVBufferSinkParams structure.
 *
 * Must be freed with av_free().
 */
    pub fn av_buffersink_params_alloc() -> *mut AVBufferSinkParams;
}
/**
 * Struct to use for initializing an abuffersink context.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVABufferSinkParams {
    ///< list of allowed sample formats, terminated by AV_SAMPLE_FMT_NONE
    pub sample_fmts: *const AVSampleFormat,
    ///< list of allowed channel layouts, terminated by -1
    pub channel_layouts: *const i64,
    ///< list of allowed channel counts, terminated by -1
    pub channel_counts: *const libc::c_int,
    ///< if not 0, accept any channel count or layout
    pub all_channel_counts: libc::c_int,
    ///< list of allowed sample rates, terminated by -1
    pub sample_rates: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_AVABufferSinkParams() {
    assert_eq!(::std::mem::size_of::<AVABufferSinkParams>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( AVABufferSinkParams ) ));
    assert_eq! (::std::mem::align_of::<AVABufferSinkParams>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AVABufferSinkParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVABufferSinkParams ) ) . sample_fmts as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVABufferSinkParams ) ,
                "::" , stringify ! ( sample_fmts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVABufferSinkParams ) ) . channel_layouts
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVABufferSinkParams ) ,
                "::" , stringify ! ( channel_layouts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVABufferSinkParams ) ) . channel_counts
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVABufferSinkParams ) ,
                "::" , stringify ! ( channel_counts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVABufferSinkParams ) ) .
                all_channel_counts as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( AVABufferSinkParams ) ,
                "::" , stringify ! ( all_channel_counts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVABufferSinkParams ) ) . sample_rates as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVABufferSinkParams ) ,
                "::" , stringify ! ( sample_rates ) ));
}
impl Clone for AVABufferSinkParams {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Create an AVABufferSinkParams structure.
 *
 * Must be freed with av_free().
 */
    pub fn av_abuffersink_params_alloc() -> *mut AVABufferSinkParams;
}
extern "C" {
    /**
 * Set the frame size for an audio buffer sink.
 *
 * All calls to av_buffersink_get_buffer_ref will return a buffer with
 * exactly the specified number of samples, or AVERROR(EAGAIN) if there is
 * not enough. The last buffer at EOF will be padded with 0.
 */
    pub fn av_buffersink_set_frame_size(ctx: *mut AVFilterContext,
                                        frame_size: libc::c_uint);
}
extern "C" {
    /**
 * @defgroup lavfi_buffersink_accessors Buffer sink accessors
 * Get the properties of the stream
 * @{
 */
    pub fn av_buffersink_get_type(ctx: *const AVFilterContext) -> AVMediaType;
}
extern "C" {
    pub fn av_buffersink_get_time_base(ctx: *const AVFilterContext)
     -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_format(ctx: *const AVFilterContext)
     -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_frame_rate(ctx: *const AVFilterContext)
     -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_w(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_h(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_sample_aspect_ratio(ctx: *const AVFilterContext)
     -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_channels(ctx: *const AVFilterContext)
     -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_channel_layout(ctx: *const AVFilterContext)
     -> u64;
}
extern "C" {
    pub fn av_buffersink_get_sample_rate(ctx: *const AVFilterContext)
     -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_hw_frames_ctx(ctx: *const AVFilterContext)
     -> *mut AVBufferRef;
}
extern "C" {
    /**
 * Get a frame with filtered data from sink and put it in frame.
 *
 * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.
 * @param frame pointer to an allocated frame that will be filled with data.
 *              The data must be freed using av_frame_unref() / av_frame_free()
 *
 * @return
 *         - >= 0 if a frame was successfully returned.
 *         - AVERROR(EAGAIN) if no frames are available at this point; more
 *           input frames must be added to the filtergraph to get more output.
 *         - AVERROR_EOF if there will be no more output frames on this sink.
 *         - A different negative AVERROR code in other failure cases.
 */
    pub fn av_buffersink_get_frame(ctx: *mut AVFilterContext,
                                   frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /**
 * Same as av_buffersink_get_frame(), but with the ability to specify the number
 * of samples read. This function is less efficient than
 * av_buffersink_get_frame(), because it copies the data around.
 *
 * @param ctx pointer to a context of the abuffersink AVFilter.
 * @param frame pointer to an allocated frame that will be filled with data.
 *              The data must be freed using av_frame_unref() / av_frame_free()
 *              frame will contain exactly nb_samples audio samples, except at
 *              the end of stream, when it can contain less than nb_samples.
 *
 * @return The return codes have the same meaning as for
 *         av_buffersink_get_samples().
 *
 * @warning do not mix this function with av_buffersink_get_frame(). Use only one or
 * the other with a single sink, not both.
 */
    pub fn av_buffersink_get_samples(ctx: *mut AVFilterContext,
                                     frame: *mut AVFrame,
                                     nb_samples: libc::c_int) -> libc::c_int;
}
#[repr(u32)]
/** Dithering algorithms */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwrDitherType {
    SWR_DITHER_NONE = 0,
    SWR_DITHER_RECTANGULAR = 1,
    SWR_DITHER_TRIANGULAR = 2,
    SWR_DITHER_TRIANGULAR_HIGHPASS = 3,
    SWR_DITHER_NS = 64,
    SWR_DITHER_NS_LIPSHITZ = 65,
    SWR_DITHER_NS_F_WEIGHTED = 66,
    SWR_DITHER_NS_MODIFIED_E_WEIGHTED = 67,
    SWR_DITHER_NS_IMPROVED_E_WEIGHTED = 68,
    SWR_DITHER_NS_SHIBATA = 69,
    SWR_DITHER_NS_LOW_SHIBATA = 70,
    SWR_DITHER_NS_HIGH_SHIBATA = 71,
    SWR_DITHER_NB = 72,
}
#[repr(u32)]
/** Resampling Engines */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwrEngine {
    SWR_ENGINE_SWR = 0,
    SWR_ENGINE_SOXR = 1,
    SWR_ENGINE_NB = 2,
}
#[repr(u32)]
/** Resampling Filter Types */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwrFilterType {
    SWR_FILTER_TYPE_CUBIC = 0,
    SWR_FILTER_TYPE_BLACKMAN_NUTTALL = 1,
    SWR_FILTER_TYPE_KAISER = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwrContext {
    _unused: [u8; 0],
}
extern "C" {
    /**
 * Get the AVClass for SwrContext. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 * @return the AVClass of SwrContext
 */
    pub fn swr_get_class() -> *const AVClass;
}
extern "C" {
    /**
 * Allocate SwrContext.
 *
 * If you use this function you will need to set the parameters (manually or
 * with swr_alloc_set_opts()) before calling swr_init().
 *
 * @see swr_alloc_set_opts(), swr_init(), swr_free()
 * @return NULL on error, allocated context otherwise
 */
    pub fn swr_alloc() -> *mut SwrContext;
}
extern "C" {
    /**
 * Initialize context after user parameters have been set.
 * @note The context must be configured using the AVOption API.
 *
 * @see av_opt_set_int()
 * @see av_opt_set_dict()
 *
 * @param[in,out]   s Swr context to initialize
 * @return AVERROR error code in case of failure.
 */
    pub fn swr_init(s: *mut SwrContext) -> libc::c_int;
}
extern "C" {
    /**
 * Check whether an swr context has been initialized or not.
 *
 * @param[in]       s Swr context to check
 * @see swr_init()
 * @return positive if it has been initialized, 0 if not initialized
 */
    pub fn swr_is_initialized(s: *mut SwrContext) -> libc::c_int;
}
extern "C" {
    /**
 * Allocate SwrContext if needed and set/reset common parameters.
 *
 * This function does not require s to be allocated with swr_alloc(). On the
 * other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters
 * on the allocated context.
 *
 * @param s               existing Swr context if available, or NULL if not
 * @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)
 * @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).
 * @param out_sample_rate output sample rate (frequency in Hz)
 * @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)
 * @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).
 * @param in_sample_rate  input sample rate (frequency in Hz)
 * @param log_offset      logging level offset
 * @param log_ctx         parent logging context, can be NULL
 *
 * @see swr_init(), swr_free()
 * @return NULL on error, allocated context otherwise
 */
    pub fn swr_alloc_set_opts(s: *mut SwrContext, out_ch_layout: i64,
                              out_sample_fmt: AVSampleFormat,
                              out_sample_rate: libc::c_int, in_ch_layout: i64,
                              in_sample_fmt: AVSampleFormat,
                              in_sample_rate: libc::c_int,
                              log_offset: libc::c_int,
                              log_ctx: *mut libc::c_void) -> *mut SwrContext;
}
extern "C" {
    /**
 * Free the given SwrContext and set the pointer to NULL.
 *
 * @param[in] s a pointer to a pointer to Swr context
 */
    pub fn swr_free(s: *mut *mut SwrContext);
}
extern "C" {
    /**
 * Closes the context so that swr_is_initialized() returns 0.
 *
 * The context can be brought back to life by running swr_init(),
 * swr_init() can also be used without swr_close().
 * This function is mainly provided for simplifying the usecase
 * where one tries to support libavresample and libswresample.
 *
 * @param[in,out] s Swr context to be closed
 */
    pub fn swr_close(s: *mut SwrContext);
}
extern "C" {
    /** Convert audio.
 *
 * in and in_count can be set to 0 to flush the last few samples out at the
 * end.
 *
 * If more input is provided than output space, then the input will be buffered.
 * You can avoid this buffering by using swr_get_out_samples() to retrieve an
 * upper bound on the required number of output samples for the given number of
 * input samples. Conversion will run directly without copying whenever possible.
 *
 * @param s         allocated Swr context, with parameters set
 * @param out       output buffers, only the first one need be set in case of packed audio
 * @param out_count amount of space available for output in samples per channel
 * @param in        input buffers, only the first one need to be set in case of packed audio
 * @param in_count  number of input samples available in one channel
 *
 * @return number of samples output per channel, negative value on error
 */
    pub fn swr_convert(s: *mut SwrContext, out: *mut *mut u8,
                       out_count: libc::c_int, in_: *mut *const u8,
                       in_count: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Convert the next timestamp from input to output
 * timestamps are in 1/(in_sample_rate * out_sample_rate) units.
 *
 * @note There are 2 slightly differently behaving modes.
 *       @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)
 *              in this case timestamps will be passed through with delays compensated
 *       @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)
 *              in this case the output timestamps will match output sample numbers.
 *              See ffmpeg-resampler(1) for the two modes of compensation.
 *
 * @param s[in]     initialized Swr context
 * @param pts[in]   timestamp for the next input sample, INT64_MIN if unknown
 * @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are
 *      function used internally for timestamp compensation.
 * @return the output timestamp for the next output sample
 */
    pub fn swr_next_pts(s: *mut SwrContext, pts: i64) -> i64;
}
extern "C" {
    /**
 * Activate resampling compensation ("soft" compensation). This function is
 * internally called when needed in swr_next_pts().
 *
 * @param[in,out] s             allocated Swr context. If it is not initialized,
 *                              or SWR_FLAG_RESAMPLE is not set, swr_init() is
 *                              called with the flag set.
 * @param[in]     sample_delta  delta in PTS per sample
 * @param[in]     compensation_distance number of samples to compensate for
 * @return    >= 0 on success, AVERROR error codes if:
 *            @li @c s is NULL,
 *            @li @c compensation_distance is less than 0,
 *            @li @c compensation_distance is 0 but sample_delta is not,
 *            @li compensation unsupported by resampler, or
 *            @li swr_init() fails when called.
 */
    pub fn swr_set_compensation(s: *mut SwrContext, sample_delta: libc::c_int,
                                compensation_distance: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Set a customized input channel mapping.
 *
 * @param[in,out] s           allocated Swr context, not yet initialized
 * @param[in]     channel_map customized input channel mapping (array of channel
 *                            indexes, -1 for a muted channel)
 * @return >= 0 on success, or AVERROR error code in case of failure.
 */
    pub fn swr_set_channel_mapping(s: *mut SwrContext,
                                   channel_map: *const libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Generate a channel mixing matrix.
 *
 * This function is the one used internally by libswresample for building the
 * default mixing matrix. It is made public just as a utility function for
 * building custom matrices.
 *
 * @param in_layout           input channel layout
 * @param out_layout          output channel layout
 * @param center_mix_level    mix level for the center channel
 * @param surround_mix_level  mix level for the surround channel(s)
 * @param lfe_mix_level       mix level for the low-frequency effects channel
 * @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent
 *                            overflow. if INT_MAX, coefficients will not be
 *                            normalized.
 * @param[out] matrix         mixing coefficients; matrix[i + stride * o] is
 *                            the weight of input channel i in output channel o.
 * @param stride              distance between adjacent input channels in the
 *                            matrix array
 * @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)
 * @param log_ctx             parent logging context, can be NULL
 * @return                    0 on success, negative AVERROR code on failure
 */
    pub fn swr_build_matrix(in_layout: u64, out_layout: u64,
                            center_mix_level: f64, surround_mix_level: f64,
                            lfe_mix_level: f64, rematrix_maxval: f64,
                            rematrix_volume: f64, matrix: *mut f64,
                            stride: libc::c_int,
                            matrix_encoding: AVMatrixEncoding,
                            log_ctx: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    /**
 * Set a customized remix matrix.
 *
 * @param s       allocated Swr context, not yet initialized
 * @param matrix  remix coefficients; matrix[i + stride * o] is
 *                the weight of input channel i in output channel o
 * @param stride  offset between lines of the matrix
 * @return  >= 0 on success, or AVERROR error code in case of failure.
 */
    pub fn swr_set_matrix(s: *mut SwrContext, matrix: *const f64,
                          stride: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * Drops the specified number of output samples.
 *
 * This function, along with swr_inject_silence(), is called by swr_next_pts()
 * if needed for "hard" compensation.
 *
 * @param s     allocated Swr context
 * @param count number of samples to be dropped
 *
 * @return >= 0 on success, or a negative AVERROR code on failure
 */
    pub fn swr_drop_output(s: *mut SwrContext, count: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Injects the specified number of silence samples.
 *
 * This function, along with swr_drop_output(), is called by swr_next_pts()
 * if needed for "hard" compensation.
 *
 * @param s     allocated Swr context
 * @param count number of samples to be dropped
 *
 * @return >= 0 on success, or a negative AVERROR code on failure
 */
    pub fn swr_inject_silence(s: *mut SwrContext, count: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Gets the delay the next input sample will experience relative to the next output sample.
 *
 * Swresample can buffer data if more input has been provided than available
 * output space, also converting between sample rates needs a delay.
 * This function returns the sum of all such delays.
 * The exact delay is not necessarily an integer value in either input or
 * output sample rate. Especially when downsampling by a large value, the
 * output sample rate may be a poor choice to represent the delay, similarly
 * for upsampling and the input sample rate.
 *
 * @param s     swr context
 * @param base  timebase in which the returned delay will be:
 *              @li if it's set to 1 the returned delay is in seconds
 *              @li if it's set to 1000 the returned delay is in milliseconds
 *              @li if it's set to the input sample rate then the returned
 *                  delay is in input samples
 *              @li if it's set to the output sample rate then the returned
 *                  delay is in output samples
 *              @li if it's the least common multiple of in_sample_rate and
 *                  out_sample_rate then an exact rounding-free delay will be
 *                  returned
 * @returns     the delay in 1 / @c base units.
 */
    pub fn swr_get_delay(s: *mut SwrContext, base: i64) -> i64;
}
extern "C" {
    /**
 * Find an upper bound on the number of samples that the next swr_convert
 * call will output, if called with in_samples of input samples. This
 * depends on the internal state, and anything changing the internal state
 * (like further swr_convert() calls) will may change the number of samples
 * swr_get_out_samples() returns for the same number of input samples.
 *
 * @param in_samples    number of input samples.
 * @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()
 *       or swr_set_compensation() invalidates this limit
 * @note it is recommended to pass the correct available buffer size
 *       to all functions like swr_convert() even if swr_get_out_samples()
 *       indicates that less would be used.
 * @returns an upper bound on the number of samples that the next swr_convert
 *          will output or a negative value to indicate an error
 */
    pub fn swr_get_out_samples(s: *mut SwrContext, in_samples: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Return the @ref LIBSWRESAMPLE_VERSION_INT constant.
 *
 * This is useful to check if the build-time libswresample has the same version
 * as the run-time one.
 *
 * @returns     the unsigned int-typed version
 */
    pub fn swresample_version() -> libc::c_uint;
}
extern "C" {
    /**
 * Return the swr build-time configuration.
 *
 * @returns     the build-time @c ./configure flags
 */
    pub fn swresample_configuration() -> *const libc::c_char;
}
extern "C" {
    /**
 * Return the swr license.
 *
 * @returns     the license of libswresample, determined at build-time
 */
    pub fn swresample_license() -> *const libc::c_char;
}
extern "C" {
    /**
 * Convert the samples in the input AVFrame and write them to the output AVFrame.
 *
 * Input and output AVFrames must have channel_layout, sample_rate and format set.
 *
 * If the output AVFrame does not have the data pointers allocated the nb_samples
 * field will be set using av_frame_get_buffer()
 * is called to allocate the frame.
 *
 * The output AVFrame can be NULL or have fewer allocated samples than required.
 * In this case, any remaining samples not written to the output will be added
 * to an internal FIFO buffer, to be returned at the next call to this function
 * or to swr_convert().
 *
 * If converting sample rate, there may be data remaining in the internal
 * resampling delay buffer. swr_get_delay() tells the number of
 * remaining samples. To get this data as output, call this function or
 * swr_convert() with NULL input.
 *
 * If the SwrContext configuration does not match the output and
 * input AVFrame settings the conversion does not take place and depending on
 * which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED
 * or the result of a bitwise-OR of them is returned.
 *
 * @see swr_delay()
 * @see swr_convert()
 * @see swr_get_delay()
 *
 * @param swr             audio resample context
 * @param output          output AVFrame
 * @param input           input AVFrame
 * @return                0 on success, AVERROR on failure or nonmatching
 *                        configuration.
 */
    pub fn swr_convert_frame(swr: *mut SwrContext, output: *mut AVFrame,
                             input: *const AVFrame) -> libc::c_int;
}
extern "C" {
    /**
 * Configure or reconfigure the SwrContext using the information
 * provided by the AVFrames.
 *
 * The original resampling context is reset even on failure.
 * The function calls swr_close() internally if the context is open.
 *
 * @see swr_close();
 *
 * @param swr             audio resample context
 * @param output          output AVFrame
 * @param input           input AVFrame
 * @return                0 on success, AVERROR on failure.
 */
    pub fn swr_config_frame(swr: *mut SwrContext, out: *const AVFrame,
                            in_: *const AVFrame) -> libc::c_int;
}
extern "C" {
    /**
 * @defgroup libsws libswscale
 * Color conversion and scaling library.
 *
 * @{
 *
 * Return the LIBSWSCALE_VERSION_INT constant.
 */
    pub fn swscale_version() -> libc::c_uint;
}
extern "C" {
    /**
 * Return the libswscale build-time configuration.
 */
    pub fn swscale_configuration() -> *const libc::c_char;
}
extern "C" {
    /**
 * Return the libswscale license.
 */
    pub fn swscale_license() -> *const libc::c_char;
}
extern "C" {
    /**
 * Return a pointer to yuv<->rgb coefficients for the given colorspace
 * suitable for sws_setColorspaceDetails().
 *
 * @param colorspace One of the SWS_CS_* macros. If invalid,
 * SWS_CS_DEFAULT is used.
 */
    pub fn sws_getCoefficients(colorspace: libc::c_int) -> *const libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SwsVector {
    ///< pointer to the list of coefficients
    pub coeff: *mut f64,
    ///< number of coefficients in the vector
    pub length: libc::c_int,
}
#[test]
fn bindgen_test_layout_SwsVector() {
    assert_eq!(::std::mem::size_of::<SwsVector>() , 16usize , concat ! (
               "Size of: " , stringify ! ( SwsVector ) ));
    assert_eq! (::std::mem::align_of::<SwsVector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SwsVector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SwsVector ) ) . coeff as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SwsVector ) , "::" ,
                stringify ! ( coeff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SwsVector ) ) . length as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SwsVector ) , "::" ,
                stringify ! ( length ) ));
}
impl Clone for SwsVector {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
#[test]
fn bindgen_test_layout_SwsFilter() {
    assert_eq!(::std::mem::size_of::<SwsFilter>() , 32usize , concat ! (
               "Size of: " , stringify ! ( SwsFilter ) ));
    assert_eq! (::std::mem::align_of::<SwsFilter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SwsFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SwsFilter ) ) . lumH as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SwsFilter ) , "::" ,
                stringify ! ( lumH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SwsFilter ) ) . lumV as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SwsFilter ) , "::" ,
                stringify ! ( lumV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SwsFilter ) ) . chrH as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SwsFilter ) , "::" ,
                stringify ! ( chrH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SwsFilter ) ) . chrV as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SwsFilter ) , "::" ,
                stringify ! ( chrV ) ));
}
impl Clone for SwsFilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsContext {
    _unused: [u8; 0],
}
extern "C" {
    /**
 * Return a positive value if pix_fmt is a supported input format, 0
 * otherwise.
 */
    pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    /**
 * Return a positive value if pix_fmt is a supported output format, 0
 * otherwise.
 */
    pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    /**
 * @param[in]  pix_fmt the pixel format
 * @return a positive value if an endianness conversion for pix_fmt is
 * supported, 0 otherwise.
 */
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: AVPixelFormat)
     -> libc::c_int;
}
extern "C" {
    /**
 * Allocate an empty SwsContext. This must be filled and passed to
 * sws_init_context(). For filling see AVOptions, options.c and
 * sws_setColorspaceDetails().
 */
    pub fn sws_alloc_context() -> *mut SwsContext;
}
extern "C" {
    /**
 * Initialize the swscaler context sws_context.
 *
 * @return zero or positive value on success, a negative value on
 * error
 */
    pub fn sws_init_context(sws_context: *mut SwsContext,
                            srcFilter: *mut SwsFilter,
                            dstFilter: *mut SwsFilter) -> libc::c_int;
}
extern "C" {
    /**
 * Free the swscaler context swsContext.
 * If swsContext is NULL, then does nothing.
 */
    pub fn sws_freeContext(swsContext: *mut SwsContext);
}
extern "C" {
    /**
 * Allocate and return an SwsContext. You need it to perform
 * scaling/conversion operations using sws_scale().
 *
 * @param srcW the width of the source image
 * @param srcH the height of the source image
 * @param srcFormat the source image format
 * @param dstW the width of the destination image
 * @param dstH the height of the destination image
 * @param dstFormat the destination image format
 * @param flags specify which algorithm and options to use for rescaling
 * @param param extra parameters to tune the used scaler
 *              For SWS_BICUBIC param[0] and [1] tune the shape of the basis
 *              function, param[0] tunes f(1) and param[1] f´(1)
 *              For SWS_GAUSS param[0] tunes the exponent and thus cutoff
 *              frequency
 *              For SWS_LANCZOS param[0] tunes the width of the window function
 * @return a pointer to an allocated context, or NULL in case of error
 * @note this function is to be removed after a saner alternative is
 *       written
 */
    pub fn sws_getContext(srcW: libc::c_int, srcH: libc::c_int,
                          srcFormat: AVPixelFormat, dstW: libc::c_int,
                          dstH: libc::c_int, dstFormat: AVPixelFormat,
                          flags: libc::c_int, srcFilter: *mut SwsFilter,
                          dstFilter: *mut SwsFilter, param: *const f64)
     -> *mut SwsContext;
}
extern "C" {
    /**
 * Scale the image slice in srcSlice and put the resulting scaled
 * slice in the image in dst. A slice is a sequence of consecutive
 * rows in an image.
 *
 * Slices have to be provided in sequential order, either in
 * top-bottom or bottom-top order. If slices are provided in
 * non-sequential order the behavior of the function is undefined.
 *
 * @param c         the scaling context previously created with
 *                  sws_getContext()
 * @param srcSlice  the array containing the pointers to the planes of
 *                  the source slice
 * @param srcStride the array containing the strides for each plane of
 *                  the source image
 * @param srcSliceY the position in the source image of the slice to
 *                  process, that is the number (counted starting from
 *                  zero) in the image of the first row of the slice
 * @param srcSliceH the height of the source slice, that is the number
 *                  of rows in the slice
 * @param dst       the array containing the pointers to the planes of
 *                  the destination image
 * @param dstStride the array containing the strides for each plane of
 *                  the destination image
 * @return          the height of the output slice
 */
    pub fn sws_scale(c: *mut SwsContext, srcSlice: *const *const u8,
                     srcStride: *const libc::c_int, srcSliceY: libc::c_int,
                     srcSliceH: libc::c_int, dst: *const *const u8,
                     dstStride: *const libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
 * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
 * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]
 * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]
 * @param brightness 16.16 fixed point brightness correction
 * @param contrast 16.16 fixed point contrast correction
 * @param saturation 16.16 fixed point saturation correction
 * @return -1 if not supported
 */
    pub fn sws_setColorspaceDetails(c: *mut SwsContext,
                                    inv_table: *const libc::c_int,
                                    srcRange: libc::c_int,
                                    table: *const libc::c_int,
                                    dstRange: libc::c_int,
                                    brightness: libc::c_int,
                                    contrast: libc::c_int,
                                    saturation: libc::c_int) -> libc::c_int;
}
extern "C" {
    /**
 * @return -1 if not supported
 */
    pub fn sws_getColorspaceDetails(c: *mut SwsContext,
                                    inv_table: *mut *mut libc::c_int,
                                    srcRange: *mut libc::c_int,
                                    table: *mut *mut libc::c_int,
                                    dstRange: *mut libc::c_int,
                                    brightness: *mut libc::c_int,
                                    contrast: *mut libc::c_int,
                                    saturation: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    /**
 * Allocate and return an uninitialized vector with length coefficients.
 */
    pub fn sws_allocVec(length: libc::c_int) -> *mut SwsVector;
}
extern "C" {
    /**
 * Return a normalized Gaussian curve used to filter stuff
 * quality = 3 is high quality, lower is lower quality.
 */
    pub fn sws_getGaussianVec(variance: f64, quality: f64) -> *mut SwsVector;
}
extern "C" {
    /**
 * Scale all the coefficients of a by the scalar value.
 */
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: f64);
}
extern "C" {
    /**
 * Scale all the coefficients of a so that their sum equals height.
 */
    pub fn sws_normalizeVec(a: *mut SwsVector, height: f64);
}
extern "C" {
    pub fn sws_getConstVec(c: f64, length: libc::c_int) -> *mut SwsVector;
}
extern "C" {
    pub fn sws_getIdentityVec() -> *mut SwsVector;
}
extern "C" {
    pub fn sws_convVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_addVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_subVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_shiftVec(a: *mut SwsVector, shift: libc::c_int);
}
extern "C" {
    pub fn sws_cloneVec(a: *mut SwsVector) -> *mut SwsVector;
}
extern "C" {
    pub fn sws_printVec2(a: *mut SwsVector, log_ctx: *mut AVClass,
                         log_level: libc::c_int);
}
extern "C" {
    pub fn sws_freeVec(a: *mut SwsVector);
}
extern "C" {
    pub fn sws_getDefaultFilter(lumaGBlur: f32, chromaGBlur: f32,
                                lumaSharpen: f32, chromaSharpen: f32,
                                chromaHShift: f32, chromaVShift: f32,
                                verbose: libc::c_int) -> *mut SwsFilter;
}
extern "C" {
    pub fn sws_freeFilter(filter: *mut SwsFilter);
}
extern "C" {
    /**
 * Check if context can be reused, otherwise reallocate a new one.
 *
 * If context is NULL, just calls sws_getContext() to get a new
 * context. Otherwise, checks if the parameters are the ones already
 * saved in context. If that is the case, returns the current
 * context. Otherwise, frees context and gets a new context with
 * the new parameters.
 *
 * Be warned that srcFilter and dstFilter are not checked, they
 * are assumed to remain the same.
 */
    pub fn sws_getCachedContext(context: *mut SwsContext, srcW: libc::c_int,
                                srcH: libc::c_int, srcFormat: AVPixelFormat,
                                dstW: libc::c_int, dstH: libc::c_int,
                                dstFormat: AVPixelFormat, flags: libc::c_int,
                                srcFilter: *mut SwsFilter,
                                dstFilter: *mut SwsFilter, param: *const f64)
     -> *mut SwsContext;
}
extern "C" {
    /**
 * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.
 *
 * The output frame will have the same packed format as the palette.
 *
 * @param src        source frame buffer
 * @param dst        destination frame buffer
 * @param num_pixels number of pixels to convert
 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
 */
    pub fn sws_convertPalette8ToPacked32(src: *const u8, dst: *mut u8,
                                         num_pixels: libc::c_int,
                                         palette: *const u8);
}
extern "C" {
    /**
 * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.
 *
 * With the palette format "ABCD", the destination frame ends up with the format "ABC".
 *
 * @param src        source frame buffer
 * @param dst        destination frame buffer
 * @param num_pixels number of pixels to convert
 * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
 */
    pub fn sws_convertPalette8ToPacked24(src: *const u8, dst: *mut u8,
                                         num_pixels: libc::c_int,
                                         palette: *const u8);
}
extern "C" {
    /**
 * Get the AVClass for swsContext. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
    pub fn sws_get_class() -> *const AVClass;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVOptionType {
    AV_OPT_TYPE_FLAGS = 0,
    AV_OPT_TYPE_INT = 1,
    AV_OPT_TYPE_INT64 = 2,
    AV_OPT_TYPE_DOUBLE = 3,
    AV_OPT_TYPE_FLOAT = 4,
    AV_OPT_TYPE_STRING = 5,
    AV_OPT_TYPE_RATIONAL = 6,
    AV_OPT_TYPE_BINARY = 7,
    AV_OPT_TYPE_DICT = 8,
    AV_OPT_TYPE_UINT64 = 9,
    AV_OPT_TYPE_CONST = 128,
    AV_OPT_TYPE_IMAGE_SIZE = 1397316165,
    AV_OPT_TYPE_PIXEL_FMT = 1346784596,
    AV_OPT_TYPE_SAMPLE_FMT = 1397116244,
    AV_OPT_TYPE_VIDEO_RATE = 1448231252,
    AV_OPT_TYPE_DURATION = 1146442272,
    AV_OPT_TYPE_COLOR = 1129270354,
    AV_OPT_TYPE_CHANNEL_LAYOUT = 1128811585,
    AV_OPT_TYPE_BOOL = 1112493900,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVOption {
    pub name: *const libc::c_char,
    pub help: *const libc::c_char,
    pub offset: libc::c_int,
    pub type_: AVOptionType,
    pub default_val: AVOption__bindgen_ty_1,
    pub min: f64,
    pub max: f64,
    pub flags: libc::c_int,
    pub unit: *const libc::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVOption__bindgen_ty_1 {
    pub i64: __BindgenUnionField<i64>,
    pub dbl: __BindgenUnionField<f64>,
    pub str: __BindgenUnionField<*const libc::c_char>,
    pub q: __BindgenUnionField<AVRational>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_AVOption__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<AVOption__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( AVOption__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<AVOption__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( AVOption__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption__bindgen_ty_1 ) ) . i64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption__bindgen_ty_1
                ) , "::" , stringify ! ( i64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption__bindgen_ty_1 ) ) . dbl as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption__bindgen_ty_1
                ) , "::" , stringify ! ( dbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption__bindgen_ty_1 ) ) . str as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption__bindgen_ty_1
                ) , "::" , stringify ! ( str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption__bindgen_ty_1 ) ) . q as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption__bindgen_ty_1
                ) , "::" , stringify ! ( q ) ));
}
impl Clone for AVOption__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_AVOption() {
    assert_eq!(::std::mem::size_of::<AVOption>() , 64usize , concat ! (
               "Size of: " , stringify ! ( AVOption ) ));
    assert_eq! (::std::mem::align_of::<AVOption>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVOption ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . name as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . help as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( help ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . offset as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . type_ as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . default_val as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( default_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . min as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . max as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . flags as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOption ) ) . unit as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOption ) , "::" ,
                stringify ! ( unit ) ));
}
impl Clone for AVOption {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVOptionRange {
    pub str: *const libc::c_char,
    pub value_min: f64,
    pub value_max: f64,
    pub component_min: f64,
    pub component_max: f64,
    pub is_range: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRange() {
    assert_eq!(::std::mem::size_of::<AVOptionRange>() , 48usize , concat ! (
               "Size of: " , stringify ! ( AVOptionRange ) ));
    assert_eq! (::std::mem::align_of::<AVOptionRange>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVOptionRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRange ) ) . str as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRange ) , "::"
                , stringify ! ( str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRange ) ) . value_min as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRange ) , "::"
                , stringify ! ( value_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRange ) ) . value_max as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRange ) , "::"
                , stringify ! ( value_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRange ) ) . component_min as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRange ) , "::"
                , stringify ! ( component_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRange ) ) . component_max as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRange ) , "::"
                , stringify ! ( component_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVOptionRange ) ) . is_range as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AVOptionRange ) , "::"
                , stringify ! ( is_range ) ));
}
impl Clone for AVOptionRange {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn av_opt_show2(obj: *mut libc::c_void, av_log_obj: *mut libc::c_void,
                        req_flags: libc::c_int, rej_flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_defaults(s: *mut libc::c_void);
}
extern "C" {
    pub fn av_opt_set_defaults2(s: *mut libc::c_void, mask: libc::c_int,
                                flags: libc::c_int);
}
extern "C" {
    pub fn av_set_options_string(ctx: *mut libc::c_void,
                                 opts: *const libc::c_char,
                                 key_val_sep: *const libc::c_char,
                                 pairs_sep: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_from_string(ctx: *mut libc::c_void,
                                  opts: *const libc::c_char,
                                  shorthand: *const *const libc::c_char,
                                  key_val_sep: *const libc::c_char,
                                  pairs_sep: *const libc::c_char)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_free(obj: *mut libc::c_void);
}
extern "C" {
    pub fn av_opt_flag_is_set(obj: *mut libc::c_void,
                              field_name: *const libc::c_char,
                              flag_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_dict(obj: *mut libc::c_void,
                           options: *mut *mut AVDictionary) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_dict2(obj: *mut libc::c_void,
                            options: *mut *mut AVDictionary,
                            search_flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_key_value(ropts: *mut *const libc::c_char,
                                key_val_sep: *const libc::c_char,
                                pairs_sep: *const libc::c_char,
                                flags: libc::c_uint,
                                rkey: *mut *mut libc::c_char,
                                rval: *mut *mut libc::c_char) -> libc::c_int;
}
pub const AV_OPT_FLAG_IMPLICIT_KEY: _bindgen_ty_4 =
    _bindgen_ty_4::AV_OPT_FLAG_IMPLICIT_KEY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 { AV_OPT_FLAG_IMPLICIT_KEY = 1, }
extern "C" {
    pub fn av_opt_eval_flags(obj: *mut libc::c_void, o: *const AVOption,
                             val: *const libc::c_char,
                             flags_out: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_int(obj: *mut libc::c_void, o: *const AVOption,
                           val: *const libc::c_char,
                           int_out: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_int64(obj: *mut libc::c_void, o: *const AVOption,
                             val: *const libc::c_char, int64_out: *mut i64)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_float(obj: *mut libc::c_void, o: *const AVOption,
                             val: *const libc::c_char, float_out: *mut f32)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_double(obj: *mut libc::c_void, o: *const AVOption,
                              val: *const libc::c_char, double_out: *mut f64)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_q(obj: *mut libc::c_void, o: *const AVOption,
                         val: *const libc::c_char, q_out: *mut AVRational)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_find(obj: *mut libc::c_void, name: *const libc::c_char,
                       unit: *const libc::c_char, opt_flags: libc::c_int,
                       search_flags: libc::c_int) -> *const AVOption;
}
extern "C" {
    pub fn av_opt_find2(obj: *mut libc::c_void, name: *const libc::c_char,
                        unit: *const libc::c_char, opt_flags: libc::c_int,
                        search_flags: libc::c_int,
                        target_obj: *mut *mut libc::c_void)
     -> *const AVOption;
}
extern "C" {
    pub fn av_opt_next(obj: *const libc::c_void, prev: *const AVOption)
     -> *const AVOption;
}
extern "C" {
    pub fn av_opt_child_next(obj: *mut libc::c_void, prev: *mut libc::c_void)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn av_opt_child_class_next(parent: *const AVClass,
                                   prev: *const AVClass) -> *const AVClass;
}
extern "C" {
    pub fn av_opt_set(obj: *mut libc::c_void, name: *const libc::c_char,
                      val: *const libc::c_char, search_flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_int(obj: *mut libc::c_void, name: *const libc::c_char,
                          val: i64, search_flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_double(obj: *mut libc::c_void,
                             name: *const libc::c_char, val: f64,
                             search_flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_q(obj: *mut libc::c_void, name: *const libc::c_char,
                        val: AVRational, search_flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_bin(obj: *mut libc::c_void, name: *const libc::c_char,
                          val: *const u8, size: libc::c_int,
                          search_flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_image_size(obj: *mut libc::c_void,
                                 name: *const libc::c_char, w: libc::c_int,
                                 h: libc::c_int, search_flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_pixel_fmt(obj: *mut libc::c_void,
                                name: *const libc::c_char, fmt: AVPixelFormat,
                                search_flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_sample_fmt(obj: *mut libc::c_void,
                                 name: *const libc::c_char,
                                 fmt: AVSampleFormat,
                                 search_flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_video_rate(obj: *mut libc::c_void,
                                 name: *const libc::c_char, val: AVRational,
                                 search_flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_channel_layout(obj: *mut libc::c_void,
                                     name: *const libc::c_char,
                                     ch_layout: i64,
                                     search_flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_dict_val(obj: *mut libc::c_void,
                               name: *const libc::c_char,
                               val: *const AVDictionary,
                               search_flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get(obj: *mut libc::c_void, name: *const libc::c_char,
                      search_flags: libc::c_int, out_val: *mut *mut u8)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_int(obj: *mut libc::c_void, name: *const libc::c_char,
                          search_flags: libc::c_int, out_val: *mut i64)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_double(obj: *mut libc::c_void,
                             name: *const libc::c_char,
                             search_flags: libc::c_int, out_val: *mut f64)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_q(obj: *mut libc::c_void, name: *const libc::c_char,
                        search_flags: libc::c_int, out_val: *mut AVRational)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_image_size(obj: *mut libc::c_void,
                                 name: *const libc::c_char,
                                 search_flags: libc::c_int,
                                 w_out: *mut libc::c_int,
                                 h_out: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_pixel_fmt(obj: *mut libc::c_void,
                                name: *const libc::c_char,
                                search_flags: libc::c_int,
                                out_fmt: *mut AVPixelFormat) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_sample_fmt(obj: *mut libc::c_void,
                                 name: *const libc::c_char,
                                 search_flags: libc::c_int,
                                 out_fmt: *mut AVSampleFormat) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_video_rate(obj: *mut libc::c_void,
                                 name: *const libc::c_char,
                                 search_flags: libc::c_int,
                                 out_val: *mut AVRational) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_channel_layout(obj: *mut libc::c_void,
                                     name: *const libc::c_char,
                                     search_flags: libc::c_int,
                                     ch_layout: *mut i64) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_dict_val(obj: *mut libc::c_void,
                               name: *const libc::c_char,
                               search_flags: libc::c_int,
                               out_val: *mut *mut AVDictionary)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_ptr(avclass: *const AVClass, obj: *mut libc::c_void,
                      name: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_opt_freep_ranges(ranges: *mut *mut AVOptionRanges);
}
extern "C" {
    pub fn av_opt_query_ranges(arg1: *mut *mut AVOptionRanges,
                               obj: *mut libc::c_void,
                               key: *const libc::c_char, flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_copy(dest: *mut libc::c_void, src: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_query_ranges_default(arg1: *mut *mut AVOptionRanges,
                                       obj: *mut libc::c_void,
                                       key: *const libc::c_char,
                                       flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_is_set_to_default(obj: *mut libc::c_void,
                                    o: *const AVOption) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_is_set_to_default_by_name(obj: *mut libc::c_void,
                                            name: *const libc::c_char,
                                            search_flags: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn av_opt_serialize(obj: *mut libc::c_void, opt_flags: libc::c_int,
                            flags: libc::c_int,
                            buffer: *mut *mut libc::c_char,
                            key_val_sep: libc::c_char,
                            pairs_sep: libc::c_char) -> libc::c_int;
}
extern "C" {
    /**
 * Return the LIBAVDEVICE_VERSION_INT constant.
 */
    pub fn avdevice_version() -> libc::c_uint;
}
extern "C" {
    /**
 * Return the libavdevice build-time configuration.
 */
    pub fn avdevice_configuration() -> *const libc::c_char;
}
extern "C" {
    /**
 * Return the libavdevice license.
 */
    pub fn avdevice_license() -> *const libc::c_char;
}
extern "C" {
    /**
 * Initialize libavdevice and register all the input and output devices.
 */
    pub fn avdevice_register_all();
}
extern "C" {
    /**
 * Audio input devices iterator.
 *
 * If d is NULL, returns the first registered input audio/video device,
 * if d is non-NULL, returns the next registered input audio/video device after d
 * or NULL if d is the last one.
 */
    pub fn av_input_audio_device_next(d: *mut AVInputFormat)
     -> *mut AVInputFormat;
}
extern "C" {
    /**
 * Video input devices iterator.
 *
 * If d is NULL, returns the first registered input audio/video device,
 * if d is non-NULL, returns the next registered input audio/video device after d
 * or NULL if d is the last one.
 */
    pub fn av_input_video_device_next(d: *mut AVInputFormat)
     -> *mut AVInputFormat;
}
extern "C" {
    /**
 * Audio output devices iterator.
 *
 * If d is NULL, returns the first registered output audio/video device,
 * if d is non-NULL, returns the next registered output audio/video device after d
 * or NULL if d is the last one.
 */
    pub fn av_output_audio_device_next(d: *mut AVOutputFormat)
     -> *mut AVOutputFormat;
}
extern "C" {
    /**
 * Video output devices iterator.
 *
 * If d is NULL, returns the first registered output audio/video device,
 * if d is non-NULL, returns the next registered output audio/video device after d
 * or NULL if d is the last one.
 */
    pub fn av_output_video_device_next(d: *mut AVOutputFormat)
     -> *mut AVOutputFormat;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVDeviceRect {
    /**< x coordinate of top left corner */
    pub x: libc::c_int,
    /**< y coordinate of top left corner */
    pub y: libc::c_int,
    /**< width */
    pub width: libc::c_int,
    /**< height */
    pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceRect() {
    assert_eq!(::std::mem::size_of::<AVDeviceRect>() , 16usize , concat ! (
               "Size of: " , stringify ! ( AVDeviceRect ) ));
    assert_eq! (::std::mem::align_of::<AVDeviceRect>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( AVDeviceRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceRect ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceRect ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceRect ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceRect ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceRect ) ) . width as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceRect ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceRect ) ) . height as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceRect ) , "::" ,
                stringify ! ( height ) ));
}
impl Clone for AVDeviceRect {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Message types used by avdevice_app_to_dev_control_message().
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVAppToDevMessageType {
    AV_APP_TO_DEV_NONE = 1313820229,
    AV_APP_TO_DEV_WINDOW_SIZE = 1195724621,
    AV_APP_TO_DEV_WINDOW_REPAINT = 1380274241,
    AV_APP_TO_DEV_PAUSE = 1346458912,
    AV_APP_TO_DEV_PLAY = 1347174745,
    AV_APP_TO_DEV_TOGGLE_PAUSE = 1346458964,
    AV_APP_TO_DEV_SET_VOLUME = 1398165324,
    AV_APP_TO_DEV_MUTE = 541939028,
    AV_APP_TO_DEV_UNMUTE = 1431131476,
    AV_APP_TO_DEV_TOGGLE_MUTE = 1414354260,
    AV_APP_TO_DEV_GET_VOLUME = 1196838732,
    AV_APP_TO_DEV_GET_MUTE = 1196250452,
}
#[repr(u32)]
/**
 * Message types used by avdevice_dev_to_app_control_message().
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVDevToAppMessageType {
    AV_DEV_TO_APP_NONE = 1313820229,
    AV_DEV_TO_APP_CREATE_WINDOW_BUFFER = 1111708229,
    AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER = 1112560197,
    AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER = 1111771475,
    AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER = 1111770451,
    AV_DEV_TO_APP_BUFFER_OVERFLOW = 1112491596,
    AV_DEV_TO_APP_BUFFER_UNDERFLOW = 1112884812,
    AV_DEV_TO_APP_BUFFER_READABLE = 1112687648,
    AV_DEV_TO_APP_BUFFER_WRITABLE = 1113018912,
    AV_DEV_TO_APP_MUTE_STATE_CHANGED = 1129141588,
    AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = 1129729868,
}
extern "C" {
    /**
 * Send control message from application to device.
 *
 * @param s         device context.
 * @param type      message type.
 * @param data      message data. Exact type depends on message type.
 * @param data_size size of message data.
 * @return >= 0 on success, negative on error.
 *         AVERROR(ENOSYS) when device doesn't implement handler of the message.
 */
    pub fn avdevice_app_to_dev_control_message(s: *mut AVFormatContext,
                                               type_: AVAppToDevMessageType,
                                               data: *mut libc::c_void,
                                               data_size: usize)
     -> libc::c_int;
}
extern "C" {
    /**
 * Send control message from device to application.
 *
 * @param s         device context.
 * @param type      message type.
 * @param data      message data. Can be NULL.
 * @param data_size size of message data.
 * @return >= 0 on success, negative on error.
 *         AVERROR(ENOSYS) when application doesn't implement handler of the message.
 */
    pub fn avdevice_dev_to_app_control_message(s: *mut AVFormatContext,
                                               type_: AVDevToAppMessageType,
                                               data: *mut libc::c_void,
                                               data_size: usize)
     -> libc::c_int;
}
extern "C" {
    #[link_name = "av_device_capabilities"]
    pub static mut av_device_capabilities: [AVOption; 0usize];
}
extern "C" {
    /**
 * Initialize capabilities probing API based on AVOption API.
 *
 * avdevice_capabilities_free() must be called when query capabilities API is
 * not used anymore.
 *
 * @param[out] caps      Device capabilities data. Pointer to a NULL pointer must be passed.
 * @param s              Context of the device.
 * @param device_options An AVDictionary filled with device-private options.
 *                       On return this parameter will be destroyed and replaced with a dict
 *                       containing options that were not found. May be NULL.
 *                       The same options must be passed later to avformat_write_header() for output
 *                       devices or avformat_open_input() for input devices, or at any other place
 *                       that affects device-private options.
 *
 * @return >= 0 on success, negative otherwise.
 */
    pub fn avdevice_capabilities_create(caps:
                                            *mut *mut AVDeviceCapabilitiesQuery,
                                        s: *mut AVFormatContext,
                                        device_options:
                                            *mut *mut AVDictionary)
     -> libc::c_int;
}
extern "C" {
    /**
 * Free resources created by avdevice_capabilities_create()
 *
 * @param caps Device capabilities data to be freed.
 * @param s    Context of the device.
 */
    pub fn avdevice_capabilities_free(caps:
                                          *mut *mut AVDeviceCapabilitiesQuery,
                                      s: *mut AVFormatContext);
}
/**
 * Structure describes basic parameters of the device.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVDeviceInfo {
    /**< device name, format depends on device */
    pub device_name: *mut libc::c_char,
    /**< human friendly name */
    pub device_description: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_AVDeviceInfo() {
    assert_eq!(::std::mem::size_of::<AVDeviceInfo>() , 16usize , concat ! (
               "Size of: " , stringify ! ( AVDeviceInfo ) ));
    assert_eq! (::std::mem::align_of::<AVDeviceInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AVDeviceInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceInfo ) ) . device_name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceInfo ) , "::" ,
                stringify ! ( device_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AVDeviceInfo ) ) . device_description as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AVDeviceInfo ) , "::" ,
                stringify ! ( device_description ) ));
}
impl Clone for AVDeviceInfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * List devices.
 *
 * Returns available device names and their parameters.
 *
 * @note: Some devices may accept system-dependent device names that cannot be
 *        autodetected. The list returned by this function cannot be assumed to
 *        be always completed.
 *
 * @param s                device context.
 * @param[out] device_list list of autodetected devices.
 * @return count of autodetected devices, negative on error.
 */
    pub fn avdevice_list_devices(s: *mut AVFormatContext,
                                 device_list: *mut *mut AVDeviceInfoList)
     -> libc::c_int;
}
extern "C" {
    /**
 * Convenient function to free result of avdevice_list_devices().
 *
 * @param devices device list to be freed.
 */
    pub fn avdevice_free_list_devices(device_list:
                                          *mut *mut AVDeviceInfoList);
}
extern "C" {
    /**
 * List devices.
 *
 * Returns available device names and their parameters.
 * These are convinient wrappers for avdevice_list_devices().
 * Device context is allocated and deallocated internally.
 *
 * @param device           device format. May be NULL if device name is set.
 * @param device_name      device name. May be NULL if device format is set.
 * @param device_options   An AVDictionary filled with device-private options. May be NULL.
 *                         The same options must be passed later to avformat_write_header() for output
 *                         devices or avformat_open_input() for input devices, or at any other place
 *                         that affects device-private options.
 * @param[out] device_list list of autodetected devices
 * @return count of autodetected devices, negative on error.
 * @note device argument takes precedence over device_name when both are set.
 */
    pub fn avdevice_list_input_sources(device: *mut AVInputFormat,
                                       device_name: *const libc::c_char,
                                       device_options: *mut AVDictionary,
                                       device_list:
                                           *mut *mut AVDeviceInfoList)
     -> libc::c_int;
}
extern "C" {
    pub fn avdevice_list_output_sinks(device: *mut AVOutputFormat,
                                      device_name: *const libc::c_char,
                                      device_options: *mut AVDictionary,
                                      device_list: *mut *mut AVDeviceInfoList)
     -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct URLContext {
    pub _address: u8,
}
impl Clone for URLContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FFFrac {
    pub _address: u8,
}
impl Clone for FFFrac {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFilterCommand {
    pub _address: u8,
}
impl Clone for AVFilterCommand {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AVFilterChannelLayouts {
    pub _address: u8,
}
impl Clone for AVFilterChannelLayouts {
    fn clone(&self) -> Self { *self }
}
